### 4-1 資料型別 (Data Types)

#### 1. 核心概念：什麼是資料型別？

##### 1.1 資料型別的定義
在程式設計中，**資料型別 (Data Type)** 是一種對資料分類的機制，它決定了變數能夠儲存的資料種類、這些資料在記憶體中佔用多少空間，以及可以對這些資料執行哪些操作。簡單來說，它告訴電腦「這是一個數字」、「這是一個文字」或是「這是一個真/假值」。

-----

##### 1.2 為什麼需要資料型別？
資料型別的存在有幾個核心原因：
1.  **記憶體管理：** 不同種類的資料佔用不同的記憶體空間。例如，一個整數可能佔用 4 位元組，而一個單一字元可能只佔用 1 位元組。明確的資料型別讓電腦能精確地分配和管理記憶體。
2.  **資料正確性與完整性：** 資料型別確保我們只對特定種類的資料執行合法的操作。你不能把兩個數字相加，然後期望得到有意義的文字結果。它有助於在程式執行前或執行時發現潛在的錯誤。
3.  **效能優化：** 知道資料型別後，編譯器或直譯器可以選擇最有效率的方式來儲存和處理資料。
4.  **表達意圖：** 明確的資料型別讓程式碼更容易閱讀和理解，因為它清楚地表達了每個變數或值的預期用途。

-----

##### 1.3 常見的基本資料型別分類
雖然不同的程式語言會有其獨特的資料型別，但大多數語言都共享以下幾種基本分類：

*   **整數型別 (Integer Types)：** 用於儲存沒有小數部分的數字。
    *   範例：`int`, `short`, `long`, `byte` (在某些語言中，如 Java)。
    *   常見語言範例：C/C++ 的 `int`、Python 的 `int`、Java 的 `int`。

*   **浮點數型別 (Floating-Point Types)：** 用於儲存帶有小數部分的數字。
    *   範例：`float`, `double`。
    *   常見語言範例：C/C++ 的 `float` 和 `double`、Python 的 `float`、Java 的 `double`。

*   **字元型別 (Character Types)：** 用於儲存單一的文字字元，例如一個字母、數字或符號。
    *   範例：`char`。
    *   常見語言範例：C/C++ 的 `char`、Java 的 `char`。Python 沒有單獨的字元型別，單一字元被視為長度為 1 的字串。

*   **布林型別 (Boolean Types)：** 用於儲存邏輯真/假值。
    *   範例：`bool`。
    *   常見語言範例：C++ 的 `bool`、Python 的 `bool`、Java 的 `boolean`。

-----

#### 2. 典型例子與型別轉換

##### 2.1 各種型別的實際例子
以下以 Python 語言為例（因為其語法較為簡潔直觀），展示不同資料型別的實際應用：

```python
# 整數型別 (int)
age = 30
student_count = 1500

# 浮點數型別 (float)
price = 99.99
pi = 3.14159

# 字串型別 (str) - Python 沒有單一字元型別，但字串可以表達字元
first_letter = 'A'
name = "Alice"
greeting = 'Hello, world!'

# 布林型別 (bool)
is_student = True
has_discount = False

# 你可以使用 type() 函數來檢查變數的資料型別
print(f"age 的型別是：{type(age)}")             # <class 'int'>
print(f"price 的型別是：{type(price)}")         # <class 'float'>
print(f"first_letter 的型別是：{type(first_letter)}") # <class 'str'>
print(f"is_student 的型別是：{type(is_student)}") # <class 'bool'>
```
**注意：** 雖然上述範例以 Python 呈現，但核心概念適用於大多數程式語言。在 C/C++ 或 Java 等靜態型別語言中，你需要在使用變數前明確宣告其型別。

```c++
// C++ 範例
int age = 30;
double price = 99.99;
char first_letter = 'A';
bool is_student = true;
// std::string name = "Alice"; // 字串是複合型別，將在更進階的章節介紹
```

-----

##### 2.2 隱式型別轉換 (Implicit Type Conversion / Coercion)
當不同資料型別的值在運算式中混合使用時，某些程式語言會自動將一種型別轉換為另一種型別，以完成運算。這稱為**隱式型別轉換**。通常，轉換會從「較小」或「精度較低」的型別轉換為「較大」或「精度較高」的型別，以避免資料遺失。

*   **推導：** `int` $\rightarrow$ `float` $\rightarrow$ `double` (從低精度到高精度)。
    *   當整數與浮點數進行運算時，整數會被隱式轉換為浮點數。
    *   例如：`5 + 3.14` $\rightarrow$ `5.0 + 3.14` $\rightarrow$ `8.14` (結果為浮點數)。

*   **例子 (C++):**
    ```c++
    int integer_val = 10;
    double double_val = 5.5;
    double result = integer_val + double_val; // integer_val (int) 被隱式轉換為 double
    // result 將會是 15.5
    ```

*   **例子 (Python):** Python 在數值型別之間也有隱式轉換。
    ```python
    num_int = 10
    num_float = 5.5
    result = num_int + num_float # num_int 被隱式轉換為 float
    # result 將會是 15.5 (型別為 float)
    ```

-----

##### 2.3 顯式型別轉換 (Explicit Type Conversion / Type Casting)
當我們需要強制將一個值從一種型別轉換為另一種型別時，我們會使用**顯式型別轉換**，也稱為**型別鑄造 (Type Casting)**。這種轉換需要程式設計師明確地指定，因為它可能導致資料遺失（例如，將浮點數轉換為整數會丟失小數部分）。

*   **語法：** 通常是 `(目標型別) 變數` (C/C++) 或 `目標型別(變數)` (Python, Java)。

*   **例子 (C++):**
    ```c++
    double pi = 3.14159;
    int integer_pi = (int)pi; // 顯式將 double 轉換為 int
    // integer_pi 將會是 3 (小數部分被截斷)

    int num1 = 10;
    int num2 = 3;
    // double division_result = num1 / num2; // 錯誤：int / int 仍是 int，結果為 3.0
    double division_result = (double)num1 / num2; // 正確：先將 num1 轉換為 double，再進行浮點數除法
    // division_result 將會是 3.33333...
    ```

*   **例子 (Python):** Python 提供內建函數來進行顯式型別轉換。
    ```python
    num_str = "123"
    num_int = int(num_str) # 將字串 "123" 轉換為整數 123
    print(f"num_int 的型別是：{type(num_int)}") # <class 'int'>

    num_float = 3.75
    num_int_from_float = int(num_float) # 將浮點數 3.75 轉換為整數 3
    print(f"num_int_from_float: {num_int_from_float}") # 輸出 3

    int_val = 5
    float_val = float(int_val) # 將整數 5 轉換為浮點數 5.0
    print(f"float_val: {float_val}") # 輸出 5.0

    bool_val_true = bool(1) # 任何非零數值轉換為 True
    bool_val_false = bool(0) # 零值轉換為 False
    bool_val_empty_str = bool("") # 空字串轉換為 False
    print(f"bool_val_true: {bool_val_true}, bool_val_false: {bool_val_false}")
    ```

-----

#### 3. 與相鄰概念的關聯

##### 3.1 資料型別與變數
*   **變數 (Variable)** 是儲存資料的命名記憶體位置。當你宣告一個變數時，通常需要指定它的資料型別（在靜態型別語言中），這決定了變數可以儲存什麼樣的值，以及它會佔用多少記憶體。
*   **關聯：** 資料型別是變數的「藍圖」，定義了變數的屬性和行為。沒有資料型別，變數就無法有效地儲存和操作數據。

##### 3.2 資料型別與記憶體配置
*   每個資料型別都有其固定的或可變的記憶體大小。例如，在 C++ 中，`char` 通常佔用 1 位元組，`int` 佔用 4 位元組，`double` 佔用 8 位元組。
*   **關聯：** 編譯器或程式執行時會根據變數的資料型別來分配足夠的記憶體空間。了解資料型別的記憶體佔用對於資源有限的系統（如嵌入式系統）或需要處理大量資料時至關重要。

##### 3.3 資料型別與運算子
*   **運算子 (Operator)** 是執行特定操作的符號（例如 `+`, `-`, `*`, `/`, `=`, `==`, `<`, `>`)。
*   **關聯：** 運算子對不同資料型別的操作方式可能不同。
    *   `+` 對於數字是加法，對於字串可能是連接 (concatenation)。
    *   `/` 對於整數可能是整數除法（結果截斷），對於浮點數是浮點數除法。
    *   比較運算子 (`==`, `<`, `>`) 依賴於資料型別來進行正確的比較。
*   資料型別也決定了哪些運算子可以應用於特定資料。你不能對布林值使用除法運算。

-----

#### 4. 進階內容

##### 4.1 資料型別的記憶體大小與數值範圍
不同的資料型別不僅佔用不同的記憶體空間，也因此能表示不同的數值範圍。

以 C/C++ 為例（具體大小可能因編譯器和平台而異，但通常遵循以下模式）：
| 型別     | 通常大小 (位元組) | 可能範圍 (範例)                       |
| :------- | :---------------- | :------------------------------------ |
| `char`   | 1                 | -128 到 127 或 0 到 255 (根據簽名/無簽名) |
| `short`  | 2                 | -32,768 到 32,767                     |
| `int`    | 4                 | -2,147,483,648 到 2,147,483,647         |
| `long`   | 4 或 8            | 與 `int` 或 `long long` 相同          |
| `long long` | 8                 | 很大 (約 $\pm 9 \times 10^{18}$)      |
| `float`  | 4                 | 約 $\pm 3.4 \times 10^{38}$ (7 位有效數字) |
| `double` | 8                 | 約 $\pm 1.7 \times 10^{308}$ (15 位有效數字) |
| `bool`   | 1                 | `true` 或 `false`                     |

*   **溢位 (Overflow)：** 當一個變數嘗試儲存超出其型別範圍的值時，就會發生溢位。這可能導致不正確的結果。
    *   範例：如果一個 `char` 型別的變數（最大值 127）被賦予 128，它可能會「捲繞」到 -128 (對於帶符號的 `char`)。

##### 4.2 型別安全 (Type Safety)
*   **定義：** 型別安全是指程式語言或其型別系統能夠在編譯時期或執行時期，檢查並防止型別不匹配的錯誤。一個型別安全的語言會盡量避免將一個型別的值當作另一個不相容的型別來使用。
*   **強型別 vs 弱型別：**
    *   **強型別 (Strongly Typed)：** 嚴格要求型別匹配，不允許隱式地進行不安全的型別轉換。例如 Java 和 C#。它們會強制執行型別檢查，減少運行時錯誤。
    *   **弱型別 (Weakly Typed)：** 允許更多隱式的型別轉換，甚至是不安全的轉換。例如 JavaScript 和 PHP。這提供了更大的彈性，但也增加了運行時型別錯誤的風險。
    *   **靜態型別 vs 動態型別：**
        *   **靜態型別 (Statically Typed)：** 型別檢查在編譯時期進行。變數的型別在編譯時就確定，且不能改變。例如 C++, Java。
        *   **動態型別 (Dynamically Typed)：** 型別檢查在執行時期進行。變數的型別在執行時才確定，且可以在運行時改變。例如 Python, JavaScript。

-----

#### 5. 常見錯誤與澄清

##### 5.1 整數除法 vs 浮點數除法
*   **錯誤：** 預期兩個整數相除會得到浮點數結果。
    ```c++
    int a = 10;
    int b = 3;
    double result = a / b; // result 得到 3.0，而非 3.333...
    ```
*   **澄清：** 在許多語言中（如 C/C++），如果運算元都是整數，則 `a / b` 會執行整數除法，結果的小數部分會被截斷。
*   **正確做法：** 至少將其中一個運算元轉換為浮點數型別。
    ```c++
    double result = (double)a / b; // result 得到 3.333...
    // 或者 double result = a / (double)b;
    // 或者 double result = a / 3.0;
    ```
    在 Python 中 `/` 運算符默認執行浮點數除法，`//` 執行整數除法。

##### 5.2 浮點數精度問題
*   **錯誤：** 認為浮點數可以精確表示所有實數，特別是在比較相等時。
    ```python
    x = 0.1 + 0.2
    print(x == 0.3) # 可能輸出 False
    ```
*   **澄清：** 大多數浮點數以二進位表示，這意味著有些小數（例如 0.1, 0.2）無法被精確表示，會產生微小的捨入誤差。因此，直接比較兩個浮點數是否相等通常是不可靠的。
*   **正確做法：** 比較兩個浮點數是否在一個非常小的誤差範圍內。
    ```python
    epsilon = 1e-9 # 設定一個很小的容忍誤差
    print(abs(x - 0.3) < epsilon) # 輸出 True
    ```

##### 5.3 字元與字串的區別
*   **錯誤：** 混淆單一字元與字串。
    *   在 C/C++ 和 Java 中，`'A'` 是 `char` (單一字元)，而 `"A"` 是 `String` (字串，是字元序列，通常以陣列實現)。
*   **澄清：**
    *   **字元 (Character)：** 通常用單引號 `' '` 表示，儲存單一的文字符號。
    *   **字串 (String)：** 通常用雙引號 `" "` 表示，是零個或多個字元組成的序列。
*   **注意：** Python 較為特殊，沒有單獨的 `char` 型別，單一字元也是長度為 1 的字串。

##### 5.4 型別不匹配的運算
*   **錯誤：** 嘗試對不相容的型別進行運算，例如將數字與布林值直接相加。
    ```c++
    int num = 5;
    bool is_valid = true;
    // int result = num + is_valid; // 在 C++ 中，true 會被轉換為 1，所以這是合法的，但可能不是本意
    // 這在強型別語言如 Java 中會是編譯錯誤
    ```
*   **澄清：** 儘管某些語言允許隱式轉換，但通常最好明確地處理不同型別之間的運算，確保它們在邏輯上是相容的。這可以透過顯式型別轉換來實現，以避免意外行為。

-----

#### 6. 小練習

##### 小練習 1：判斷資料型別與數值範圍
請判斷以下 C++ 程式碼片段中變數的資料型別，並思考其可能的數值範圍及潛在問題。

```c++
int a = 100000;
short b = 50000;
char c = 'X';
double d = 1.23456789;
bool e = true;
```

**詳解：**

1.  `a = 100000;`
    *   **資料型別：** `int` (整數型別)
    *   **數值範圍：** 通常為 4 位元組，範圍約在 $\pm 2 \times 10^9$ 之間。`100000` 在此範圍內，沒有問題。

2.  `b = 50000;`
    *   **資料型別：** `short` (短整數型別)
    *   **數值範圍：** 通常為 2 位元組，範圍約在 -32,768 到 32,767 之間。
    *   **潛在問題：** `50000` 超出了 `short` 的最大正數範圍 (32,767)。這會導致**溢位 (Overflow)**。變數 `b` 的實際值將會是一個不正確的負數（例如：-15536，具體數值取決於系統和編譯器處理溢位的方式）。

3.  `c = 'X';`
    *   **資料型別：** `char` (字元型別)
    *   **數值範圍：** 1 位元組，儲存單一字元。對應 ASCII 或 Unicode 值。 `'X'` 的 ASCII 值為 88，在 `char` 的範圍內。

4.  `d = 1.23456789;`
    *   **資料型別：** `double` (雙精度浮點數型別)
    *   **數值範圍：** 通常為 8 位元組，提供約 15-17 位有效數字的精度。此數值在 `double` 的表示範圍內。

5.  `e = true;`
    *   **資料型別：** `bool` (布林型別)
    *   **數值範圍：** 儲存 `true` 或 `false`。

-----

##### 小練習 2：型別轉換的結果預測
請預測以下 Python 程式碼的輸出結果（值和型別）。

```python
val1 = 10
val2 = 3.5
val3 = "20"
val4 = "Hello"

# 運算 1
result1 = val1 + val2

# 運算 2
result2 = int(val2)

# 運算 3
result3 = val1 + int(val3)

# 運算 4
result4 = float(val1) / 4

# 運算 5
result5 = str(val1) + val4

print(f"Result 1: {result1}, Type: {type(result1)}")
print(f"Result 2: {result2}, Type: {type(result2)}")
print(f"Result 3: {result3}, Type: {type(result3)}")
print(f"Result 4: {result4}, Type: {type(result4)}")
print(f"Result 5: {result5}, Type: {type(result5)}")
```

**詳解：**

1.  `result1 = val1 + val2`
    *   `val1` 是 `int` (10)，`val2` 是 `float` (3.5)。
    *   發生隱式型別轉換：`val1` 被轉換為 `float` (10.0)。
    *   運算：`10.0 + 3.5 = 13.5`。
    *   **結果 1：** 值 `13.5`，型別 `<class 'float'>`。

2.  `result2 = int(val2)`
    *   `val2` 是 `float` (3.5)。
    *   `int()` 函數將浮點數顯式轉換為整數，會截斷小數部分。
    *   運算：`int(3.5) = 3`。
    *   **結果 2：** 值 `3`，型別 `<class 'int'>`。

3.  `result3 = val1 + int(val3)`
    *   `val1` 是 `int` (10)，`val3` 是 `str` ("20")。
    *   `int(val3)` 將字串 "20" 顯式轉換為整數 20。
    *   運算：`10 + 20 = 30`。
    *   **結果 3：** 值 `30`，型別 `<class 'int'>`。

4.  `result4 = float(val1) / 4`
    *   `val1` 是 `int` (10)。
    *   `float(val1)` 將 `val1` 顯式轉換為 `float` (10.0)。
    *   運算：`10.0 / 4`。在 Python 中 `/` 總是產生浮點數結果。
    *   運算：`10.0 / 4.0 = 2.5`。
    *   **結果 4：** 值 `2.5`，型別 `<class 'float'>`。

5.  `result5 = str(val1) + val4`
    *   `val1` 是 `int` (10)，`val4` 是 `str` ("Hello")。
    *   `str(val1)` 將 `val1` 顯式轉換為字串 "10"。
    *   運算：字串連接 `"10" + "Hello" = "10Hello"`。
    *   **結果 5：** 值 `"10Hello"`，型別 `<class 'str'>`。

-----

#### 7. 延伸閱讀

*   **特定程式語言的資料型別：**
    *   [Java 資料型別](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
    *   [C++ 基本型別](https://www.learncpp.com/cpp-tutorial/fundamental-data-types/)
    *   [Python 內建型別](https://docs.python.org/3/library/stdtypes.html)
*   **型別系統 (Type System)：** 更深入探討程式語言如何分類、使用和檢查資料型別的規則。這包括靜態型別、動態型別、強型別、弱型別等概念。
*   **記憶體管理：** 了解變數和資料型別在電腦記憶體中的實際儲存方式，以及記憶體位址、指標 (pointers) 等相關概念。
*   **浮點數標準 IEEE 754：** 深入了解浮點數在電腦中如何表示，以及為什麼會存在精度問題。