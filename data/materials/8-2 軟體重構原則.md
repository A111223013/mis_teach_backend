# 軟體重構原則 (8-2 Refactoring Principles)

重構是軟體開發中一項核心技能，它允許開發者在不改變軟體外部行為的前提下，改善其內部結構。這不僅能提高程式碼的可讀性與可維護性，更能為未來的擴展和修改打下堅實的基礎。

-----

### 1. 核心概念與定義

#### 1.1 什麼是軟體重構？

軟體重構 (Refactoring) 是一種對現有程式碼進行結構性調整的過程，其核心目標是在不改變程式碼外部行為（功能、介面）的前提下，改善其內部結構。想像一下，你正在重新整理一個房間，傢俱的位置改變了，但房間的總體功能（居住）並未改變，反而變得更整潔、更實用。

*   **定義：** 不改變軟體的外部行為，僅改善其內部結構的過程。
*   **關鍵詞：** 外部行為不變 (Behavior-preserving)，內部結構改善 (Internal structure improvement)。

#### 1.2 重構的目的

重構並非為了增加新功能，而是為了使程式碼更健康、更易於管理。其主要目的包括：

*   **提高可讀性與理解性：** 清晰的結構和命名讓程式碼更易於理解，降低新人上手門檻。
*   **提高可維護性：** 良好的結構減少了錯誤引入的可能性，也使修改和擴展更為方便。
*   **提高可擴展性：** 高內聚、低耦合的設計更容易應對未來的需求變化。
*   **降低複雜度：** 將複雜邏輯分解為簡單的單元，減少認知負擔。
*   **消除程式碼異味 (Code Smells)：** 解決重複程式碼、過大的類別/函式、魔術數字等問題。
*   **發現潛在的錯誤：** 在重構過程中，有時能暴露原先隱藏的設計缺陷或邏輯錯誤。

#### 1.3 重構的時機

重構不應是專案結束後的「清理工作」，而應融入日常開發流程中：

*   **新增功能之前：** 當需要為現有模組添加新功能時，先重構使其更易於擴展。
*   **修復錯誤時：** 在修復 Bug 的同時，審視相關程式碼，消除潛在的結構問題。
*   **程式碼審查 (Code Review) 時：** 透過團隊成員的審查，發現重構機會。
*   **理解程式碼時：** 當你發現某段程式碼難以理解時，就是重構的好時機。
*   **演進式設計的一部分：** 重構是持續改進設計的手段。
*   **避免『腐爛的蘋果』效應：** 及時處理程式碼異味，防止其擴散。

-----

### 2. 典型重構技巧與例子

重構有多種模式或技巧，以下列舉幾個最常用且具有代表性的。

#### 2.1 提取函式 (Extract Method)

*   **定義：** 將一段邏輯獨立、重複出現或過長的程式碼片段，提取為一個新的函式。
*   **核心觀念：** 提高程式碼的內聚性、可讀性，消除重複程式碼。
*   **例子：**

    **重構前：**
    ```python
    def print_order_details(order):
        # 打印客戶資訊
        print(f"客戶名稱: {order.customer.name}")
        print(f"客戶地址: {order.customer.address}")

        # 計算訂單總價
        total_price = 0
        for item in order.items:
            total_price += item.price * item.quantity
        print(f"訂單總價: {total_price} 元")

        # 打印付款狀態
        if order.is_paid:
            print("付款狀態: 已支付")
        else:
            print("付款狀態: 待支付")
    ```

    **重構後（提取 `print_customer_info` 和 `calculate_total_price`）：**
    ```python
    def print_customer_info(customer):
        print(f"客戶名稱: {customer.name}")
        print(f"客戶地址: {customer.address}")

    def calculate_total_price(items):
        total_price = 0
        for item in items:
            total_price += item.price * item.quantity
        return total_price

    def print_order_details(order):
        print_customer_info(order.customer) # 使用提取出的函式

        total = calculate_total_price(order.items) # 使用提取出的函式
        print(f"訂單總價: {total} 元")

        # 打印付款狀態
        if order.is_paid:
            print("付款狀態: 已支付")
        else:
            print("付款狀態: 待支付")
    ```
*   **與相鄰概念的關聯：** 函式應當只做一件事 (Single Responsibility Principle)，提取函式有助於遵循此原則。

#### 2.2 重新命名 (Rename)

*   **定義：** 給變數、函式、類別、檔案等元素一個更具描述性、清晰、無歧義的名稱。
*   **核心觀念：** 提高程式碼的可讀性，減少誤解。命名是程式碼自解釋的關鍵。
*   **例子：**

    **重構前：**
    ```java
    class UserProcessor {
        void proc(List<User> usrs) {
            for (User u : usrs) {
                // ...
            }
        }
    }
    ```

    **重構後：**
    ```java
    class UserAccountManager { // 'UserProcessor' 改為 'UserAccountManager' 更清晰
        void processUsers(List<User> users) { // 'proc' 改為 'processUsers'，'usrs' 改為 'users'
            for (User user : users) {
                // ...
            }
        }
    }
    ```
*   **與相鄰概念的關聯：** 好的命名是撰寫清晰程式碼的基石，也與程式碼審查密切相關。

#### 2.3 取代魔術數字/字串為常數 (Replace Magic Number/String with Symbolic Constant)

*   **定義：** 將硬編碼 (Hard-coded) 在程式碼中的數值或字串，替換為具有明確名稱的常數。
*   **核心觀念：** 提高程式碼的可讀性、可維護性和一致性，避免重複修改。
*   **例子：**

    **重構前：**
    ```javascript
    function calculateShippingCost(weight) {
        if (weight > 10) { // '10' 是什麼？
            return weight * 5; // '5' 是什麼費率？
        } else {
            return weight * 3; // '3' 是什麼費率？
        }
    }

    function getOrderStatus(statusCode) {
        if (statusCode === 1) { // '1' 是什麼狀態？
            return "待處理";
        } else if (statusCode === 2) { // '2' 是什麼狀態？
            return "已發貨";
        }
        return "未知";
    }
    ```

    **重構後：**
    ```javascript
    const MAX_LIGHT_WEIGHT = 10;
    const HEAVY_WEIGHT_RATE = 5;
    const LIGHT_WEIGHT_RATE = 3;

    const ORDER_STATUS_PENDING = 1;
    const ORDER_STATUS_SHIPPED = 2;

    function calculateShippingCost(weight) {
        if (weight > MAX_LIGHT_WEIGHT) {
            return weight * HEAVY_WEIGHT_RATE;
        } else {
            return weight * LIGHT_WEIGHT_RATE;
        }
    }

    function getOrderStatus(statusCode) {
        if (statusCode === ORDER_STATUS_PENDING) {
            return "待處理";
        } else if (statusCode === ORDER_STATUS_SHIPPED) {
            return "已發貨";
        }
        return "未知";
    }
    ```
*   **與相鄰概念的關聯：** 這是程式碼可讀性與可維護性的基礎，特別適用於業務規則或系統配置。

#### 2.4 移動函式/欄位 (Move Method/Field)

*   **定義：** 將函式或欄位從一個類別移動到另一個更合適的類別，以提高類別的內聚性並降低耦合性。
*   **核心觀念：** 確保每個類別只負責其應負責的功能和數據，遵循單一職責原則。
*   **例子：**

    **重構前：`Customer` 類別中包含了計算訂單總價的函式。**
    ```python
    class Order:
        def __init__(self, order_id, items, customer_id):
            self.order_id = order_id
            self.items = items # 列表，每個元素有 price 和 quantity
            self.customer_id = customer_id

    class Customer:
        def __init__(self, customer_id, name):
            self.customer_id = customer_id
            self.name = name

        def calculate_order_total(self, order): # 這個函式應該屬於 Order 類別
            total = 0
            for item in order.items:
                total += item.price * item.quantity
            return total

    # 使用範例
    order1 = Order("123", [{"price": 100, "quantity": 2}], "C001")
    customer1 = Customer("C001", "張三")
    print(f"訂單 {order1.order_id} 總價: {customer1.calculate_order_total(order1)}")
    ```

    **重構後：將 `calculate_order_total` 函式移動到 `Order` 類別。**
    ```python
    class Order:
        def __init__(self, order_id, items, customer_id):
            self.order_id = order_id
            self.items = items
            self.customer_id = customer_id

        def calculate_total(self): # 函式被移動到 Order 類別並重新命名
            total = 0
            for item in self.items:
                total += item.price * item.quantity
            return total

    class Customer:
        def __init__(self, customer_id, name):
            self.customer_id = customer_id
            self.name = name

    # 使用範例
    order1 = Order("123", [{"price": 100, "quantity": 2}], "C001")
    customer1 = Customer("C001", "張三") # 現在客戶不需要知道如何計算訂單總價
    print(f"訂單 {order1.order_id} 總價: {order1.calculate_total()}")
    ```
*   **與相鄰概念的關聯：** 這是物件導向設計中高內聚、低耦合原則的直接應用。

-----

### 3. 與相鄰概念的關聯

#### 3.1 重構與設計模式 (Design Patterns)

重構和設計模式是相輔相成的。

*   **應用設計模式：** 重構可以使程式碼更容易應用某個設計模式。例如，透過提取介面、推廣欄位等，為引入策略模式或工廠模式做準備。
*   **去除設計模式：** 有時，過度或錯誤地應用設計模式會使程式碼變得複雜，重構可以用於簡化或移除不合適的設計模式。
*   **模式的演化：** 程式碼可能從簡單開始，透過重構逐漸演化出符合某個設計模式的結構。

#### 3.2 重構與測試驅動開發 (Test-Driven Development, TDD)

TDD 的經典循環是「紅-綠-重構 (Red-Green-Refactor)」。

1.  **紅 (Red)：** 編寫一個失敗的測試，以驗證新功能或修復的 Bug。
2.  **綠 (Green)：** 編寫最少量的程式碼，使測試通過。
3.  **重構 (Refactor)：** 在所有測試都通過的前提下，重構程式碼，改善其內部結構。

在這個循環中，全面的自動化測試是重構的「安全網」。它確保你在改變程式碼內部結構時，不會無意中改變外部行為或引入新的錯誤。

#### 3.3 重構與程式碼異味 (Code Smells)

程式碼異味是程式碼中可能預示著更深層次問題的跡象。重構是消除這些異味的主要手段。

*   **常見異味：** 重複程式碼 (Duplicated Code)、過大的類別/函式 (Large Class/Long Method)、魔術數字/字串 (Magic Numbers/Strings)、霰彈式修改 (Shotgun Surgery, 單一修改需要變更多處程式碼) 等。
*   **重構的應用：** 提取函式解決重複程式碼和長函式；移動函式/欄位解決過大的類別和低內聚問題；取代魔術數字/字串為常數提高可維護性。

#### 3.4 重構與性能優化

雖然兩者都涉及改變程式碼，但它們的優先級和目標不同。

*   **重構：** 主要目標是改善程式碼結構，提高可讀性、可維護性。通常在功能正確且測試通過後進行。
*   **性能優化：** 主要目標是提高程式碼執行效率，降低資源消耗。通常在性能瓶頸被識別後才進行。

良好的程式碼結構通常有助於後續的性能優化，因為它更容易識別和隔離性能熱點。不建議在程式碼結構混亂時盲目進行性能優化，那可能導致程式碼更難以維護。

-----

### 4. 進階內容

#### 4.1 重構工具的應用

現代 IDE (如 IntelliJ IDEA, Visual Studio Code, Eclipse) 提供了強大的重構工具，可以自動化執行許多常見的重構操作，如：

*   重新命名 (Rename)
*   提取函式/變數/常數 (Extract Method/Variable/Constant)
*   移動函式/類別 (Move Method/Class)
*   提取介面 (Extract Interface)

使用這些工具能確保重構的準確性（例如，重新命名一個變數會自動更新所有引用），並提高效率。但開發者仍需理解重構的原則和目的，避免盲目使用。

#### 4.2 大型重構的策略

對於大型、複雜或歷史悠久的系統，重構可能需要更謹慎的策略：

1.  **準備測試：** 如果缺乏足夠的測試覆蓋，先為需要重構的區域編寫測試，建立安全網。
2.  **小步快跑：** 每次只做一個小的、原子性的重構操作，確保每次改動後程式碼仍然可運行且所有測試都通過。
3.  **分層重構：** 從底層模組或核心邏輯開始，逐步向上重構。
4.  **功能凍結：** 在進行大規模重構時，盡量避免同時開發新功能，以減少衝突和複雜性。
5.  **版本控制：** 頻繁提交到版本控制系統，便於追溯和回滾。
6.  **團隊協作：** 確保團隊所有成員都理解重構的目的和策略。

-----

### 5. 常見錯誤與澄清

#### 5.1 誤解一：重構就是重寫 (Rewrite)

*   **澄清：** 重構是小步、漸進式地改善現有程式碼的內部結構，每次改動後都確保功能不變。重寫是推倒重來，從零開始重新撰寫程式碼。重構的風險遠低於重寫，且更具可控性。

#### 5.2 誤解二：重構會引入 Bug

*   **澄清：** 如果在有充分測試覆蓋的情況下進行重構，並且遵循小步快跑的原則，重構引入 Bug 的風險會大大降低。自動化測試是重構的基石，它提供了信心去改變程式碼。

#### 5.3 誤解三：重構是浪費時間

*   **澄清：** 從短期看，重構似乎沒有直接產生新功能。但從長遠看，它大大降低了未來維護、擴展和修復錯誤的成本。不進行重構的程式碼會逐漸腐爛，累積技術債，最終變得難以維護。這是對未來效率的投資。

#### 5.4 何時不重構？

並非所有情況都適合立即重構：

*   **專案時程極其緊迫：** 在交付壓力巨大時，可能需要優先完成功能，但要清楚這會累積技術債。
*   **程式碼即將被移除：** 如果某段程式碼很快就會被淘汰或重寫，那麼花時間重構它可能是浪費。
*   **缺乏測試的遺留系統：** 在沒有任何測試保護的「危險區域」，盲目重構風險極高，此時應優先編寫測試。

-----

### 6. 小練習（附詳解）

#### 小練習一：提取函式 (Extract Method)

以下 Python 程式碼負責處理一個購物車的結帳邏輯，請將計算總價和打印結帳單的邏輯提取為獨立的函式。

```python
class Item:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

def checkout(cart_items, customer_name, discount_percentage):
    print(f"--- 結帳單 ---")
    print(f"客戶：{customer_name}")
    print(f"折扣：{discount_percentage * 100}%")
    print("商品列表：")
    
    total_amount = 0
    for item in cart_items:
        item_total = item.price * item.quantity
        print(f"- {item.name} x {item.quantity} @ ${item.price} = ${item_total}")
        total_amount += item_total

    final_amount = total_amount * (1 - discount_percentage)
    print(f"原始總價：${total_amount:.2f}")
    print(f"最終付款：${final_amount:.2f}")
    print(f"---------------")

# 範例使用
items = [
    Item("筆記本", 50, 2),
    Item("原子筆", 10, 5),
    Item("鉛筆盒", 30, 1)
]
checkout(items, "小明", 0.1)
```

**你的任務：**
1.  提取一個函式 `calculate_cart_total(cart_items)`，用於計算購物車中所有商品的原始總價。
2.  提取一個函式 `print_receipt(customer_name, discount_percentage, total_amount, final_amount, cart_items)`，用於打印結帳單的所有細節。

**步驟提示：**
1.  找出計算總價的程式碼段。
2.  找出打印結帳單所有資訊的程式碼段。
3.  定義新函式的簽名（名稱、參數）。
4.  將原始程式碼段移動到新函式中。
5.  在原位置調用新函式。

-----

#### 詳解一：提取函式

```python
class Item:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

def calculate_cart_total(cart_items):
    """計算購物車中所有商品的原始總價"""
    total_amount = 0
    for item in cart_items:
        total_amount += item.price * item.quantity
    return total_amount

def print_receipt(customer_name, discount_percentage, total_amount, final_amount, cart_items):
    """打印結帳單的所有細節"""
    print(f"--- 結帳單 ---")
    print(f"客戶：{customer_name}")
    print(f"折扣：{discount_percentage * 100}%")
    print("商品列表：")
    
    for item in cart_items:
        item_total = item.price * item.quantity
        print(f"- {item.name} x {item.quantity} @ ${item.price} = ${item_total}")

    print(f"原始總價：${total_amount:.2f}")
    print(f"最終付款：${final_amount:.2f}")
    print(f"---------------")

def checkout(cart_items, customer_name, discount_percentage):
    # 1. 計算原始總價
    total_amount = calculate_cart_total(cart_items)

    # 2. 計算最終付款金額
    final_amount = total_amount * (1 - discount_percentage)

    # 3. 打印結帳單
    print_receipt(customer_name, discount_percentage, total_amount, final_amount, cart_items)

# 範例使用
items = [
    Item("筆記本", 50, 2),
    Item("原子筆", 10, 5),
    Item("鉛筆盒", 30, 1)
]
checkout(items, "小明", 0.1)
```
**說明：**
通過提取函式，`checkout` 函式變得更短，其職責更清晰，只需協調計算和打印。`calculate_cart_total` 函式現在可以獨立測試或在其他地方重複使用。`print_receipt` 函式也獨立了打印邏輯，使其更容易修改打印格式而不會影響計算邏輯。

-----

#### 小練習二：取代魔術數字為常數 (Replace Magic Number with Symbolic Constant)

以下 Java 程式碼片段中包含了一些「魔術數字」，請將它們替換為具有描述性的常數。

```java
public class OrderProcessor {
    public double calculateDiscount(double amount, int customerType) {
        double discount = 0;
        if (customerType == 1) { // 普通客戶
            if (amount > 1000) {
                discount = amount * 0.1; // 10% 折扣
            }
        } else if (customerType == 2) { // VIP 客戶
            if (amount > 500) {
                discount = amount * 0.15; // 15% 折扣
            } else {
                discount = amount * 0.05; // 5% 折扣
            }
        }
        return discount;
    }
}
```

**你的任務：**
1.  為 `customerType` 的值 `1` 和 `2` 定義常數。
2.  為折扣金額的閾值 `1000` 和 `500` 定義常數。
3.  為各個折扣比例 `0.1`, `0.15`, `0.05` 定義常數。

**步驟提示：**
1.  在類別內部或外部定義 `public static final` 常數。
2.  給常數取一個清楚、大寫且使用底線分隔的名稱。
3.  將所有出現的魔術數字替換為對應的常數。

-----

#### 詳解二：取代魔術數字為常數

```java
public class OrderProcessor {
    // 定義客戶類型常數
    public static final int CUSTOMER_TYPE_REGULAR = 1;
    public static final int CUSTOMER_TYPE_VIP = 2;

    // 定義折扣閾值常數
    public static final double DISCOUNT_THRESHOLD_REGULAR = 1000.0;
    public static final double DISCOUNT_THRESHOLD_VIP = 500.0;

    // 定義折扣比例常數
    public static final double DISCOUNT_RATE_REGULAR = 0.10;   // 10%
    public static final double DISCOUNT_RATE_VIP_HIGH = 0.15; // 15% for VIP > 500
    public static final double DISCOUNT_RATE_VIP_LOW = 0.05;  // 5% for VIP <= 500

    public double calculateDiscount(double amount, int customerType) {
        double discount = 0;
        if (customerType == CUSTOMER_TYPE_REGULAR) {
            if (amount > DISCOUNT_THRESHOLD_REGULAR) {
                discount = amount * DISCOUNT_RATE_REGULAR;
            }
        } else if (customerType == CUSTOMER_TYPE_VIP) {
            if (amount > DISCOUNT_THRESHOLD_VIP) {
                discount = amount * DISCOUNT_RATE_VIP_HIGH;
            } else {
                discount = amount * DISCOUNT_RATE_VIP_LOW;
            }
        }
        return discount;
    }
}
```
**說明：**
現在程式碼的可讀性大大提高。任何開發者在看到 `CUSTOMER_TYPE_REGULAR` 時就能立刻理解其含義，而不再需要猜測 `1` 代表什麼。當折扣比例或閾值需要修改時，只需修改常數定義處，而非在程式碼中搜尋多處實例，這極大地提高了可維護性並降低了出錯的可能性。

-----

### 7. 延伸閱讀/參考

*   **《Refactoring: Improving the Design of Existing Code》** by Martin Fowler
    *   這本書是重構領域的經典之作，詳細介紹了各種重構手法及其應用場景，是所有軟體開發者的必讀。
*   **《Clean Code: A Handbook of Agile Software Craftsmanship》** by Robert C. Martin
    *   雖然不完全是關於重構，但書中關於程式碼整潔、可讀性和維護性的原則，是重構思想的基礎。
*   **《The Pragmatic Programmer: Your Journey to Mastery》** by David Thomas and Andrew Hunt
    *   書中提倡「破窗理論」和「DRY (Don't Repeat Yourself)」原則，這些都是驅動重構的重要思想。
*   **線上資源：**
    *   Martin Fowler 的個人網站 (martinfowler.com) 上有大量關於重構和軟體設計的文章。
    *   許多 IDE 的官方文件也提供了重構工具的使用指南。