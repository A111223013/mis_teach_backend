# Chapter 1 資料結構簡介

### 1.1 什麼是資料結構？

#### 1.1.1 核心概念與定義

在電腦科學中，**資料結構 (Data Structure)** 是一種儲存、組織資料的方式，旨在讓資料能夠被有效率地存取、修改與管理。想像一下你的書架：你可以隨意堆放書籍，但如果你按照主題、作者或出版年份來組織它們，你會發現查找特定書籍變得更加快速和容易。資料結構之於電腦資料，就像組織良好的書架之於你的書籍。

它的主要目標是：
*   **優化資料處理：** 選擇合適的資料結構可以大幅提升演算法的效率，減少執行時間和記憶體消耗。
*   **組織複雜資料：** 將不同性質的資料以邏輯的方式連結起來，以便於程式設計師理解和操作。
*   **支援各種演算法：** 許多演算法的效能都高度依賴於其所使用的資料結構。

資料結構不只是資料的集合，更包含了這些資料之間的**關係**以及對這些資料可以執行的**操作**。

-----

#### 1.1.2 為什麼我們需要資料結構？

當處理大量或複雜的資料時，直接使用簡單的變數或未經組織的記憶體空間將變得效率極低，甚至是不可能。

**例子：**
假設我們要儲存一百萬名學生的姓名和成績。

*   **無組織方式：** 如果我們為每個學生的姓名和成績都建立兩個獨立的變數（例如 `student1Name`, `student1Grade`, `student2Name`, `student2Grade`...），那麼我們將需要兩百萬個變數。這不僅難以管理，而且要查找特定學生或計算平均成績將會非常耗時。
*   **使用陣列 (Array)：** 我們可以將所有學生姓名儲存在一個姓名陣列中，所有成績儲存在一個成績陣列中。這樣至少資料有了統一的入口點。但如果我們要根據姓名查找成績，仍然需要遍歷整個姓名陣列。
*   **使用更進階的資料結構 (例如雜湊表或樹)：** 如果我們將學生的姓名和成績以更精巧的結構（例如一個包含姓名和成績的物件列表，或是一個以姓名為鍵的雜湊表）儲存，那麼查找、插入和刪除操作都可以變得極其迅速。

從上述例子可以看出，選擇正確的資料結構對於解決問題的效率至關重要。它能讓程式碼更簡潔、更有效率、更容易維護。

-----

#### 1.1.3 抽象資料型態 (ADT) 與資料結構 (Data Structure)

這兩者經常被混淆，但它們代表著不同的抽象層次。

*   **抽象資料型態 (Abstract Data Type, ADT)：**
    *   **定義/核心觀念：** ADT 是對資料型態及其操作行為的數學模型描述，它**只定義了行為，不涉及具體實現細節**。它回答「這個資料型態能做什麼？」的問題。想像一個「清單 (List)」的ADT，它會定義「新增元素」、「刪除元素」、「搜尋元素」等操作，但不會說清單內部是用陣列還是連結串列實現。
    *   **例子：** 堆疊 (Stack)、佇列 (Queue)、清單 (List)、映射 (Map/Dictionary) 都是典型的 ADT。我們知道堆疊是「後進先出 (LIFO)」的，有 `push` 和 `pop` 操作，但具體如何實現 LIFO 行為則不屬於 ADT 的範疇。

*   **資料結構 (Data Structure)：**
    *   **定義/核心觀念：** 資料結構是 ADT 的**具體實作**。它回答「這個資料型態是如何實現的？」的問題。它包含了底層記憶體組織方式和操作的演算法細節。
    *   **例子：** 陣列 (Array)、連結串列 (Linked List)、二元樹 (Binary Tree)、雜湊表 (Hash Table) 都是資料結構。你可以用陣列來實現清單 ADT，也可以用連結串列來實現清單 ADT。

**與相鄰概念的關聯：**
ADT 是「WHAT」，資料結構是「HOW」。一個 ADT 可以有多種資料結構來實現，而不同的資料結構在實現相同的 ADT 時，其效能（時間和空間複雜度）可能會大相徑庭。理解這兩者的區別，有助於我們在設計系統時，先思考資料的邏輯行為（ADT），再選擇最適合的實作方式（資料結構）。

-----

### 1.2 資料結構的分類

資料結構有多種分類方式，以下是常見的幾種：

#### 1.2.1 依照組織方式

*   **線性資料結構 (Linear Data Structures)：**
    *   **核心觀念：** 元素之間存在一對一的順序關係，每個元素除了第一個和最後一個外，都有唯一的前驅和後繼。
    *   **例子：** 陣列 (Array)、連結串列 (Linked List)、堆疊 (Stack)、佇列 (Queue)。
*   **非線性資料結構 (Non-linear Data Structures)：**
    *   **核心觀念：** 元素之間存在一對多或多對多的關係，不只是一條直線的序列。
    *   **例子：** 樹 (Tree)、圖 (Graph)、雜湊表 (Hash Table)。

-----

#### 1.2.2 依照記憶體分配

*   **靜態資料結構 (Static Data Structures)：**
    *   **核心觀念：** 在程式編譯時就確定其大小，運行時無法改變。記憶體在堆疊 (Stack) 或資料段 (Data Segment) 分配。
    *   **例子：** 傳統陣列 (C/C++ 中的固定大小陣列)。
*   **動態資料結構 (Dynamic Data Structures)：**
    *   **核心觀念：** 大小在運行時可以改變，根據需求動態分配或釋放記憶體。記憶體在堆積 (Heap) 分配。
    *   **例子：** 連結串列、樹、圖、動態陣列 (如 C++ 的 `std::vector`, Java 的 `ArrayList`)。

-----

#### 1.2.3 依照資料同質性

*   **同質資料結構 (Homogeneous Data Structures)：**
    *   **核心觀念：** 所有元素都屬於相同的資料型態。
    *   **例子：** 整數陣列、字串陣列。
*   **異質資料結構 (Heterogeneous Data Structures)：**
    *   **核心觀念：** 元素可以包含不同的資料型態。
    *   **例子：** 結構體 (Struct) 或類別 (Class) 物件，它們可能包含整數、字串、布林值等不同型態的成員。

-----

### 1.3 資料結構與演算法

#### 1.3.1 兩者的緊密關聯

資料結構與演算法是電腦科學的兩大基石，它們之間有著不可分割的共生關係。
*   **演算法 (Algorithm)：**
    *   **核心觀念：** 解決特定問題的一系列明確、有限的步驟。它就像食譜，告訴你如何一步步地達成目標。
    *   **例子：** 排序演算法（如何將一組數字從小到大排列）、搜尋演算法（如何在資料中找到特定元素）。

**關聯：**
演算法是操作資料結構的步驟，而資料結構是演算法運行的舞台。沒有高效的資料結構，再精妙的演算法也可能寸步難行；反之，沒有合適的演算法，資料結構也只是靜態的資料集合。

**推導：**
假設我們要設計一個搜尋程式來找出一個城市中所有姓「陳」的居民。
1.  **若資料未經組織 (Data Structure 不佳)：** 你可能需要遍歷所有居民的資料，一個一個檢查他們的姓氏。這是一個簡單的線性搜尋演算法，但如果居民數量龐大，效率會非常低。
2.  **若資料結構優化 (Data Structure 優良)：** 如果我們將居民資料儲存在一個按照姓氏排序的「樹」或「雜湊表」中，那麼你就可以使用更快的演算法（如二元搜尋或直接雜湊查找）來迅速找到所有姓「陳」的居民。

因此，選擇正確的資料結構，往往是設計高效演算法的關鍵第一步。

-----

#### 1.3.2 衡量效能：時間複雜度與空間複雜度簡介

在選擇資料結構和演算法時，我們需要評估它們的效率。

*   **時間複雜度 (Time Complexity)：**
    *   **核心觀念：** 衡量演算法執行所需時間的成長趨勢。它並非指實際執行時間，而是指隨著輸入資料量 $N$ 的增加，演算法執行步驟數量或操作次數的變化規律。
    *   **常用表示：** 大 O 符號 (Big O Notation)，例如 $O(1)$ (常數時間)、$O(\log N)$ (對數時間)、$O(N)$ (線性時間)、$O(N \log N)$、$O(N^2)$ (平方時間) 等。
    *   **例子：**
        *   從陣列中透過索引直接存取元素：$O(1)$
        *   遍歷一個陣列搜尋元素：$O(N)$

*   **空間複雜度 (Space Complexity)：**
    *   **核心觀念：** 衡量演算法執行所需記憶體空間的成長趨勢。它同樣指隨著輸入資料量 $N$ 的增加，演算法所需的額外記憶體空間的變化規律。
    *   **常用表示：** 同樣使用大 O 符號。
    *   **例子：**
        *   原地排序演算法（不使用額外陣列）：$O(1)$
        *   遞迴演算法，呼叫堆疊深度為 $N$：$O(N)$

在第一章，我們只需理解這些是評估資料結構和演算法好壞的指標，未來的章節將會深入探討。

-----

### 1.4 常見錯誤與澄清

#### 1.4.1 混淆 ADT 與資料結構

*   **錯誤觀念：** 認為「清單就是連結串列」或「堆疊就是陣列」。
*   **澄清：**
    *   **ADT (抽象資料型態)** 是一種**邏輯概念**，描述了資料能做什麼（`push`、`pop`、`add`、`remove`）。
    *   **資料結構** 是一種**具體實現**，描述了資料是如何儲存和組織來實現這些操作的（例如用陣列或連結串列來實現堆疊）。
    *   舉例來說，你可以用陣列來實現堆疊，也可以用連結串列來實現堆疊。這兩種不同的資料結構都能實現堆疊這個 ADT 的行為。因此，堆疊是一個 ADT，而陣列和連結串列是資料結構。

-----

#### 1.4.2 認為資料結構只用於複雜問題

*   **錯誤觀念：** 「我的程式很簡單，用不上資料結構。」
*   **澄清：** 即使是簡單的程式，選擇合適的資料結構也能讓程式碼更清晰、更易於維護和擴展。例如，在 Python 中，`list`、`dict` 都是語言內建的資料結構，你幾乎每天都在使用它們。選擇 `list` 還是 `dict` 取決於你的需求：需要有序的元素集合還是快速的鍵值查找？理解資料結構的基本原理能幫助你做出更明智的選擇。

-----

#### 1.4.3 忽略演算法的重要性

*   **錯誤觀念：** 「只要用對資料結構，效能就一定好。」
*   **澄清：** 資料結構是基礎，演算法是靈魂。一個優良的資料結構搭配一個低效率的演算法，其整體表現仍會很差。反之，一個不那麼理想的資料結構，透過精巧的演算法設計，有時也能達成不錯的效能。最佳的解法往往是資料結構和演算法的完美結合。

-----

### 1.5 小練習

#### 1.5.1 小練習一：辨別 ADT 與資料結構

請判斷以下術語是屬於「抽象資料型態 (ADT)」還是「資料結構」，並簡要說明原因。

1.  堆疊 (Stack)
2.  陣列 (Array)
3.  佇列 (Queue)
4.  二元搜尋樹 (Binary Search Tree)
5.  映射/字典 (Map/Dictionary)

**詳解：**

1.  **堆疊 (Stack)：**
    *   **判斷：** 抽象資料型態 (ADT)
    *   **原因：** 堆疊定義了一種行為模式（LIFO, 後進先出），以及操作（`push`、`pop`、`peek`、`isEmpty`）。它沒有指定底層如何儲存資料（可以用陣列或連結串列實現）。

2.  **陣列 (Array)：**
    *   **判斷：** 資料結構
    *   **原因：** 陣列描述了資料在記憶體中的具體組織方式：連續的記憶體區塊，通過索引進行存取。它是一種實現其他 ADT 的手段。

3.  **佇列 (Queue)：**
    *   **判斷：** 抽象資料型態 (ADT)
    *   **原因：** 佇列定義了另一種行為模式（FIFO, 先進先出），以及操作（`enqueue`、`dequeue`、`front`、`isEmpty`）。它同樣可以透過陣列或連結串列等資料結構來實現。

4.  **二元搜尋樹 (Binary Search Tree)：**
    *   **判斷：** 資料結構
    *   **原因：** 二元搜尋樹明確定義了資料如何以節點形式組織（每個節點最多有兩個子節點）、如何維護順序（左子樹小於根，右子樹大於根），以及如何進行搜尋、插入、刪除等操作的具體演算法。它是一種具體的樹狀資料組織方式。

5.  **映射/字典 (Map/Dictionary)：**
    *   **判斷：** 抽象資料型態 (ADT)
    *   **原因：** 映射定義了一種鍵值對 (key-value pair) 的資料儲存和查找行為，核心操作是根據鍵快速查找值。它可以用雜湊表 (Hash Table) 或平衡二元搜尋樹等資料結構來實現。

-----

#### 1.5.2 小練習二：應用場景思考

假設你正在開發一個應用程式，需要儲存大量使用者的會員資料，包括會員 ID、姓名、註冊日期、點數等。當使用者登入時，你需要根據會員 ID 快速查找其所有資料。

1.  請思考如果採用一個簡單的「無序列表」來儲存這些資料（就像一個 Excel 工作表的列表，但沒有任何排序或特殊結構），在什麼情況下會有效率？在什麼情況下會非常低效率？
2.  為了提高「根據會員 ID 快速查找」的效率，你會考慮採用哪種資料結構（只需提及名稱，無需細節實現）？為什麼？

**詳解：**

1.  **「無序列表」儲存會員資料的效率分析：**
    *   **有效率的情況：**
        *   **資料量非常小：** 如果使用者數量只有幾十或幾百個，即使是線性搜尋，也可能在可接受的時間內完成。
        *   **只需遍歷所有資料：** 如果你的主要操作是批次處理所有會員（例如，發送所有會員的電子報），那麼無論資料是否有序，你都需要遍歷所有資料，此時「無序列表」的效率不會比其他結構差太多（甚至更簡單）。
        *   **插入操作：** 在列表末尾新增會員通常是非常快速的。
    *   **低效率的情況：**
        *   **資料量大，且需要頻繁查找：** 如果使用者數量達到數萬、數百萬，每次登入都需要從頭到尾搜尋會員 ID，這將花費大量的時間。例如，如果有 $N$ 個會員，平均每次查找需要 $N/2$ 次比較，最壞情況需要 $N$ 次比較。這會導致應用程式響應遲鈍，使用者體驗極差。
        *   **頻繁刪除特定會員：** 刪除特定會員可能需要先查找，然後再移動後續元素或標記刪除，效率會受到查找的影響。

2.  **提高「根據會員 ID 快速查找」效率的資料結構：**
    *   **資料結構名稱：** 雜湊表 (Hash Table) 或 字典 (Dictionary/Map)
    *   **原因：**
        *   **核心優勢：** 雜湊表能夠實現**平均 $O(1)$ 的查找、插入和刪除時間複雜度**。這意味著無論會員數量是 100 還是 1,000,000，根據會員 ID 查找資料所需的時間幾乎是常數級別，極其快速。
        *   **如何實現：** 雜湊表使用一個雜湊函數將會員 ID 轉換為一個記憶體地址（或陣列索引），從而可以直接跳轉到儲存該會員資料的位置，避免了逐一比較的過程。
        *   **其他選擇 (但雜湊表通常更優)：**
            *   **平衡二元搜尋樹 (Balanced Binary Search Tree)：** 例如 AVL 樹或紅黑樹。查找效率為 $O(\log N)$。雖然不如雜湊表的 $O(1)$ 平均效率，但在最壞情況下仍能保證 $O(\log N)$，且能保持資料有序。
            *   **已排序的陣列結合二元搜尋：** 如果資料量固定且主要操作是查找，可以將會員資料按 ID 排序，然後使用二元搜尋，查找效率為 $O(\log N)$。但插入和刪除操作會很昂貴 ($O(N)$)。

-----

### 1.6 延伸閱讀/參考

*   **經典教材：**
    *   *Introduction to Algorithms* by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein (俗稱 CLRS)
    *   *Data Structures and Algorithms in Java/Python/C++* by Michael T. Goodrich, Roberto Tamassia, and Michael H. Goldwasser
    *   *資料結構與演算法分析* by Mark Allen Weiss (涵蓋 C++, Java 等版本)

*   **線上資源：**
    *   GeeksforGeeks (英文): 提供豐富的資料結構與演算法教學、範例和練習題。
    *   LeetCode (英文/中文): 著名的程式設計面試準備平台，包含大量資料結構與演算法題目。
    *   各大學電腦科學系的開放課程：許多大學會在 YouTube 或 Coursera 等平台分享其資料結構課程。