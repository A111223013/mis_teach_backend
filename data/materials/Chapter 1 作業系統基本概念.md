主題：Chapter 1 作業系統基本概念

---

### 1. 核心概念與定義

#### 1.1 什麼是作業系統？

**定義/核心觀念：**
作業系統（Operating System, OS）是管理電腦硬體與軟體資源，並為電腦程式提供共用服務的系統軟體。它充當使用者與電腦硬體之間的介面，讓使用者能夠更有效率且方便地使用電腦。簡單來說，沒有作業系統，電腦就只是一堆無用的電子零件。

**目的與功能：**
*   **資源管理者：** 作業系統負責管理電腦中的所有資源，包括處理器（CPU）、記憶體（RAM）、儲存裝置（硬碟、SSD）、輸入/輸出設備（鍵盤、滑鼠、顯示器、印表機等）。它決定了哪個程式何時以及如何存取這些資源，以確保系統穩定運作並達到最佳效能。
*   **提供抽象化介面：** 硬體操作複雜且多樣。作業系統將這些複雜的硬體細節抽象化，提供給應用程式簡單、統一的介面（API，Application Programming Interface），讓應用程式開發者無需了解底層硬體如何運作，也能輕鬆地開發程式。
*   **使用者介面：** 提供使用者與電腦互動的方式，可以是圖形使用者介面（GUI，Graphical User Interface）如 Windows、macOS，或是命令列介面（CLI，Command Line Interface）如 Linux 的 Bash。
*   **程式執行環境：** 為應用程式的執行提供必要的環境和服務，例如載入程式、分配記憶體、管理檔案系統等。

**例子：**
當您開啟一個網頁瀏覽器時：
1.  您點擊瀏覽器圖示，作業系統接收到這個輸入事件。
2.  作業系統找到瀏覽器的執行檔，並將其載入到記憶體中。
3.  作業系統為瀏覽器程式分配所需的記憶體空間。
4.  作業系統排程 CPU 時間，讓瀏覽器程式能夠執行其指令。
5.  當瀏覽器需要顯示網頁內容時，它會透過作業系統的圖形介面服務，將像素繪製到顯示器上。
6.  當您下載一個檔案時，瀏覽器會向作業系統發出寫入檔案的請求，作業系統會將資料寫入硬碟。

#### 1.2 作業系統的角色

**定義/核心觀念：**
作業系統主要扮演兩個核心角色：
1.  **資源配置器（Resource Allocator）：** 作業系統負責在相互衝突的請求下，公正且有效率地分配電腦資源。這包括 CPU 時間、記憶體空間、儲存空間、I/O 設備等。
2.  **控制程式（Control Program）：** 作業系統負責控制程式的執行，防止錯誤和不當使用電腦。它確保系統安全，並維持系統的穩定性。

**例子：**
*   **資源配置：** 多個程式（例如瀏覽器、文字編輯器、音樂播放器）同時運行時，它們都需要 CPU 時間。作業系統的排程器會決定哪個程式在特定時間片獲得 CPU，以及持續多久，以創造多工的假象。
*   **控制程式：** 假設一個程式試圖存取不屬於它的記憶體區域，作業系統會偵測到這個非法操作，並終止該程式的執行（通常會顯示「程式已停止回應」或「記憶體錯誤」的訊息），以防止該錯誤影響到整個系統的穩定性。

**與相鄰概念的關聯：**
作業系統的角色直接影響了其與硬體、應用程式和使用者之間的關係。作為資源管理者，它必須了解硬體的運作方式；作為控制程式，它必須能夠干預應用程式的行為；作為介面提供者，它必須與使用者互動。

#### 1.3 作業系統的演進

**定義/核心觀念：**
作業系統的設計與功能隨著電腦硬體的發展和使用者需求的變化而演進。主要階段包括：

1.  **批次處理系統（Batch Systems）：**
    *   **核心觀念：** 將多個待執行的任務（Job）組成一個批次，由作業系統自動依序執行。使用者無法直接與電腦互動。
    *   **例子：** 早期電腦使用者將程式和資料儲存在打孔卡上，提交給操作員，操作員再將多個任務集中起來，一次性送入電腦執行。
    *   **優點：** 提高 CPU 利用率，減少人為干預。
    *   **缺點：** 缺乏互動性，周轉時間長。

2.  **多道程式系統（Multiprogramming Systems）：**
    *   **核心觀念：** 當一個程式進行 I/O 操作而閒置時，作業系統會切換到另一個程式執行，以保持 CPU 忙碌。
    *   **例子：** 程式 $P_1$ 正在讀取硬碟（I/O 操作），此時 CPU 閒置。多道程式系統會讓程式 $P_2$ 獲得 CPU 執行，待 $P_1$ 的 I/O 完成後再切換回來。
    *   **優點：** 進一步提高 CPU 利用率。
    *   **缺點：** 仍然缺乏直接互動性，周轉時間較難預測。

3.  **分時系統（Time-Sharing Systems / Multitasking Systems）：**
    *   **核心觀念：** 在多道程式的基礎上，將 CPU 的時間劃分為許多小片段（時間片），輪流分配給每個使用者或程式。使用者感覺可以同時與多個程式或多個使用者同時操作電腦。
    *   **例子：** 您在瀏覽網頁的同時聽音樂、聊天，感覺所有程式都在同時執行。
    *   **優點：** 提供良好的使用者互動性，多使用者共享系統。
    *   **缺點：** 引入了上下文切換的開銷，需要更複雜的排程演算法。

4.  **即時系統（Real-Time Systems）：**
    *   **核心觀念：** 針對對時間響應有嚴格要求的應用設計，必須在預設的截止時間內完成任務。
    *   **例子：** 飛機導航系統、工業控制系統、醫療設備。
    *   **分類：**
        *   **硬即時系統（Hard Real-Time）：** 絕對不能錯過截止時間，否則會導致災難性後果。
        *   **軟即時系統（Soft Real-Time）：** 允許偶爾錯過截止時間，但會降低服務品質。
    *   **優點：** 適用於時間敏感的應用。
    *   **缺點：** 設計和實現複雜，通常資源效率較低。

5.  **分散式系統（Distributed Systems）：**
    *   **核心觀念：** 將多台電腦透過網路連接起來，共同協作完成任務，對使用者來說像一台單一電腦。
    *   **例子：** Google 的雲端服務、網路檔案系統（NFS）。
    *   **優點：** 資源共享、高可靠性、高擴展性。
    *   **缺點：** 分散式一致性、網路延遲、安全性等問題。

6.  **行動作業系統（Mobile Operating Systems）：**
    *   **核心觀念：** 專為行動裝置（智慧型手機、平板電腦）設計的作業系統，強調低功耗、觸控介面、應用程式商店、感應器支援等。
    *   **例子：** iOS、Android。
    *   **優點：** 針對行動裝置優化，提供豐富的應用生態。
    *   **缺點：** 資源受限（電池、記憶體、CPU），安全性挑戰。

**與相鄰概念的關聯：**
這些演進反映了作業系統如何應對硬體發展（如 CPU 速度、記憶體容量、網路普及）和使用者需求（從單純計算到互動性、即時性、移動性）。每次演進都為更高層次的應用程式和服務奠定了基礎。

---

### 2. 典型例子與轉換/推導

#### 2.1 程式執行流程概述

**定義/核心觀念：**
當使用者啟動一個程式時，作業系統會執行一系列步驟來讓該程式運行。這涉及從磁碟載入程式、為其分配資源、並排程其執行。

**例子與推導：**
假設您點擊了一個名為 `my_program` 的可執行檔：

1.  **使用者介面（UI）處理：**
    *   作業系統的 UI（例如 Windows 的 explorer.exe 或 macOS 的 Finder）偵測到您的點擊事件。
    *   UI 程序會向核心發出一個請求，要求執行 `my_program`。

2.  **核心模式轉換與程序建立（Process Creation）：**
    *   使用者模式的 UI 程序透過**系統呼叫（System Call）**進入核心模式。
    *   核心（Kernel）收到執行請求後，會建立一個新的**程序（Process）**。程序是程式的一個執行實例，包含程式碼、資料、堆疊、暫存器狀態等。
    *   為這個新程序分配一個唯一的程序識別碼（PID）。

3.  **記憶體管理（Memory Management）：**
    *   作業系統為新程序分配虛擬記憶體空間。
    *   將 `my_program` 的程式碼和初始資料從硬碟載入（Load）到程序的虛擬記憶體空間中。
    *   若程式需要動態記憶體（heap），作業系統也會進行分配。

4.  **CPU 排程（CPU Scheduling）：**
    *   新建立的程序被放置在「就緒佇列（Ready Queue）」中。
    *   作業系統的排程器（Scheduler）會根據排程演算法選擇就緒佇列中的一個程序，將 CPU 分配給它。
    *   當 `my_program` 獲得 CPU 後，其指令便開始執行。

5.  **I/O 操作與其他系統服務：**
    *   在執行過程中，`my_program` 可能需要讀取檔案、顯示內容、接收鍵盤輸入等。這些操作都必須透過**系統呼叫**請求作業系統的服務。
    *   每次系統呼叫都會導致從使用者模式切換到核心模式，由核心處理請求，然後再切換回使用者模式。

6.  **程序終止（Process Termination）：**
    *   當 `my_program` 執行完成（或發生錯誤）時，它會發出終止系統呼叫。
    *   作業系統會回收該程序所佔用的所有資源（記憶體、檔案描述符等），並將其從程序清單中移除。

#### 2.2 系統呼叫 (System Calls)

**定義/核心觀念：**
系統呼叫是應用程式與作業系統核心之間互動的主要介面。它提供了一種受控的方式，讓使用者模式的程式可以請求核心服務，例如檔案操作、程序管理、記憶體管理或設備 I/O。

**例子與推導：**
考慮一個 C 語言程式，它需要打開一個檔案並寫入內容：

```c
#include <stdio.h>

int main() {
    FILE *fp;
    fp = fopen("example.txt", "w"); // 系統呼叫 open()
    if (fp == NULL) {
        // 錯誤處理
        return 1;
    }
    fprintf(fp, "Hello, OS!\n"); // 系統呼叫 write()
    fclose(fp);                  // 系統呼叫 close()
    return 0;
}
```

這段程式碼中：
*   `fopen()` 函式實際上會觸發底層的 `open()` 系統呼叫，要求作業系統打開或建立一個檔案。
*   `fprintf()` 函式會觸發 `write()` 系統呼叫，要求作業系統將資料寫入檔案。
*   `fclose()` 函式會觸發 `close()` 系統呼叫，要求作業系統關閉檔案。

**系統呼叫的流程：**
1.  **應用程式準備參數：** 應用程式在使用者模式下，將系統呼叫所需的參數放置在 CPU 暫存器或堆疊中。
2.  **觸發陷阱（Trap）：** 應用程式執行一個特殊的機器指令（通常是軟體中斷或陷阱指令），這會導致 CPU 從使用者模式切換到核心模式。
3.  **作業系統核心接管：** CPU 收到陷阱後，會跳轉到核心定義的陷阱處理程式的入口點。
4.  **識別系統呼叫：** 核心根據暫存器中的系統呼叫編號識別出是哪個系統呼叫（例如 `open`、`write`）。
5.  **執行核心服務：** 核心執行對應的服務，例如檢查檔案權限、存取磁碟控制器、分配記憶體等。
6.  **返回結果：** 核心將系統呼叫的結果（例如檔案描述符、寫入的位元組數或錯誤碼）放置在暫存器中。
7.  **切換回使用者模式：** 核心執行一個特殊的返回指令，將 CPU 切換回使用者模式，並將控制權交還給應用程式。

**為什麼需要系統呼叫？**
*   **安全性：** 直接存取硬體可能導致系統不穩定或資料損壞。系統呼叫提供了一個受控的介面，只有經過授權的操作才能由核心執行。
*   **抽象化：** 隱藏了底層硬體的複雜性，應用程式開發者無需了解特定硬體的細節。
*   **資源共享：** 確保多個應用程式能夠安全、公平地共享系統資源。
*   **可移植性：** 應用程式只需呼叫作業系統提供的標準介面，而無需為每種硬體架構重新編寫程式碼。

---

### 3. 與相鄰概念的關聯

#### 3.1 作業系統與硬體

**定義/核心觀念：**
作業系統是硬體的延伸與抽象化層。它管理硬體資源、提供驅動程式，並透過中斷（Interrupts）機制與硬體溝通。

**關聯：**
*   **資源管理：** 作業系統直接控制 CPU、記憶體、儲存、網路卡、顯示卡等硬體，決定其使用權和方式。
*   **驅動程式（Device Drivers）：** 為了讓作業系統能夠與各種不同的硬體設備互動，硬體製造商會提供設備驅動程式。驅動程式是作業系統核心的一部分或可載入模組，負責將作業系統的通用 I/O 請求轉換為特定硬體設備能夠理解的指令。
*   **抽象化：** 作業系統將硬體資源抽象化為更易於理解和操作的邏輯資源。例如，將硬碟上的磁區抽象化為檔案和目錄。
*   **保護：** 作業系統利用硬體的保護機制（如記憶體管理單元 MMU、模式位元）來隔離不同的程序，防止一個程序非法存取其他程序的記憶體或執行惡意操作。
*   **中斷（Interrupts）：** 硬體會透過發送中斷訊號來通知 CPU 某些事件的發生（例如鍵盤輸入、網路數據包到達、磁碟 I/O 完成）。作業系統會響應這些中斷，並執行對應的中斷處理程式。

#### 3.2 作業系統與應用程式

**定義/核心觀念：**
作業系統為應用程式提供執行環境和必要的服務。應用程式透過系統呼叫來請求這些服務。

**關聯：**
*   **API 與系統呼叫：** 應用程式透過呼叫作業系統提供的應用程式介面（API），間接發出系統呼叫，來使用核心服務。例如，C 語言中的 `printf()` 函式最終會透過作業系統的 `write()` 系統呼叫來輸出文字。
*   **執行環境：** 作業系統載入應用程式、分配記憶體、管理程序的執行緒、處理程序間通訊等，為應用程式提供一個穩定且安全的執行環境。
*   **沙盒機制：** 作業系統可以限制應用程式的權限，使其只能在特定的資源範圍內操作，保護系統的安全性。
*   **資源競爭：** 多個應用程式同時運行時，會競爭 CPU、記憶體等資源。作業系統的排程器和記憶體管理器負責協調這些競爭，確保每個應用程式都能公平地獲得資源，並防止死結。

#### 3.3 作業系統與使用者

**定義/核心觀念：**
作業系統是使用者與複雜電腦硬體之間的橋樑，提供直觀的互動方式。

**關聯：**
*   **使用者介面（User Interface）：**
    *   **圖形使用者介面（GUI）：** 提供視覺化的圖示、視窗、按鈕等元素，讓使用者透過滑鼠、觸控等方式直觀操作。如 Windows、macOS、Android、iOS。
    *   **命令列介面（CLI）：** 透過文字命令與系統互動，效率高，但需要學習命令語法。如 Linux 的 Bash、Windows 的 Command Prompt。
*   **檔案系統：** 提供結構化的方式來組織和管理檔案及目錄，讓使用者能夠方便地儲存、查找和存取資料。
*   **權限管理：** 允許管理者設定不同使用者對檔案、目錄或系統資源的存取權限，確保資料安全和多使用者環境下的隔離。

---

### 4. 進階內容：核心模式與使用者模式

#### 4.1 核心模式與使用者模式

**定義/核心觀念：**
大多數現代作業系統都採用**雙模式操作（Dual-Mode Operation）**，將 CPU 的執行權限分為兩種：

1.  **核心模式（Kernel Mode / Supervisor Mode）：**
    *   擁有最高權限，可以執行任何指令，存取任何記憶體位置和所有硬體設備。
    *   作業系統的核心程式碼在核心模式下執行。
    *   執行核心模式的程式碼時，系統完全信任它，任何錯誤都可能導致系統崩潰。

2.  **使用者模式（User Mode）：**
    *   權限受限，不能執行特權指令（例如直接操作 I/O 設備、禁用中斷、修改記憶體管理單元設定）。
    *   使用者應用程式（如瀏覽器、文字編輯器）在使用者模式下執行。
    *   嘗試執行特權指令會觸發陷阱（trap），將控制權交還給作業系統核心。

**目的與推導：**
雙模式操作的根本目的是為了**系統保護和安全性**。

*   **系統穩定性：** 防止使用者應用程式中的錯誤或惡意程式碼直接破壞作業系統核心或損壞其他應用程式的資料。
*   **資源隔離：** 確保不同程序之間相互隔離，一個程序的錯誤不會影響到其他程序或整個系統。
*   **受控資源存取：** 應用程式無法直接存取硬體，必須透過系統呼叫請求作業系統的核心服務。這使得作業系統能夠在授予存取權限之前，進行權限檢查和資源管理。

**模式切換：**
模式的切換是由硬體支援的。一個特殊的**模式位元（Mode Bit）**儲存在 CPU 的暫存器中，指示當前 CPU 處於核心模式（通常為 0）還是使用者模式（通常為 1）。

*   **使用者模式 -> 核心模式：**
    *   **系統呼叫：** 應用程式發出軟體中斷（陷阱指令），導致 CPU 切換到核心模式。
    *   **中斷（Interrupt）：** 硬體發出中斷訊號（例如計時器中斷、I/O 完成中斷），導致 CPU 切換到核心模式。
    *   **例外（Exception）：** 應用程式執行非法操作（例如除以零、非法記憶體存取），導致 CPU 切換到核心模式。
*   **核心模式 -> 使用者模式：**
    *   核心在處理完系統呼叫、中斷或例外後，會執行一個特殊的「從中斷返回」指令，將模式位元設置為使用者模式，並將控制權返回給使用者應用程式。

**例子：**
當一個文字編輯器（使用者模式程式）想要將資料寫入檔案時，它不能直接操作硬碟控制器（這是特權操作）。它會：
1.  準備好要寫入的資料和目標檔案的資訊。
2.  發出一個 `write()` 系統呼叫。
3.  CPU 的模式位元從使用者模式切換到核心模式。
4.  作業系統的核心處理 `write()` 請求，包括檢查權限、排程 I/O 操作等。
5.  核心完成寫入操作後，將結果返回給文字編輯器。
6.  CPU 的模式位元從核心模式切換回使用者模式。
7.  文字編輯器在使用者模式下繼續執行。

---

### 5. 常見錯誤與澄清

#### 5.1 誤解：作業系統只是使用者介面。

**澄清：**
使用者介面（GUI 或 CLI）確實是作業系統的一個重要組成部分，它是使用者與電腦互動的橋樑。但作業系統的職責遠不止於此。它的核心功能是管理硬體資源、提供抽象化服務、保護系統穩定性，並為應用程式提供執行環境。使用者介面只是這些核心功能之上的一個應用程式，它本身也是由作業系統的核心服務所支撐的。

#### 5.2 誤解：作業系統就是 Windows/macOS/Linux。

**澄清：**
Windows、macOS 和 Linux 是當前最主流的**作業系統產品**，它們是作業系統理論與技術的具體實現。然而，「作業系統」是一個更廣泛的概念，泛指任何負責管理電腦資源的系統軟體。除了這些桌面作業系統，還有行動作業系統（如 Android、iOS）、伺服器作業系統、嵌入式作業系統（如 RTOS for IoT 設備）等。它們都遵循相同的基本原則：管理資源、提供服務。

#### 5.3 誤解：應用程式可以直接存取硬體。

**澄清：**
在現代作業系統中，使用者模式的應用程式通常**不能**直接存取硬體。這是為了系統的穩定性、安全性和資源共享。如果應用程式可以直接操作硬體，一個惡意的或有錯誤的程式可能會隨意讀寫記憶體、破壞磁碟資料，甚至導致整個系統崩潰。作業系統透過雙模式操作和系統呼叫機制，嚴格控制對硬體的存取。應用程式必須透過發出系統呼叫，請求作業系統核心來代表它執行硬體操作。核心會檢查請求的合法性，然後再執行。

---

### 6. 小練習（附詳解）

#### 小練習 1：識別作業系統的功能

**題目：**
您正在使用一台電腦，打開了多個應用程式（例如：網頁瀏覽器、Word 文檔、音樂播放器），同時您還插上了一個 USB 隨身碟，並將一份文件從電腦硬碟複製到隨身碟中。請指出在這個過程中，作業系統至少發揮了哪三項核心功能，並簡要說明。

**步驟與詳解：**

1.  **識別多應用程式運行：**
    *   **情境：** 開啟多個應用程式（瀏覽器、Word、音樂播放器）。
    *   **作業系統功能：** **程序管理與排程（Process Management & Scheduling）**。
    *   **說明：** 作業系統負責為每個應用程式建立和管理程序，並透過排程器在這些程序之間切換 CPU，使得使用者感覺所有應用程式都在同時運行（多工）。它分配 CPU 時間片，確保每個程式都能獲得執行的機會。

2.  **識別記憶體使用：**
    *   **情境：** 各個應用程式都需要佔用記憶體來儲存程式碼和數據。
    *   **作業系統功能：** **記憶體管理（Memory Management）**。
    *   **說明：** 作業系統為每個運行中的應用程式分配和管理記憶體空間，防止不同程式之間相互干擾，同時優化記憶體的使用效率（例如透過虛擬記憶體技術）。

3.  **識別 USB 隨身碟與檔案操作：**
    *   **情境：** 插入 USB 隨身碟，並將文件從硬碟複製到隨身碟。
    *   **作業系統功能：** **設備管理（Device Management）與檔案系統管理（File System Management）**。
    *   **說明：**
        *   **設備管理：** 作業系統會偵測到 USB 隨身碟的插入（通常透過中斷機制），載入相應的驅動程式，並使其可用。當文件複製時，作業系統會管理數據在硬碟和 USB 隨身碟之間的傳輸。
        *   **檔案系統管理：** 作業系統提供檔案系統來組織和儲存硬碟和隨身碟上的文件和目錄。複製文件時，作業系統會處理檔案的讀取、寫入、權限檢查等操作。

#### 小練習 2：理解系統呼叫的必要性

**題目：**
假設一個惡意應用程式試圖直接讀取電腦硬碟上的所有資料，而不透過作業系統的檔案服務。請解釋為什麼現代作業系統會阻止這種行為？這與「核心模式與使用者模式」的概念有何關係？

**步驟與詳解：**

1.  **直接存取硬碟的問題：**
    *   **錯誤風險：** 應用程式如果直接操作硬碟，可能會讀取到錯誤的記憶體位置，導致資料損壞，甚至寫入到作業系統的關鍵區域，使系統崩潰。
    *   **安全性漏洞：** 惡意應用程式可以繞過所有安全檢查（例如檔案權限、加密），直接竊取或破壞使用者數據。這會對個人隱私和系統安全造成極大威脅。
    *   **資源競爭：** 如果多個應用程式同時嘗試直接存取硬碟，可能會發生衝突，導致資料不一致或系統死結。

2.  **作業系統的阻止機制：**
    *   現代作業系統會透過**雙模式操作（Dual-Mode Operation）**來阻止這種行為。
    *   **使用者模式的限制：** 應用程式在使用者模式下運行，其權限是受限的。它無法執行直接操作硬體（如 I/O 指令）的「特權指令」。
    *   **系統呼叫的必要性：** 任何涉及硬體或敏感資源的操作，都必須透過**系統呼叫（System Call）**來請求作業系統核心的服務。
    *   **模式切換與核心審核：** 當應用程式發出系統呼叫時，CPU 會從使用者模式切換到核心模式。在核心模式下，作業系統核心會：
        *   **驗證請求：** 檢查應用程式是否有足夠的權限來執行所請求的操作（例如讀取某個檔案）。
        *   **執行安全操作：** 如果請求合法，核心將代表應用程式以核心模式的權限安全地操作硬體。
        *   **返回結果：** 操作完成後，核心將結果返回給應用程式，並將 CPU 切換回使用者模式。

3.  **與「核心模式與使用者模式」的關係：**
    *   **核心模式**是作業系統核心的專屬領域，擁有最高權限，負責所有特權操作，包括對硬體的直接存取。
    *   **使用者模式**是應用程式的執行環境，權限受限，無法直接執行特權指令。
    *   這種模式分離確保了應用程式被「沙盒化」，它們無法直接接觸底層硬體，必須透過核心這個「看門人」來間接存取。核心扮演了中間人的角色，對所有請求進行審查和管理，從而保護了系統的安全和穩定。

---

### 7. 延伸閱讀/參考

*   **經典教科書：**
    *   Silberschatz, A., Galvin, P. B., & Gagne, G. (最新版). *Operating System Concepts*. Wiley. (作業系統領域的經典教材，涵蓋了從基本概念到進階主題的廣泛內容。)
    *   Tanenbaum, A. S., & Bos, H. (最新版). *Modern Operating Systems*. Pearson. (另一本廣受好評的教材，提供了更深入的實作細節和實際作業系統的案例分析。)

*   **線上資源：**
    *   [維基百科：作業系統](https://zh.wikipedia.org/zh-tw/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    *   [CSAPP (Computer Systems: A Programmer's Perspective)](http://csapp.cs.cmu.edu/)：雖然主要關於電腦系統，但其中關於程序、記憶體管理、I/O 等章節能很好地補充作業系統的基本概念。

*   **開放課程：**
    *   許多大學在 YouTube 或其他平台提供免費的作業系統課程，例如 MIT 的 6.828 (Operating System Engineering) 或 Standford 的 CS140 (Operating Systems)。

---