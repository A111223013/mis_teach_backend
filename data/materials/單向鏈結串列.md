# 單向鏈結串列 (Singly Linked List)

## 1. 核心概念與定義

### 什麼是鏈結串列？
鏈結串列（Linked List）是一種線性資料結構，與陣列（Array）不同，它的元素在記憶體中不是連續儲存的。每個元素（稱為「節點」）除了包含資料本身，還包含一個指向序列中下一個元素的「連結」（或稱為「指標」、「參考」）。

-----

### 什麼是單向鏈結串列？
單向鏈結串列（Singly Linked List）是鏈結串列中最基本的形式。它的每個節點只包含一個指向「下一個」節點的連結。這表示我們只能從頭到尾單向地走訪串列。

-----

### 鏈結串列的構成要素：節點 (Node)
單向鏈結串列由一系列節點組成。每個節點通常包含兩個主要部分：

1.  **資料 (Data / Value):** 儲存該節點的實際資訊。
2.  **下一個節點的連結 (Next Pointer / Reference):** 一個指向串列中下一個節點的記憶體位址。如果該節點是串列中的最後一個節點，則其 `next` 連結會指向 `NULL`（或 `None`），表示串列的結束。

#### 節點結構示意圖
```
+-------+       +-------+       +-------+
| Data  |       | Data  |       | Data  |
|-------|-----> |-------|-----> |-------|-----> NULL
| Next  |       | Next  |       | Next  |
+-------+       +-------+       +-------+
```

-----

### 頭節點 (Head) 與尾節點 (Tail)
*   **頭節點 (Head):** 是一個指向鏈結串列中第一個節點的指標。如果鏈結串列為空，`head` 會指向 `NULL`。`head` 是我們存取整個鏈結串列的入口點。
*   **尾節點 (Tail):** （可選，但對於 O(1) 尾端插入很有用）是一個指向鏈結串列中最後一個節點的指標。

#### 鏈結串列示意圖
```
Head ----> +-------+       +-------+       +-------+
           | Data:A|       | Data:B|       | Data:C|
           |-------|-----> |-------|-----> |-------|-----> NULL
           | Next  |       | Next  |       | Next  |
           +-------+       +-------+       +-------+
                                                   ^
                                                   |
                                                  Tail
```

-----

## 2. 典型操作與推導

單向鏈結串列的常見操作包括建立、插入、刪除、搜尋和走訪。這些操作主要透過操縱節點的 `next` 指標來實現。

### 2.1 建立與初始化

#### 定義/核心觀念
建立一個空的鏈結串列通常意味著將 `head` 指標設定為 `NULL`。當我們需要加入第一個節點時，`head` 會指向這個新節點。

#### 例子或推導
假設我們使用 Python-like 的語法來表示節點和鏈結串列。

```python
# 定義節點類別
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None # 初始時，下一個節點為空

# 定義單向鏈結串列類別
class SinglyLinkedList:
    def __init__(self):
        self.head = None # 初始時，鏈結串列為空

# 建立一個空的鏈結串列
my_list = SinglyLinkedList()
print(f"鏈結串列是否為空: {my_list.head is None}") # 輸出: True
```

#### 與相鄰概念的關聯
一個空的鏈結串列是所有操作的起點。接下來的所有插入操作都會從改變 `head` 或現有節點的 `next` 指標開始。

-----

### 2.2 走訪 (Traversal)

#### 定義/核心觀念
走訪是指從鏈結串列的 `head` 節點開始，依序拜訪每一個節點，直到遇到 `NULL` 指標為止。

#### 例子或推導
我們可以使用一個暫時指標（例如 `current`）從 `head` 開始，逐步移動到下一個節點，直到 `current` 變為 `NULL`。

```python
class SinglyLinkedList:
    # ... (前述 Node 和 SinglyLinkedList 的 __init__ ) ...

    def append(self, data): # 先增加一個在尾端插入的方法，方便測試
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def traverse(self):
        current = self.head
        if current is None:
            print("鏈結串列為空。")
            return
        
        print("鏈結串列元素:", end=" ")
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")

# 建立並走訪鏈結串列
my_list = SinglyLinkedList()
my_list.append("A")
my_list.append("B")
my_list.append("C")
my_list.traverse() # 輸出: 鏈結串列元素: A -> B -> C -> NULL
```

#### 與相鄰概念的關聯
走訪是許多其他操作（如搜尋、在特定位置插入/刪除）的基礎。它展示了單向鏈結串列的線性性質。

-----

### 2.3 插入 (Insertion)

#### 2.3.1 在開頭插入 (Insert at Head)

#### 定義/核心觀念
將新節點插入到鏈結串列的最前面。這意味著新節點將成為新的 `head`，而其 `next` 指標會指向原來的 `head` 節點。

#### 例子或推導
1.  建立一個新節點。
2.  將新節點的 `next` 指標指向目前的 `head`。
3.  更新 `head` 指標，使其指向新節點。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def prepend(self, data): # 在開頭插入
        new_node = Node(data)
        new_node.next = self.head # 新節點指向原來的頭
        self.head = new_node     # 更新頭為新節點

# 範例
my_list = SinglyLinkedList()
my_list.prepend("C") # C -> NULL
my_list.prepend("B") # B -> C -> NULL
my_list.prepend("A") # A -> B -> C -> NULL
my_list.traverse() # 輸出: 鏈結串列元素: A -> B -> C -> NULL
```

#### 與相鄰概念的關聯
這是最簡單的插入操作，時間複雜度為 $O(1)$，因為只需要修改兩個指標。

-----

#### 2.3.2 在結尾插入 (Insert at Tail)

#### 定義/核心觀念
將新節點插入到鏈結串列的最後面。這需要走訪整個鏈結串列找到目前的最後一個節點，然後讓它的 `next` 指向新節點。

#### 例子或推導
1.  建立一個新節點。
2.  如果鏈結串列為空，新節點即為 `head`。
3.  如果鏈結串列不為空，從 `head` 開始走訪，直到找到 `next` 為 `NULL` 的節點（即目前的最後一個節點）。
4.  將最後一個節點的 `next` 指向新節點。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def append(self, data): # 在結尾插入 (已在 traverse 範例中出現)
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next: # 走訪直到找到最後一個節點
            last = last.next
        last.next = new_node # 最後一個節點指向新節點

# 範例
my_list = SinglyLinkedList()
my_list.append("A") # A -> NULL
my_list.append("B") # A -> B -> NULL
my_list.append("C") # A -> B -> C -> NULL
my_list.traverse() # 輸出: 鏈結串列元素: A -> B -> C -> NULL
```

#### 與相鄰概念的關聯
在結尾插入操作的時間複雜度為 $O(N)$，因為在最壞情況下需要走訪整個串列。如果我們維護一個 `tail` 指標，則可以將此操作優化為 $O(1)$。

-----

#### 2.3.3 在特定節點之後插入 (Insert After a Given Node)

#### 定義/核心觀念
在鏈結串列中一個已知節點的後面插入新節點。這要求我們已經找到了目標節點。

#### 例子或推導
1.  找到目標節點 `prev_node`。如果 `prev_node` 為 `NULL`，則無法插入。
2.  建立一個新節點 `new_node`。
3.  將 `new_node` 的 `next` 指標指向 `prev_node` 原來的 `next`。
4.  將 `prev_node` 的 `next` 指標指向 `new_node`。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def insert_after(self, prev_node_data, new_data):
        if self.head is None:
            print("鏈結串列為空，無法在指定節點後插入。")
            return

        current = self.head
        prev_node = None
        while current and current.data != prev_node_data:
            current = current.next
        
        if current is None:
            print(f"未找到資料為 {prev_node_data} 的節點。")
            return

        # 此時 current 就是 prev_node
        new_node = Node(new_data)
        new_node.next = current.next
        current.next = new_node

# 範例
my_list = SinglyLinkedList()
my_list.append("A")
my_list.append("C") # A -> C -> NULL
my_list.insert_after("A", "B") # A -> B -> C -> NULL
my_list.traverse() # 輸出: 鏈結串列元素: A -> B -> C -> NULL
my_list.insert_after("Z", "Y") # 輸出: 未找到資料為 Z 的節點。
```

#### 與相鄰概念的關聯
此操作的時間複雜度為 $O(N)$（因為需要搜尋 `prev_node`）加上 $O(1)$（實際的插入步驟）。如果 `prev_node` 已經是已知參考，則僅需 $O(1)$。

-----

### 2.4 刪除 (Deletion)

#### 2.4.1 刪除開頭節點 (Delete Head)

#### 定義/核心觀念
移除鏈結串列中的第一個節點。這意味著 `head` 指標需要更新指向第二個節點。

#### 例子或推導
1.  如果鏈結串列為空，則沒有可刪除的節點。
2.  如果鏈結串列不為空，將 `head` 指標更新為指向原 `head` 的 `next` 節點。
3.  （在支援垃圾回收的語言中）原 `head` 節點會被自動回收。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def delete_head(self):
        if self.head is None:
            print("鏈結串列為空，無法刪除頭節點。")
            return
        
        temp = self.head # 儲存原來的頭節點
        self.head = self.head.next # 頭節點移到下一個
        # temp 節點現在沒有被任何變數引用，會被垃圾回收

# 範例
my_list = SinglyLinkedList()
my_list.append("A")
my_list.append("B")
my_list.append("C") # A -> B -> C -> NULL
my_list.delete_head() # B -> C -> NULL
my_list.traverse() # 輸出: 鏈結串列元素: B -> C -> NULL
my_list.delete_head() # C -> NULL
my_list.delete_head() # NULL
my_list.traverse() # 輸出: 鏈結串列為空。
my_list.delete_head() # 輸出: 鏈結串列為空，無法刪除頭節點。
```

#### 與相鄰概念的關聯
這是最簡單的刪除操作，時間複雜度為 $O(1)$。

-----

#### 2.4.2 刪除特定值的節點 (Delete a Node with Specific Value)

#### 定義/核心觀念
在鏈結串列中尋找第一個具有特定資料值的節點並將其移除。這需要找到目標節點的「前一個」節點，然後修改前一個節點的 `next` 指標以跳過目標節點。

#### 例子或推導
1.  如果鏈結串列為空，則沒有可刪除的節點。
2.  如果 `head` 節點就是目標節點，則直接執行 `delete_head` 的邏輯。
3.  否則，從 `head` 開始走訪，使用兩個指標：`current` 和 `prev`。
    *   `current` 負責走訪，當 `current.data` 等於目標值時停止。
    *   `prev` 始終指向 `current` 的前一個節點。
4.  找到目標節點後（`current` 為目標節點），將 `prev.next` 指向 `current.next`。
5.  如果走訪完畢仍未找到目標節點，則表示該值不存在。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def delete_node(self, key_data):
        current = self.head

        # 情況 1: 如果頭節點就是要刪除的節點
        if current and current.data == key_data:
            self.head = current.next
            current = None # 釋放原頭節點
            return

        # 情況 2: 遍歷鏈結串列尋找要刪除的節點
        prev = None
        while current and current.data != key_data:
            prev = current
            current = current.next

        # 情況 3: 如果沒有找到該值
        if current is None:
            print(f"未找到資料為 {key_data} 的節點。")
            return

        # 情況 4: 找到節點，執行刪除
        prev.next = current.next
        current = None # 釋放被刪除的節點

# 範例
my_list = SinglyLinkedList()
my_list.append("A")
my_list.append("B")
my_list.append("C")
my_list.append("D") # A -> B -> C -> D -> NULL

my_list.delete_node("B") # A -> C -> D -> NULL
my_list.traverse() # 輸出: 鏈結串列元素: A -> C -> D -> NULL

my_list.delete_node("A") # C -> D -> NULL (刪除頭節點)
my_list.traverse() # 輸出: 鏈結串列元素: C -> D -> NULL

my_list.delete_node("D") # C -> NULL (刪除尾節點)
my_list.traverse() # 輸出: 鏈結串列元素: C -> NULL

my_list.delete_node("E") # 輸出: 未找到資料為 E 的節點。
my_list.traverse() # 輸出: 鏈結串列元素: C -> NULL
```

#### 與相鄰概念的關聯
此操作的時間複雜度為 $O(N)$，因為在最壞情況下可能需要走訪整個串列來找到目標節點及其前一個節點。

-----

### 2.5 搜尋 (Search)

#### 定義/核心觀念
在鏈結串列中查找一個具有特定資料值的節點。

#### 例子或推導
1.  從 `head` 節點開始。
2.  使用一個 `current` 指標走訪每個節點。
3.  在每個節點，檢查其 `data` 是否與目標值匹配。
4.  如果找到匹配項，返回該節點或其資料。
5.  如果 `current` 變為 `NULL` 仍未找到，則表示目標值不存在。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def search(self, key_data):
        current = self.head
        while current:
            if current.data == key_data:
                return True # 找到
            current = current.next
        return False # 未找到

# 範例
my_list = SinglyLinkedList()
my_list.append("Apple")
my_list.append("Banana")
my_list.append("Cherry")

print(f"搜尋 'Banana': {my_list.search('Banana')}") # 輸出: True
print(f"搜尋 'Grape': {my_list.search('Grape')}")   # 輸出: False
```

#### 與相鄰概念的關聯
搜尋操作的原理與在結尾插入或刪除特定節點的走訪部分相同，時間複雜度為 $O(N)$。

-----

## 3. 與相鄰概念的關聯：陣列 vs. 鏈結串列

單向鏈結串列與陣列（Array）是兩種常見的線性資料結構，它們在底層記憶體管理和操作效率上存在顯著差異。

| 特性 / 結構     | 陣列 (Array)                                  | 單向鏈結串列 (Singly Linked List)                   |
| :-------------- | :-------------------------------------------- | :-------------------------------------------------- |
| **記憶體分配**  | 元素在記憶體中是連續儲存的。                  | 元素（節點）在記憶體中不連續，透過指標連結。       |
| **隨機存取**    | 支援隨機存取，可透過索引直接訪問任意元素 $O(1)$。 | 不支援隨機存取，必須從頭節點開始走訪才能訪問元素 $O(N)$。 |
| **插入/刪除**   | 在中間插入/刪除需要移動後續所有元素 $O(N)$。在尾部操作有時為 $O(1)$。 | 在開頭插入/刪除為 $O(1)$。在中間或尾部插入/刪除需要先走訪找到位置 $O(N)$。 |
| **大小調整**    | 通常為固定大小，調整大小需要創建新陣列並複製元素。 | 動態大小，可根據需要輕鬆增加或刪除節點。            |
| **記憶體使用**  | 通常更緊湊，沒有額外指標開銷。                 | 每個節點需要額外空間儲存指標，記憶體開銷較大。      |
| **快取性能**    | 由於連續儲存，通常具有更好的快取性能。        | 由於記憶體分散，快取性能可能較差。                  |

**總結：**
*   當需要頻繁進行隨機存取（例如，透過索引 `arr[i]`）時，陣列是更好的選擇。
*   當需要頻繁在資料結構的開頭進行插入或刪除，且對隨機存取要求不高時，鏈結串列（尤其是單向鏈結串列）更有效率。
*   鏈結串列在記憶體使用上更具彈性，但也伴隨著額外的指標記憶體開銷。

-----

## 4. 進階內容

### 4.1 時間複雜度分析

| 操作                  | 平均時間複雜度 | 最壞時間複雜度 | 備註                                                   |
| :-------------------- | :------------- | :------------- | :----------------------------------------------------- |
| 建立空串列            | $O(1)$         | $O(1)$         |                                                        |
| 插入到開頭 (`prepend`)| $O(1)$         | $O(1)$         | 僅需修改 `head` 指標。                                 |
| 插入到結尾 (`append`) | $O(N)$         | $O(N)$         | 需要走訪整個串列找到尾節點，除非維護 `tail` 指標，則為 $O(1)$。 |
| 在特定節點後插入      | $O(1)$         | $O(1)$         | 假設已知目標節點的參考。若需搜尋，則為 $O(N)$。          |
| 刪除開頭節點 (`delete_head`) | $O(1)$         | $O(1)$         | 僅需修改 `head` 指標。                                 |
| 刪除特定值的節點      | $O(N)$         | $O(N)$         | 需要走訪串列找到目標節點及其前一個節點。             |
| 走訪 (`traverse`)     | $O(N)$         | $O(N)$         | 必須拜訪所有節點。                                     |
| 搜尋 (`search`)       | $O(N)$         | $O(N)$         | 在最壞情況下需要拜訪所有節點。                         |
| 隨機存取 (`get_at_index`) | $O(N)$         | $O(N)$         | 必須從頭走訪到目標索引。                               |

-----

### 4.2 空間複雜度分析

*   **每個節點的空間開銷:** 每個節點需要儲存其資料和一個指向下一個節點的指標。如果資料大小為 $S$ 且指標大小為 $P$，則每個節點的空間複雜度為 $O(S + P)$。
*   **鏈結串列的總空間開銷:** 如果鏈結串列有 $N$ 個節點，總空間複雜度為 $O(N \cdot (S + P))$，即 $O(N)$。與陣列相比，額外的 $P$ 空間開銷是鏈結串列的固有特性。

-----

### 4.3 反轉鏈結串列 (Reversing a Linked List)

#### 定義/核心觀念
反轉鏈結串列是指將鏈結串列中所有節點的 `next` 指標方向顛倒，使原來的尾節點變成頭節點，原來的頭節點變成尾節點。這是一個經典的指標操作練習。

#### 例子或推導
一般使用三個指標來完成反轉：`prev` (前一個節點)、`current` (當前節點)、`next_node` (當前節點的下一個節點)。

1.  初始化 `prev = NULL`，`current = head`。
2.  在 `current` 不為 `NULL` 的迴圈中：
    a.  儲存 `current.next` 到 `next_node` (防止失去對鏈結其餘部分的引用)。
    b.  將 `current.next` 指向 `prev` (反轉指標)。
    c.  將 `prev` 移動到 `current` (更新 `prev` 為下一次迭代)。
    d.  將 `current` 移動到 `next_node` (更新 `current` 為下一次迭代)。
3.  迴圈結束後，`prev` 將指向原來的尾節點，這就是新的 `head`。

```python
class SinglyLinkedList:
    # ... (其他方法) ...

    def reverse(self):
        prev = None
        current = self.head
        while current:
            next_node = current.next # 1. 儲存下一個節點
            current.next = prev      # 2. 反轉當前節點的指標
            prev = current           # 3. 移動 prev 到當前節點
            current = next_node      # 4. 移動 current 到下一個節點
        self.head = prev # 更新 head 為新的頭節點

# 範例
my_list = SinglyLinkedList()
my_list.append(1)
my_list.append(2)
my_list.append(3)
my_list.traverse() # 輸出: 鏈結串列元素: 1 -> 2 -> 3 -> NULL

my_list.reverse()
my_list.traverse() # 輸出: 鏈結串列元素: 3 -> 2 -> 1 -> NULL

my_list.reverse() # 再反轉一次，恢復原狀
my_list.traverse() # 輸出: 鏈結串列元素: 1 -> 2 -> 3 -> NULL
```

#### 與相鄰概念的關聯
反轉操作展示了對鏈結串列指標精確控制的重要性。它不改變節點的資料，只改變它們之間的連接順序。時間複雜度為 $O(N)$ (需走訪所有節點一次)，空間複雜度為 $O(1)$ (只使用了幾個額外指標)。

-----

## 5. 常見錯誤與澄清

1.  **空指標處理不當 (Null Pointer Handling):**
    *   **錯誤:** 忘記在存取 `node.next` 或 `node.data` 之前檢查 `node` 是否為 `None` (或 `NULL`)，這會導致執行時錯誤（例如 `AttributeError` 或 `NullPointerException`）。
    *   **澄清:** 在任何可能為空的節點指標上執行操作前，務必進行 `if node is not None:` 檢查。特別是對於空鏈結串列 (`head is None`) 和走訪到鏈結串列末尾時的 `current.next`。

2.  **指標遺失 (Lost Pointers) 或資料丟失:**
    *   **錯誤:** 在執行插入或刪除操作時，如果直接修改某個節點的 `next` 指標，而沒有先保存它原來的 `next` 所指向的節點，則該節點及其後續所有節點可能永遠無法再被存取，導致資料丟失。
    *   **澄清:** 在改變一個節點的 `next` 指標之前，如果該 `next` 指向的節節點之後還有有用的資料，請務必先將其保存到一個臨時變數中。例如，反轉鏈結串列時需要 `next_node = current.next`。

3.  **邊界條件考慮不周 (Edge Cases):**
    *   **錯誤:** 許多操作（如插入、刪除）在處理空鏈結串列、只有一個節點的鏈結串列或在頭部/尾部進行操作時，行為會與一般情況不同。忘記處理這些「邊界條件」會導致程式錯誤。
    *   **澄清:** 總是在設計鏈結串列操作時，先考慮以下情況：
        *   鏈結串列為空 (`head is None`)。
        *   鏈結串列只有一個節點。
        *   操作發生在頭節點。
        *   操作發生在尾節點。

4.  **無限迴圈 (Infinite Loops):**
    *   **錯誤:** 在走訪鏈結串列時，如果 `current` 指標未能正確地向後移動 (`current = current.next`)，或者鏈結串列中意外形成了循環（例如，最後一個節點的 `next` 指向了前面的某個節點），就會導致無限迴圈。
    *   **澄清:** 確保走訪迴圈中有正確的指標推進邏輯 (`current = current.next`)，並且最後一個節點的 `next` 確實指向 `NULL`。

-----

## 6. 小練習（附詳解）

### 小練習 1: 實作在鏈結串列中取得第 N 個節點的資料

請完成 `SinglyLinkedList` 類別中的 `get_nth(self, index)` 方法，使其能返回鏈結串列中第 `index` 個（從 0 開始計數）節點的資料。如果 `index` 超出範圍，請返回 `None` 或拋出錯誤。

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def traverse(self):
        current = self.head
        if current is None:
            print("鏈結串列為空。")
            return
        
        print("鏈結串列元素:", end=" ")
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")

    def get_nth(self, index):
        # 請在此處寫下您的程式碼
        pass

# 測試您的程式碼
my_list = SinglyLinkedList()
my_list.append("A") # index 0
my_list.append("B") # index 1
my_list.append("C") # index 2

print(f"取得第 0 個節點: {my_list.get_nth(0)}") # 預期: A
print(f"取得第 1 個節點: {my_list.get_nth(1)}") # 預期: B
print(f"取得第 2 個節點: {my_list.get_nth(2)}") # 預期: C
print(f"取得第 3 個節點: {my_list.get_nth(3)}") # 預期: None (或錯誤訊息)
print(f"取得第 -1 個節點: {my_list.get_nth(-1)}") # 預期: None (或錯誤訊息)

empty_list = SinglyLinkedList()
print(f"空鏈結串列取得第 0 個節點: {empty_list.get_nth(0)}") # 預期: None (或錯誤訊息)
```

#### 詳解: 小練習 1

1.  **初始化計數器與當前節點:**
    *   宣告一個 `current` 指標，從 `self.head` 開始。
    *   宣告一個 `count` 變數，初始化為 `0`。

2.  **處理無效索引或空串列:**
    *   如果 `index` 小於 0，或者 `self.head` 為 `None` 且 `index` 大於等於 0，則直接返回 `None`。

3.  **走訪串列:**
    *   使用 `while` 迴圈，條件是 `current` 不為 `None`。
    *   在每次迭代中，檢查 `count` 是否等於 `index`。
        *   如果相等，表示找到目標節點，返回 `current.data`。
    *   將 `current` 推進到下一個節點 (`current = current.next`)。
    *   將 `count` 遞增 (`count += 1`)。

4.  **處理索引超出範圍:**
    *   如果迴圈結束（即 `current` 變為 `None`），但仍未找到匹配的 `index`，則表示 `index` 超出範圍，返回 `None`。

```python
class SinglyLinkedList:
    # ... (其他方法不變) ...

    def get_nth(self, index):
        if index < 0:
            print("錯誤: 索引不能為負數。")
            return None

        current = self.head
        count = 0

        while current:
            if count == index:
                return current.data
            current = current.next
            count += 1
        
        # 如果走訪完畢仍未找到，表示索引超出範圍
        print(f"錯誤: 索引 {index} 超出鏈結串列範圍。")
        return None

# 測試結果應為：
# 取得第 0 個節點: A
# 取得第 1 個節點: B
# 取得第 2 個節點: C
# 錯誤: 索引 3 超出鏈結串列範圍。
# 取得第 3 個節點: None
# 錯誤: 索引不能為負數。
# 取得第 -1 個節點: None
# 錯誤: 索引 0 超出鏈結串列範圍。
# 空鏈結串列取得第 0 個節點: None
```

-----

### 小練習 2: 實作刪除鏈結串列中所有特定值的節點

請完成 `SinglyLinkedList` 類別中的 `delete_all_occurrences(self, key_data)` 方法，使其能刪除鏈結串列中所有資料值為 `key_data` 的節點。

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def traverse(self):
        current = self.head
        if current is None:
            print("鏈結串列為空。")
            return
        
        print("鏈結串列元素:", end=" ")
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")

    def delete_all_occurrences(self, key_data):
        # 請在此處寫下您的程式碼
        pass

# 測試您的程式碼
my_list = SinglyLinkedList()
my_list.append(1)
my_list.append(2)
my_list.append(1)
my_list.append(3)
my_list.append(1)
my_list.append(4)
my_list.traverse() # 預期: 1 -> 2 -> 1 -> 3 -> 1 -> 4 -> NULL

my_list.delete_all_occurrences(1)
my_list.traverse() # 預期: 2 -> 3 -> 4 -> NULL

my_list.delete_all_occurrences(5) # 預期: 沒有改變
my_list.traverse() # 預期: 2 -> 3 -> 4 -> NULL

my_list.delete_all_occurrences(2)
my_list.traverse() # 預期: 3 -> 4 -> NULL

empty_list = SinglyLinkedList()
empty_list.delete_all_occurrences(1) # 預期: 沒有錯誤，空列表
empty_list.traverse() # 預期: 鏈結串列為空。

single_node_list = SinglyLinkedList()
single_node_list.append(7)
single_node_list.delete_all_occurrences(7)
single_node_list.traverse() # 預期: 鏈結串列為空。
```

#### 詳解: 小練習 2

1.  **處理頭節點的刪除:**
    *   首先，我們需要處理鏈結串列開頭可能存在多個要刪除的節點。
    *   使用 `while self.head and self.head.data == key_data:` 迴圈，只要 `head` 不為空且 `head` 的資料與 `key_data` 相符，就將 `self.head` 推進到下一個節點。

2.  **走訪並刪除中間和尾部的節點:**
    *   初始化 `current = self.head` 和 `prev = None`。`prev` 指向 `current` 的前一個節點。
    *   使用 `while current:` 迴圈走訪串列。
    *   在迴圈內部：
        *   如果 `current.data` 等於 `key_data`：
            *   表示找到一個要刪除的節點。
            *   將 `prev.next` 指向 `current.next`，從而跳過 `current` 節點。
            *   更新 `current` 為 `current.next`（因為原來的 `current` 已經被移除了）。
        *   如果 `current.data` 不等於 `key_data`：
            *   表示當前節點不需要刪除。
            *   將 `prev` 推進到 `current` (`prev = current`)。
            *   將 `current` 推進到下一個節點 (`current = current.next`)。

```python
class SinglyLinkedList:
    # ... (其他方法不變) ...

    def delete_all_occurrences(self, key_data):
        # 情況 1: 處理開頭的節點
        while self.head and self.head.data == key_data:
            self.head = self.head.next
        
        # 如果處理完開頭後鏈結串列變空了，就直接返回
        if self.head is None:
            return

        # 情況 2: 處理中間和尾部的節點
        current = self.head
        prev = None

        while current:
            if current.data == key_data:
                # 找到要刪除的節點
                prev.next = current.next # 前一個節點跳過 current
                current = current.next   # current 移動到下一個節點
            else:
                # current 不需要刪除，移動 prev 和 current
                prev = current
                current = current.next

# 測試結果應為：
# 鏈結串列元素: 1 -> 2 -> 1 -> 3 -> 1 -> 4 -> NULL
# 鏈結串列元素: 2 -> 3 -> 4 -> NULL
# 鏈結串列元素: 2 -> 3 -> 4 -> NULL
# 鏈結串列元素: 3 -> 4 -> NULL
# 鏈結串列為空。
# 鏈結串列為空。
```

-----

## 7. 延伸閱讀

*   **雙向鏈結串列 (Doubly Linked List):** 每個節點除了指向下一個節點的指標，還包含一個指向前一個節點的指標。這使得從任一方向走訪串列，以及在特定節點前插入/刪除都更有效率。
*   **環狀鏈結串列 (Circular Linked List):** 鏈結串列的最後一個節點的 `next` 指標指向頭節點，形成一個環。
*   **跳躍列表 (Skip List):** 一種機率性資料結構，在鏈結串列的基礎上增加了多層次跳躍指標，以實現類似平衡樹的 $O(\log N)$ 搜尋、插入和刪除效率，但實現更為簡單。
*   **鏈結串列的應用:**
    *   實作堆疊 (Stack) 和佇列 (Queue)。
    *   表示多項式（每個節點代表一個項）。
    *   作業系統中行程排程和記憶體管理。
    *   實現雜湊表中的鏈結衝突解決策略。
*   **演算法與資料結構書籍:** 任何經典的演算法與資料結構教材都會詳細介紹鏈結串列。例如：
    *   *Introduction to Algorithms* by Cormen, Leiserson, Rivest, and Stein (CLRS)
    *   *Data Structures and Algorithms in Python* by Michael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser