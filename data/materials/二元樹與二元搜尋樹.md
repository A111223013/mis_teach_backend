# 二元樹與二元搜尋樹

資料結構是電腦科學的基石，而「樹」是其中一種功能強大且用途廣泛的非線性資料結構。在各種樹狀結構中，二元樹 (Binary Tree) 因其簡潔的定義和多樣的應用而佔據核心地位。更進一步地，二元搜尋樹 (Binary Search Tree, BST) 則在二元樹的基礎上引入了特殊的排序特性，使其在搜尋、插入和刪除操作上展現出高效能。

本教材旨在深入淺出地介紹二元樹與二元搜尋樹的核心概念、典型操作、與其他資料結構的關聯，並探討其常見問題與應用。

-----

### 1. 核心概念與定義

#### 1.1 什麼是樹？

在深入探討二元樹之前，讓我們先快速回顧一下「樹」這一抽象概念。
樹是一種非線性的資料結構，由節點 (nodes) 和邊 (edges) 組成。它具有層次結構，每個節點可以有多個子節點，但只有一個父節點（除了根節點）。

- **根節點 (Root Node)**：樹的最頂端節點，沒有父節點。
- **子節點 (Child Node)**：直接連接在某個節點下方的節點。
- **父節點 (Parent Node)**：某個節點直接連接在其上方的節點。
- **兄弟節點 (Sibling Nodes)**：具有相同父節點的節點。
- **葉節點 (Leaf Node)**：沒有子節點的節點。
- **內部節點 (Internal Node)**：至少有一個子節點的節點。
- **邊 (Edge)**：連接兩個節點的連結。
- **路徑 (Path)**：從一個節點到另一個節點所經過的邊的序列。
- **深度 (Depth)**：從根節點到某個節點的路徑長度。根節點深度為 0。
- **高度 (Height)**：從某個節點到其最遠葉節點的路徑長度。葉節點高度為 0。整棵樹的高度是根節點的高度。
- **層次 (Level)**：深度相同的節點位於同一層次。

#### 1.2 什麼是二元樹 (Binary Tree)？

**定義/核心觀念：**
二元樹是一種特殊的樹，其中每個節點最多只能有兩個子節點，分別稱為左子節點 (left child) 和右子節點 (right child)。這兩個子節點可以為空。

**核心特性：**
1.  每個節點最多有兩個子節點。
2.  每個子節點都有明確的左右之分。
3.  二元樹可以是空的 (不包含任何節點)。

**二元樹的種類：**
儘管所有二元樹都遵循上述定義，但根據其結構特點，我們還可以進一步細分：

-   **滿二元樹 (Full Binary Tree)**：
    所有內部節點都恰好有兩個子節點。換句話說，除了葉節點之外，所有節點都有兩個子節點。
    ```
          A
         / \
        B   C
       / \ / \
      D  E F  G
    ```

-   **完全二元樹 (Complete Binary Tree)**：
    除了最後一層外，所有層次都被完全填滿，並且最後一層的所有節點都盡可能地靠左排列。
    例如，深度為 `d` 的完全二元樹，除了深度 `d` 的節點外，其他所有節點的深度都小於 `d`。深度 `d` 的所有節點都集中在左側。
    ```
          A
         / \
        B   C
       / \ /
      D  E F
    ```

-   **完美二元樹 (Perfect Binary Tree)**：
    所有內部節點都有兩個子節點，且所有葉節點都位於同一層次。這意味著完美二元樹既是滿二元樹，也是完全二元樹。
    對於高度為 $h$ 的完美二元樹，節點總數為 $2^{h+1} - 1$。
    ```
          A
         / \
        B   C
       / \ / \
      D  E F  G
    ```

-   **傾斜二元樹 (Skewed Binary Tree)**：
    所有節點都只擁有左子節點或只擁有右子節點，形成一條鏈狀結構。
    ```
    右傾斜：  A         左傾斜：  A
               \                 /
                B               B
                 \             /
                  C           C
    ```

#### 1.3 什麼是二元搜尋樹 (Binary Search Tree, BST)？

**定義/核心觀念：**
二元搜尋樹 (BST) 是一種特殊的二元樹，它額外遵循一個重要的排序特性：

1.  **左子樹性質**：任意節點的左子樹中，所有節點的值都 **小於** 該節點的值。
2.  **右子樹性質**：任意節點的右子樹中，所有節點的值都 **大於** 該節點的值。
3.  **遞歸性質**：左子樹和右子樹本身也必須是二元搜尋樹。

**例子：**
一個符合二元搜尋樹性質的例子：
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \   /
     4   7 13
```
在這個例子中，對於根節點 8：
- 左子樹 (3, 1, 6, 4, 7) 的所有值都小於 8。
- 右子樹 (10, 14, 13) 的所有值都大於 8。
這個性質遞歸地應用於所有子樹。例如，對於節點 3：
- 左子樹 (1) 的值小於 3。
- 右子樹 (6, 4, 7) 的所有值都大於 3。

**與二元樹的關聯：**
二元搜尋樹是二元樹的一種特殊化。所有的二元搜尋樹都是二元樹，但並非所有的二元樹都是二元搜尋樹。BST 透過引入節點值的排序約束，為資料的快速搜尋、插入和刪除提供了基礎。

-----

### 2. 典型例子與操作

#### 2.1 二元樹的建立與遍歷

在二元樹中，遍歷 (Traversal) 是指以特定順序訪問樹中所有節點的過程。主要有三種深度優先遍歷 (Depth-First Traversal) 方法和一種廣度優先遍歷 (Breadth-First Traversal) 方法。

**例子：假設有以下二元樹結構**
```
       A
      / \
     B   C
    / \ / \
   D  E F  G
```

1.  **前序遍歷 (Pre-order Traversal)**：
    - **順序**：根節點 -> 左子樹 -> 右子樹
    - **推導**：
        1. 訪問 A。
        2. 訪問 A 的左子樹 (B)。
            1. 訪問 B。
            2. 訪問 B 的左子樹 (D)。
                1. 訪問 D。
            3. 訪問 B 的右子樹 (E)。
                1. 訪問 E。
        3. 訪問 A 的右子樹 (C)。
            1. 訪問 C。
            2. 訪問 C 的左子樹 (F)。
                1. 訪問 F。
            3. 訪問 C 的右子樹 (G)。
                1. 訪問 G。
    - **結果**：A -> B -> D -> E -> C -> F -> G

2.  **中序遍歷 (In-order Traversal)**：
    - **順序**：左子樹 -> 根節點 -> 右子樹
    - **推導**：
        1. 訪問 A 的左子樹 (B)。
            1. 訪問 B 的左子樹 (D)。
                1. 訪問 D。
            2. 訪問 B。
            3. 訪問 B 的右子樹 (E)。
                1. 訪問 E。
        2. 訪問 A。
        3. 訪問 A 的右子樹 (C)。
            1. 訪問 C 的左子樹 (F)。
                1. 訪問 F。
            2. 訪問 C。
            3. 訪問 C 的右子樹 (G)。
                1. 訪問 G。
    - **結果**：D -> B -> E -> A -> F -> C -> G

3.  **後序遍歷 (Post-order Traversal)**：
    - **順序**：左子樹 -> 右子樹 -> 根節點
    - **推導**：
        1. 訪問 A 的左子樹 (B)。
            1. 訪問 B 的左子樹 (D)。
                1. 訪問 D。
            2. 訪問 B 的右子樹 (E)。
                1. 訪問 E。
            3. 訪問 B。
        2. 訪問 A 的右子樹 (C)。
            1. 訪問 C 的左子樹 (F)。
                1. 訪問 F。
            2. 訪問 C 的右子樹 (G)。
                1. 訪問 G。
            3. 訪問 C。
        3. 訪問 A。
    - **結果**：D -> E -> B -> F -> G -> C -> A

4.  **層次遍歷 (Level-order Traversal)**：
    - **順序**：從上到下，從左到右，逐層訪問節點（通常使用佇列實現，類似廣度優先搜尋 BFS）。
    - **推導**：
        1. 訪問第一層的節點：A
        2. 訪問第二層的節點：B, C
        3. 訪問第三層的節點：D, E, F, G
    - **結果**：A -> B -> C -> D -> E -> F -> G

#### 2.2 二元搜尋樹 (BST) 的操作

二元搜尋樹的核心價值在於它能有效地執行搜尋、插入和刪除等操作，這都歸功於其特有的排序性質。

**假設初始 BST 為空，我們將依序插入 8, 3, 10, 1, 6, 14, 4, 7, 13。**

1.  **插入 (Insertion)：**
    -   **核心觀念**：從根節點開始，如果新值小於當前節點值，則往左走；如果新值大於當前節點值，則往右走。直到找到一個空的位置（即當前節點為 `null`）為止，將新值插入該位置。
    -   **例子與推導**：
        -   插入 8：作為根節點。
            ```
                8
            ```
        -   插入 3：$3 < 8$，移至 8 的左側。8 的左子節點為 3。
            ```
                8
               /
              3
            ```
        -   插入 10：$10 > 8$，移至 8 的右側。8 的右子節點為 10。
            ```
                8
               / \
              3   10
            ```
        -   插入 1：$1 < 8$，左移到 3；$1 < 3$，左移。3 的左子節點為 1。
            ```
                8
               / \
              3   10
             /
            1
            ```
        -   插入 6：$6 < 8$，左移到 3；$6 > 3$，右移。3 的右子節點為 6。
            ```
                8
               / \
              3   10
             / \
            1   6
            ```
        -   依此類推，最終結構將是：
            ```
                 8
                / \
               3   10
              / \    \
             1   6    14
                / \   /
               4   7 13
            ```

2.  **搜尋 (Search)：**
    -   **核心觀念**：從根節點開始，將目標值與當前節點值比較。如果相等，則找到；如果目標值小於當前節點值，則往左子樹搜尋；如果目標值大於當前節點值，則往右子樹搜尋。如果走到 `null` 仍未找到，則目標值不存在。
    -   **例子與推導**：搜尋值 7
        1.  從根節點 8 開始：$7 < 8$，往左子樹走。
        2.  到達節點 3：$7 > 3$，往右子樹走。
        3.  到達節點 6：$7 > 6$，往右子樹走。
        4.  到達節點 7：$7 = 7$，找到目標值 7。

    -   **例子與推導**：搜尋值 5
        1.  從根節點 8 開始：$5 < 8$，往左子樹走。
        2.  到達節點 3：$5 > 3$，往右子樹走。
        3.  到達節點 6：$5 < 6$，往左子樹走。
        4.  到達節點 4：$5 > 4$，往右子樹走。
        5.  到達 `null`：未找到 5。

3.  **刪除 (Deletion)：**
    -   **核心觀念**：刪除操作較為複雜，需要處理三種情況，以確保刪除後仍維持 BST 的性質。
    -   **例子與推導**：刪除節點 6
        -   **案例 1: 刪除葉節點 (無子節點)**
            -   例如，刪除節點 1。直接將其父節點 3 的左子節點指向 `null` 即可。
        -   **案例 2: 刪除只有一個子節點的節點**
            -   例如，刪除節點 10 (只有右子節點 14)。將其父節點 8 的右子節點指向 10 的子節點 (即 14)。
                ```
                     8
                    / \
                   3   14  (10被刪除，14取代其位置)
                  / \  /
                 1   6 13
                    / \
                   4   7
                ```
        -   **案例 3: 刪除有兩個子節點的節點**
            -   這是最複雜的情況。我們不能簡單地將其移除。有兩種常見策略：
                -   找到該節點的**中序後繼 (in-order successor)**：即其右子樹中最小的節點。
                -   找到該節點的**中序前驅 (in-order predecessor)**：即其左子樹中最大的節點。
            -   通常使用中序後繼。將要刪除的節點的值替換為其中序後繼的值，然後遞歸地刪除中序後繼節點（此時中序後繼節點必定至多只有一個右子節點，因為它是其子樹中最小的）。
            -   **例子**：刪除根節點 8 (具有兩個子節點)
                1.  找到 8 的中序後繼：8 的右子樹中最小的節點是 10 的左子樹中的最小值，即 10。
                2.  將 8 的值替換為 10。
                3.  刪除原來的節點 10 (現在這個 10 是其父節點的右子節點，且它只有一個子節點 14)。
                    ```
                    原始樹：
                         8
                        / \
                       3   10
                      / \    \
                     1   6    14
                        / \   /
                       4   7 13

                    步驟1&2: 找到中序後繼 10，替換 8
                         10
                        /  \
                       3    10 (待刪除，此為原來的10)
                      / \    \
                     1   6    14
                        / \   /
                       4   7 13

                    步驟3: 刪除原來的 10 (現在的值為10，只有右子節點 14)。
                           將 10 的父節點 (此例中就是替換後的根節點) 的右子節點指向 10 的右子節點 14。
                         10
                        /  \
                       3    14
                      / \   /
                     1   6 13
                        / \
                       4   7
                    ```

4.  **查找最小值/最大值 (Find Min/Max)：**
    -   **核心觀念**：最小值位於最左側的葉節點（或具有左子節點的節點），最大值位於最右側的葉節點。
    -   **查找最小值**：從根節點開始，不斷往左子樹移動，直到當前節點沒有左子節點為止。該節點的值即為 BST 中的最小值。
        -   從 8 開始，左移到 3，再左移到 1。1 沒有左子節點，所以最小值是 1。
    -   **查找最大值**：從根節點開始，不斷往右子樹移動，直到當前節點沒有右子節點為止。該節點的值即為 BST 中的最大值。
        -   從 8 開始，右移到 10，再右移到 14。14 沒有右子節點，所以最大值是 14。

-----

### 3. 與相鄰概念的關聯

#### 3.1 二元樹與其他樹結構

-   **N元樹 (N-ary Tree)**：二元樹是 N 元樹的一種特例，其中 $N=2$。N 元樹的每個節點可以有最多 N 個子節點。二元樹簡化了結構，使其在許多演算法設計中更易於管理。
-   **堆 (Heap)**：堆是一種特殊的完全二元樹，它滿足堆的性質（父節點的值總是大於或小於其所有子節點的值）。雖然堆是二元樹，但它沒有像 BST 那樣的左右子樹的排序關係，而是側重於找出最大或最小值。它通常用於實現優先佇列。
-   **Trie (字典樹)**：Trie 是一種用於快速檢索關鍵字字串的樹狀資料結構。它不是二元樹，而是 N 元樹（通常 N 等於字母表的大小）。每個節點儲存一個字元，沿著路徑形成的字串就是一個關鍵字。

#### 3.2 二元搜尋樹的效能

二元搜尋樹在資料處理中的效率是其最重要的特性之一。

-   **時間複雜度**：
    -   **平均情況**：當 BST 接近平衡時，搜尋、插入和刪除操作的時間複雜度為 $O(\log N)$，其中 $N$ 是樹中的節點數。這與二分搜尋法的效率相當，非常高效。
    -   **最差情況**：當 BST 變得高度傾斜（例如，所有插入的元素都按遞增或遞減順序排列），它會退化成一個鏈結串列。此時，搜尋、插入和刪除操作的時間複雜度會退化為 $O(N)$。

-   **與其他資料結構的關聯**：
    -   **陣列 (Arrays)**：陣列在隨機存取 (random access) 上是 $O(1)$，但插入和刪除中間元素需要 $O(N)$ 的時間。排序陣列上二分搜尋是 $O(\log N)$，但插入仍是 $O(N)$。BST 在平均情況下，在搜尋、插入、刪除上都優於未排序陣列，且插入比排序陣列高效。
    -   **鏈結串列 (Linked Lists)**：單向鏈結串列的搜尋、插入、刪除都是 $O(N)$。BST 在平均情況下明顯優於鏈結串列。
    -   **雜湊表 (Hash Tables)**：雜湊表在平均情況下提供 $O(1)$ 的搜尋、插入、刪除性能。然而，它不支援範圍查詢、查找最小值/最大值，也不保持元素的排序。BST 在這些方面表現出色。

#### 3.3 BST 與平衡樹 (Balanced Trees)

-   **問題**：如前所述，二元搜尋樹在最差情況下可能退化成鏈結串列，導致操作效率從 $O(\log N)$ 降至 $O(N)$。這大大降低了其性能優勢。
-   **解決方案**：為了解決這個問題，人們設計了**平衡二元搜尋樹 (Balanced Binary Search Trees)**。這些樹在插入和刪除操作後會自動調整其結構，以保持樹的高度大致平衡，從而確保所有操作始終保持 $O(\log N)$ 的時間複雜度。
-   **典型例子**：
    -   **AVL 樹 (Adelson-Velsky and Landis Tree)**：最早的自平衡二元搜尋樹之一。它通過追蹤每個節點的平衡因子（左右子樹的高度差），在插入或刪除導致失衡時執行旋轉操作來重新平衡。
    -   **紅黑樹 (Red-Black Tree)**：一種更為複雜但更常用的自平衡二元搜尋樹。它通過給每個節點標記顏色（紅或黑）並遵循一系列規則來保證樹的平衡，插入和刪除的開銷相對較小。許多標準程式庫（如 C++ STL 的 `std::map` 和 `std::set`，Java 的 `TreeMap` 和 `TreeSet`）都使用紅黑樹作為底層實現。

-----

### 4. 進階內容

#### 4.1 二元樹的應用

二元樹作為一種基本的樹結構，在電腦科學中有著廣泛的應用：

-   **表達式樹 (Expression Trees)**：用於表示數學或邏輯表達式。內部節點代表運算符，葉節點代表操作數。這使得表達式的求值、轉換（例如從中序轉後序）變得簡單。
-   **霍夫曼編碼 (Huffman Coding)**：一種數據壓縮演算法，利用頻率構建霍夫曼樹來為字元生成變長前綴編碼，頻率高的字元得到短碼。
-   **決策樹 (Decision Trees)**：在機器學習中，決策樹用於分類和回歸。每個內部節點代表一個屬性測試，每個分支代表測試的一個結果，每個葉節點代表一個類別標籤或數值。

#### 4.2 二元搜尋樹的應用

由於其高效的搜尋、插入、刪除和有序訪問特性，BST 及其變種被廣泛應用：

-   **字典/映射 (Dictionary/Map)**：可以作為鍵值對儲存的底層資料結構，支援按鍵快速查找、插入和刪除。
-   **優先佇列 (Priority Queues)**：雖然堆是更常見的優先佇列實現，但 BST 也可以用於實現優先佇列，特別是在需要頻繁修改優先級或合併佇列時。
-   **排序 (Sorting)**：通過將所有元素插入到 BST 中，然後執行中序遍歷，可以得到一個排序好的序列（這種排序方式稱為樹排序）。
-   **數據庫索引 (Database Indexing)**：B 樹和 B+ 樹是基於 BST 概念的多路搜尋樹，它們是數據庫中實現索引的常用結構，特別適合於磁碟儲存的數據。

-----

### 5. 常見錯誤與澄清

1.  **誤解：所有二元樹都是二元搜尋樹。**
    -   **澄清**：錯誤。二元搜尋樹是二元樹的一個子集。二元樹只要滿足「每個節點最多有兩個子節點」即可，對節點值沒有排序要求。而二元搜尋樹則額外要求左子樹的值都小於根節點，右子樹的值都大於根節點。

2.  **誤解：二元搜尋樹的操作時間複雜度總是 $O(\log N)$。**
    -   **澄清**：這是平均情況下的性能。在最差情況下（例如，插入的元素總是遞增或遞減，導致樹退化成一條鏈結），操作的時間複雜度會退化到 $O(N)$。這正是需要平衡二元搜尋樹（如 AVL 樹、紅黑樹）的原因。

3.  **誤解：二元搜尋樹的節點值必須是唯一的。**
    -   **澄清**：這取決於具體的實現。BST 的定義本身不強制要求值唯一。如果允許重複值，通常有兩種處理方式：
        -   將重複值插入到左子樹或右子樹（保持一致性，例如都插入到左子樹），但這會稍微違反「左子樹小於、右子樹大於」的嚴格定義，變成「左子樹小於等於、右子樹大於」或「左子樹小於、右子樹大於等於」。
        -   在節點中儲存一個計數器，而不是插入多個相同值的節點。
        -   更常見且嚴格的實現會假設值是唯一的，在插入重複值時會忽略或拋出錯誤。

4.  **遍歷順序的混淆。**
    -   **澄清**：
        -   **前序 (Pre-order)**：先根節點，再左子樹，再右子樹。（Root -> Left -> Right）
        -   **中序 (In-order)**：先左子樹，再根節點，再右子樹。（Left -> Root -> Right）- **對於 BST，中序遍歷會得到一個升序排序的序列。**
        -   **後序 (Post-order)**：先左子樹，再右子樹，再根節點。（Left -> Right -> Root）
    務必理解根節點在遍歷順序中的位置差異。

-----

### 6. 小練習（附詳解）

#### 小練習 1：二元樹遍歷

給定以下二元樹結構：
```
       10
      /  \
     5    15
    / \   / \
   2   7 12  18
```

請寫出其：
a) 前序遍歷 (Pre-order Traversal) 結果
b) 中序遍歷 (In-order Traversal) 結果
c) 後序遍歷 (Post-order Traversal) 結果
d) 層次遍歷 (Level-order Traversal) 結果

---

**詳解 1：**

a) **前序遍歷 (Root -> Left -> Right)**
   1. 訪問 10 (根)。
   2. 訪問 5 (左子樹的根)。
   3. 訪問 2 (5 的左子樹的根)。
   4. 訪問 7 (5 的右子樹的根)。
   5. 訪問 15 (右子樹的根)。
   6. 訪問 12 (15 的左子樹的根)。
   7. 訪問 18 (15 的右子樹的根)。
   **結果：10 -> 5 -> 2 -> 7 -> 15 -> 12 -> 18**

b) **中序遍歷 (Left -> Root -> Right)**
   1. 訪問 2 (5 的左子樹的左子樹)。
   2. 訪問 5 (左子樹的根)。
   3. 訪問 7 (5 的右子樹)。
   4. 訪問 10 (根)。
   5. 訪問 12 (15 的左子樹)。
   6. 訪問 15 (右子樹的根)。
   7. 訪問 18 (15 的右子樹)。
   **結果：2 -> 5 -> 7 -> 10 -> 12 -> 15 -> 18**
   (注意：由於這是一個 BST，中序遍歷結果是排序好的序列)

c) **後序遍歷 (Left -> Right -> Root)**
   1. 訪問 2 (5 的左子樹的左子樹)。
   2. 訪問 7 (5 的右子樹)。
   3. 訪問 5 (左子樹的根)。
   4. 訪問 12 (15 的左子樹)。
   5. 訪問 18 (15 的右子樹)。
   6. 訪問 15 (右子樹的根)。
   7. 訪問 10 (根)。
   **結果：2 -> 7 -> 5 -> 12 -> 18 -> 15 -> 10**

d) **層次遍歷 (Level by Level, Left to Right)**
   1. 第一層：10
   2. 第二層：5, 15
   3. 第三層：2, 7, 12, 18
   **結果：10 -> 5 -> 15 -> 2 -> 7 -> 12 -> 18**

---

#### 小練習 2：二元搜尋樹操作

從一個空的二元搜尋樹開始，依序插入以下數字：`20, 10, 30, 5, 15, 25, 35, 2`。
a) 畫出最終的二元搜尋樹結構。
b) 搜尋數字 `25`，請描述搜尋路徑。
c) 刪除數字 `10`，請畫出刪除後的樹結構。

---

**詳解 2：**

a) **最終的二元搜尋樹結構：**
   1. 插入 20：
      ```
        20
      ```
   2. 插入 10 ($10 < 20$):
      ```
        20
       /
      10
      ```
   3. 插入 30 ($30 > 20$):
      ```
        20
       /  \
      10   30
      ```
   4. 插入 5 ($5 < 20$, $5 < 10$):
      ```
        20
       /  \
      10   30
     /
    5
      ```
   5. 插入 15 ($15 < 20$, $15 > 10$):
      ```
        20
       /  \
      10   30
     /  \
    5   15
      ```
   6. 插入 25 ($25 > 20$, $25 < 30$):
      ```
        20
       /  \
      10   30
     /  \ /
    5   15 25
      ```
   7. 插入 35 ($35 > 20$, $35 > 30$):
      ```
        20
       /  \
      10   30
     /  \ /  \
    5   15 25  35
      ```
   8. 插入 2 ($2 < 20$, $2 < 10$, $2 < 5$):
      ```
            20
           /  \
          10   30
         /  \ /  \
        5   15 25  35
       /
      2
      ```
   **最終樹結構：**
   ```
         20
        /  \
       10   30
      /  \ /  \
     5   15 25  35
    /
   2
   ```

b) **搜尋數字 `25`：**
   1. 從根節點 `20` 開始。`25 > 20`，向右走。
   2. 到達節點 `30`。`25 < 30`，向左走。
   3. 到達節點 `25`。`25 == 25`，找到目標值。
   **搜尋路徑：20 -> 30 -> 25**

c) **刪除數字 `10`：**
   節點 `10` 有兩個子節點（`5` 和 `15`）。我們需要找到它的中序後繼（右子樹中的最小值），也就是 `15`。
   1. 將節點 `10` 的值替換為其後繼 `15` 的值。
   2. 刪除原來的後繼節點 `15`。原來的 `15` 是 `10` 的右子節點，且它是一個葉節點（因為它被 `5` 取代，它本身沒有子節點了，或者我們考慮原來的 `15` 是 `10` 的右子節點，它沒有子節點），所以直接移除即可。

   **刪除步驟：**
   原始樹：
   ```
         20
        /  \
       10   30
      /  \ /  \
     5   15 25  35
    /
   2
   ```
   1. 找到要刪除的節點 `10`。
   2. 找到 `10` 的中序後繼，即 `10` 右子樹中最小的節點。`10` 的右子樹根是 `15`，其沒有左子節點，所以 `15` 是中序後繼。
   3. 將 `10` 的值替換為 `15`。
   4. 遞歸地刪除 `15`（原 `10` 的右子節點）。原 `15` 是葉節點，直接移除。

   **刪除後的樹結構：**
   ```
         20
        /  \
       15   30
      /  \ /  \
     5   (null) 25  35  <-- 原15的位置 now empty
    /
   2
   ```
   簡化後為：
   ```
         20
        /  \
       15   30
      /   /  \
     5   25  35
    /
   2
   ```

-----

### 7. 延伸閱讀/參考

-   **書籍**：
    -   《資料結構與演算法分析 (Data Structures and Algorithm Analysis in C++/Java/C)》：Mark Allen Weiss 著，經典的資料結構教科書，對二元樹和 BST 有詳細的理論和程式碼實現。
    -   《演算法導論 (Introduction to Algorithms)》：Thomas H. Cormen 等著，內容全面深入，包含二元搜尋樹的變種，如紅黑樹。
-   **線上課程**：
    -   Coursera/edX 上有許多知名大學開設的資料結構與演算法課程，涵蓋二元樹和二元搜尋樹。
    -   LeetCode 和 HackerRank 等線上平台提供了大量關於樹的練習題。
-   **相關主題**：
    -   **平衡二元搜尋樹**：深入學習 AVL 樹、紅黑樹的原理和實現，它們是許多高效率資料庫和資料結構的基礎。
    -   **B 樹 (B-Trees) 和 B+ 樹 (B+ Trees)**：這些是多路搜尋樹，常用於資料庫索引和檔案系統，特別適用於處理大量儲存在磁碟上的數據。
    -   **Trie 樹**：用於高效的字串搜尋和前綴匹配。
    -   **堆 (Heaps)**：另一種基於二元樹的資料結構，用於實現優先佇列。