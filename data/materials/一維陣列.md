# 一維陣列 (One-Dimensional Array)

一維陣列是最基礎也最常用的資料結構之一。理解它對於學習更複雜的資料結構與演算法至關重要。本章節將深入探討一維陣列的核心概念、應用、以及與其他資料結構的關係。

-----

### 核心概念與定義

#### 什麼是一維陣列？

一維陣列是一種線性（或序列性）的資料結構，用於儲存**相同資料類型**元素的**有序集合**。這些元素通常在記憶體中是**連續存放**的，並且可以透過一個唯一的**索引**（或下標）直接存取。

#### 核心觀念

1.  **同質性 (Homogeneity)**
    *   **定義：** 陣列中的所有元素必須是相同的資料類型。例如，一個整數陣列只能儲存整數，不能同時儲存字串或浮點數。
    *   **重要性：** 確保了每個元素佔用的記憶體大小一致，方便記憶體管理和索引計算。

2.  **固定大小 (Fixed Size)**
    *   **定義：** 在大多數靜態型別語言（如 C, C++, Java）中，陣列一旦被宣告並初始化，其大小（可儲存的元素數量）便是固定的，無法在運行時改變。
    *   **例外：** 某些語言（如 Python 的 `list` 或 JavaScript 的 `Array`）提供了類似陣列的資料結構，它們在底層可能透過動態陣列實現，可以動態調整大小。但這些通常不是嚴格意義上的「靜態一維陣列」。

3.  **索引 (Indexing)**
    *   **定義：** 陣列中的每個元素都有一個唯一的整數編號，稱為索引（或下標），用於識別和存取該元素。
    *   **起始點：** 大多數程式語言採用**0-based indexing**，即第一個元素的索引是 0，第二個是 1，依此類推，直到最後一個元素的索引是 `大小 - 1`。少數語言（如 Fortran）可能支援 1-based indexing。
    *   **優勢：** 透過索引可以直接跳轉到記憶體中的特定位置，實現 $O(1)$ 的存取時間複雜度。

4.  **記憶體連續性 (Memory Contiguity)**
    *   **定義：** 陣列的所有元素在記憶體中是緊密相連、連續存放的。
    *   **重要性：**
        *   **高效存取：** 由於元素記憶體位址連續，計算任何元素的位址都非常快。
        *   **快取友好：** CPU 快取在載入一個記憶體位置時，通常也會預取相鄰的記憶體塊，這對連續存放的陣列操作（如遍歷）非常有利，提高執行效率。

#### 圖示說明

假設有一個儲存了 5 個整數的陣列 `scores`：

```
+-------+-------+-------+-------+-------+
|  95   |  88   |  72   |  60   |  99   |
+-------+-------+-------+-------+-------+
  [0]     [1]     [2]     [3]     [4]
```

*   `scores[0]` 的值是 95
*   `scores[3]` 的值是 60
*   陣列的大小是 5。合法的索引範圍是 0 到 4。

-----

### 典型例子與操作

#### 陣列的宣告與初始化

在不同的程式語言中，一維陣列的宣告和初始化方式略有不同。

**C++ 範例：**

```cpp
// 宣告一個包含 5 個整數的陣列，並自動初始化為預設值 (全域/靜態陣列為0，局部陣列為不確定值)
int numbers[5];

// 宣告並同時初始化
int primes[] = {2, 3, 5, 7, 11}; // 編譯器會自動推斷大小為 5
int grades[3] = {85, 90, 78};   // 宣告大小為 3，並初始化前三個元素
int empty_arr[5] = {};         // C++11 後可將所有元素初始化為 0

// 動態配置陣列 (在堆疊上)
int* dynamic_array = new int[10]; // 宣告一個包含 10 個整數的陣列
// ... 使用 dynamic_array ...
delete[] dynamic_array;         // 釋放記憶體
```

**Java 範例：**

```java
// 宣告一個整數陣列變數
int[] numbers;

// 創建一個包含 5 個整數的陣列實例，所有元素自動初始化為 0 (預設值)
numbers = new int[5];

// 宣告並同時創建和初始化
int[] primes = {2, 3, 5, 7, 11};

// 宣告、創建並指定大小，同時初始化部分元素 (其餘為預設值)
int[] grades = new int[]{85, 90, 78}; // 大小為 3
```

**Python 範例 (使用列表 `list` 模擬一維陣列)：**

雖然 Python 沒有內建的「靜態一維陣列」概念，但其 `list` 型別在行為上常用來模擬陣列。

```python
# 創建一個空的列表
my_list = []

# 創建並初始化
primes = [2, 3, 5, 7, 11]

# 創建一個包含 5 個元素，每個元素都是 0 的列表
numbers = [0] * 5 # [0, 0, 0, 0, 0]

# 列表可以動態增減元素，這與固定大小的陣列不同
my_list.append(10) # [10]
```

#### 存取陣列元素

透過索引直接存取陣列元素是其最核心的操作。

```cpp
// C++ 範例
int numbers[5] = {10, 20, 30, 40, 50};
int first_element = numbers[0]; // 取得第一個元素的值 (10)
numbers[2] = 35;                // 將第三個元素的值修改為 35
std::cout << numbers[2];        // 輸出 35
```

```java
// Java 範例
int[] numbers = {10, 20, 30, 40, 50};
int first_element = numbers[0]; // 取得第一個元素的值 (10)
numbers[2] = 35;                // 將第三個元素的值修改為 35
System.out.println(numbers[2]); // 輸出 35
```

```python
# Python 範例
numbers = [10, 20, 30, 40, 50]
first_element = numbers[0]  # 取得第一個元素的值 (10)
numbers[2] = 35             # 將第三個元素的值修改為 35
print(numbers[2])           # 輸出 35
```

#### 遍歷陣列

遍歷是指逐一訪問陣列中的每個元素，通常使用迴圈實現。

```cpp
// C++ 範例
int scores[] = {85, 92, 78, 95, 88};
int size = sizeof(scores) / sizeof(scores[0]); // 計算陣列大小

// 使用 for 迴圈遍歷 (傳統方式)
for (int i = 0; i < size; ++i) {
    std::cout << scores[i] << " ";
}
std::cout << std::endl; // 輸出: 85 92 78 95 88

// 使用 C++11 範圍-based for 迴圈
for (int score : scores) {
    std::cout << score << " ";
}
std::cout << std::endl;
```

```java
// Java 範例
int[] scores = {85, 92, 78, 95, 88};

// 使用 for 迴圈遍歷 (傳統方式)
for (int i = 0; i < scores.length; i++) {
    System.out.print(scores[i] + " ");
}
System.out.println(); // 輸出: 85 92 78 95 88

// 使用增強型 for 迴圈 (for-each)
for (int score : scores) {
    System.out.print(score + " ");
}
System.out.println();
```

```python
# Python 範例
scores = [85, 92, 78, 95, 88]

# 使用 for 迴圈遍歷 (直接遍歷元素)
for score in scores:
    print(score, end=" ")
print() # 輸出: 85 92 78 95 88

# 使用 for 迴圈遍歷 (透過索引)
for i in range(len(scores)):
    print(scores[i], end=" ")
print()
```

#### 記憶體位址計算 (推導)

陣列的記憶體連續性是其高效存取的基石。我們可以推導出陣列中任意元素的記憶體位址。

假設：
*   陣列 `A` 的起始記憶體位址（即 `A[0]` 的位址）為 $B$ (Base Address)。
*   陣列中的每個元素佔用 $S$ 位元組 (Size of each element)。
*   我們使用 0-based indexing。

則陣列中第 $i$ 個元素（即 `A[i]`）的記憶體位址可以計算為：

$Address(A[i]) = B + i \times S$

**推導解釋：**
*   `A[0]` 的位址是 $B + 0 \times S = B$。
*   `A[1]` 的位址是 $B + 1 \times S$ (緊接在 `A[0]` 之後)。
*   `A[2]` 的位址是 $B + 2 \times S$ (緊接在 `A[1]` 之後)。
*   依此類推，`A[i]` 的位址就是起始位址加上 $i$ 個元素所佔的總記憶體大小。

這種簡單的算術計算使得陣列元素的存取時間複雜度為 $O(1)$，因為無論陣列有多大，存取任何元素所需的計算量都是固定的。

-----

### 與相鄰概念的關聯

#### 與變數 (Variables)

*   **單一 vs. 集合：** 變數儲存一個單一的值，而陣列儲存多個相同類型的值。陣列可以被看作是多個變數的集合，但這些變數透過索引被統一管理。
*   **命名：** 每個變數都有一個唯一的名稱，而陣列本身有一個名稱，其內部元素則透過名稱與索引組合來識別（e.g., `score` vs. `grades[0]`, `grades[1]`, ...）。

#### 與結構體/物件 (Structs/Objects)

*   **同質性 vs. 異質性：** 陣列要求所有元素類型相同（同質性），而結構體（在 C/C++ 中）或物件（在物件導向語言中）可以將**不同類型**的資料組合在一起，形成一個單一的邏輯實體（異質性）。
*   **用途：** 陣列適合儲存大量同類型資料的集合；結構體/物件適合描述一個具有多個屬性（不同類型）的實體。
*   **組合：** 陣列的元素可以是結構體或物件。例如，一個學生陣列 `Student students[5];`，其中每個 `Student` 都是一個結構體或物件。

#### 與指標 (Pointers) (主要針對 C/C++)

*   **密切關係：** 在 C/C++ 中，陣列名本身常被視為一個指向其第一個元素的常數指標。這意味著在許多情況下，陣列名可以像指標一樣使用。
*   **指標算術：** 透過指標算術，可以像陣列索引一樣存取元素。例如，`*(arr + i)` 等價於 `arr[i]`。
*   **衰退 (Array Decay)：** 當陣列作為函數參數傳遞時，它會「衰退」成一個指向其第一個元素的指標，失去其原始的大小資訊。這解釋了為什麼在 C/C++ 中，將陣列傳遞給函數時，通常也需要傳遞其大小。
*   **區別：** 儘管關係密切，但陣列和指標並非完全相同。陣列名是一個常數位址，不能被重新賦值；而指標變數可以指向不同的位址。`sizeof(array_name)` 通常會給出整個陣列的大小（位元組），而 `sizeof(pointer_name)` 只會給出指標變數本身的大小（通常是 4 或 8 位元組）。

#### 與串列/動態陣列 (Lists/Dynamic Arrays)

*   **固定大小 vs. 可變大小：**
    *   **一維陣列：** 大小在創建時固定，無法直接改變。若需改變大小，通常需要創建一個新的更大或更小的陣列，並將舊陣列的內容複製過去。
    *   **串列/動態陣列：** (例如 C++ 的 `std::vector`、Java 的 `ArrayList`、Python 的 `list`) 提供了動態調整大小的能力。當容量不足時，它們會自動分配更大的記憶體塊，並將現有元素複製到新記憶體中。
*   **效率考量：**
    *   **存取：** 兩者都支援 $O(1)$ 的隨機存取。
    *   **插入/刪除：**
        *   **一維陣列：** 在陣列中間插入或刪除元素需要移動大量後續元素，時間複雜度為 $O(N)$。
        *   **動態陣列：** 類似陣列，中間插入/刪除也是 $O(N)$。但在尾部插入通常是 $O(1)$（分攤分析後）。
    *   **記憶體分配：**
        *   **一維陣列：** 一次性分配，執行時開銷小。
        *   **動態陣列：** 可能會發生多次記憶體重新分配和複製操作，這會帶來額外的性能開銷，尤其是在頻繁增長的情況下。
*   **選擇：** 當元素的數量已知且不變時，一維陣列通常是更高效和簡潔的選擇。當元素數量不確定或需要頻繁增減時，動態陣列或串列更為靈活。

-----

### 進階內容

#### 陣列作為函數參數傳遞 (C/C++)

在 C/C++ 中，將陣列傳遞給函數時，實際上傳遞的是陣列的**首位址**，而不是整個陣列的副本。這就是所謂的「傳址呼叫」或「傳參考呼叫」行為。

```cpp
#include <iostream>

// 函數接收一個整數指標和陣列大小
void printArray(int* arr, int size) {
    std::cout << "Inside printArray: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    arr[0] = 99; // 修改了陣列的元素，這會影響原始陣列
}

// 另一種寫法，語法上更像陣列
void modifyArray(int arr[], int size) {
    arr[1] = 100; // 同樣會修改原始陣列
}

int main() {
    int myNumbers[] = {10, 20, 30, 40, 50};
    int size = sizeof(myNumbers) / sizeof(myNumbers[0]);

    printArray(myNumbers, size);
    std::cout << "After printArray, myNumbers[0]: " << myNumbers[0] << std::endl; // 輸出 99

    modifyArray(myNumbers, size);
    std::cout << "After modifyArray, myNumbers[1]: " << myNumbers[1] << std::endl; // 輸出 100

    return 0;
}
```
**說明：**
1.  函數 `printArray` 和 `modifyArray` 都接收了 `myNumbers` 陣列的首位址。
2.  在函數內部對 `arr` 的修改，實際上是對 `myNumbers` 的修改。
3.  由於陣列衰退，函數無法自行判斷傳入陣列的大小，因此通常需要額外傳遞 `size` 參數。

#### 多維陣列簡介 (由一維陣列延伸)

多維陣列可以看作是「陣列的陣列」。最常見的是二維陣列（矩陣），它是由多個一維陣列組成的。

**概念：** 一個 $M \times N$ 的二維陣列，實際上是一個包含 $M$ 個元素的一維陣列，而每個元素又是一個包含 $N$ 個元素的一維陣列。

**記憶體模型：**
在大多數程式語言中，多維陣列在記憶體中仍然是按**一維連續存放**的。常見的存放方式有兩種：
1.  **行主序 (Row-Major Order)：** 先存第一行的所有元素，再存第二行，依此類推。這是 C/C++, Java 等語言的預設方式。
    *   對於 `arr[row][col]`，其記憶體位址為 $B + (row \times N + col) \times S$。
2.  **列主序 (Column-Major Order)：** 先存第一列的所有元素，再存第二列，依此類推。這是 Fortran 等語言的預設方式。
    *   對於 `arr[row][col]`，其記憶體位址為 $B + (col \times M + row) \times S$。

**範例 (C++ 二維陣列)：**
```cpp
int matrix[3][4]; // 3 行 4 列的整數矩陣
// 相當於：一個包含 3 個元素的陣列，每個元素都是一個包含 4 個整數的陣列。
```
`matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3]` 會連續存放，接著是 `matrix[1][0], ...`。

理解多維陣列如何由一維陣列的基礎概念延伸，有助於把握其記憶體佈局和存取邏輯。

-----

### 常見錯誤與澄清

#### 1. 索引越界 (Index Out of Bounds)

*   **錯誤：** 嘗試存取陣列範圍之外的索引，例如對大小為 `N` 的陣列存取 `arr[N]` 或 `arr[-1]`。
*   **後果：**
    *   **C/C++：** 導致「未定義行為 (Undefined Behavior)」。程式可能崩潰、產生錯誤結果，或看似正常運行但潛在的記憶體損壞。這是一個嚴重的安全漏洞和程式錯誤來源。
    *   **Java：** 拋出 `ArrayIndexOutOfBoundsException` 運行時異常，程式會終止。
    *   **Python：** 拋出 `IndexError: list index out of range` 運行時錯誤。
*   **澄清：** 始終確保使用的索引在合法範圍內：`0` 到 `陣列大小 - 1`。使用迴圈遍歷時要特別小心迴圈條件 (`< size` 而不是 `<= size`)。

#### 2. 陣列大小錯誤理解 (C/C++)

*   **錯誤：** 在 C/C++ 中，錯誤地使用 `sizeof` 運算符來判斷作為函數參數傳遞的陣列大小。
    ```cpp
    void func(int arr[]) {
        // 錯誤：這裡 sizeof(arr) 將返回指標的大小 (通常是 4 或 8 位元組)，而不是陣列的實際大小
        int size = sizeof(arr) / sizeof(arr[0]);
    }
    ```
*   **澄清：** 當陣列作為函數參數傳遞時，它會衰退成一個指標。因此，`sizeof(arr)` 會返回指標本身的大小。若要獲得陣列的實際大小，必須將其作為單獨的參數傳遞。

#### 3. 陣列未初始化問題

*   **錯誤：** 宣告陣列後，在沒有初始化其元素的情況下直接使用。
    ```cpp
    int arr[5]; // 局部變量陣列，元素值不確定
    std::cout << arr[0]; // 可能輸出垃圾值
    ```
*   **後果：** 陣列元素將包含記憶體中當時的「垃圾值」，導致程式行為不可預測或錯誤。
*   **澄清：** 宣告陣列後，務必在使用前初始化其所有元素。這可以透過宣告時直接賦值、使用迴圈逐一賦值，或在某些語言中依靠預設初始化（例如 Java 中數值型別陣列元素預設為 0，布林型別為 false）。

#### 4. C/C++ 中陣列與指標的混淆

*   **錯誤：** 認為陣列名與指標完全等價，例如嘗試對陣列名進行 `arr = another_arr;` 這樣的賦值操作。
*   **澄清：**
    *   **陣列名是一個常數指標：** 它指向陣列的第一個元素，並且不能被重新賦值去指向其他地方。
    *   **指標是一個變數：** 它可以被賦值以指向不同的記憶體位址。
    *   `int arr[5];` 是一個陣列的宣告。
    *   `int* ptr;` 是一個指標的宣告。
    *   `ptr = arr;` 是合法的，表示指標 `ptr` 現在指向陣列 `arr` 的開頭。
    *   `arr = ptr;` 是非法的，因為 `arr` 是常數位址。

-----

### 小練習（附詳解）

#### 練習 1: 計算陣列元素的總和與平均值

**題目：**
給定一個整數陣列，請編寫程式計算其所有元素的總和 (sum) 及平均值 (average)。

**輸入範例：**
`int numbers[] = {15, 20, 25, 30, 35};`

**輸出範例：**
總和: 125
平均值: 25.0

**詳解：**

1.  **定義陣列與變數：**
    *   宣告並初始化給定的整數陣列。
    *   宣告一個變數來儲存總和，並初始化為 0。
    *   宣告一個變數來儲存陣列的大小。
2.  **遍歷陣列並累加：**
    *   使用 `for` 迴圈從索引 0 開始遍歷到 `大小 - 1`。
    *   在迴圈中，將每個元素的值加到總和變數中。
3.  **計算平均值：**
    *   總和除以陣列的大小即可得到平均值。
    *   注意：為了得到浮點數的平均值，確保除法操作中至少一個操作數是浮點數（例如，將總和轉換為 `double` 或 `float`）。
4.  **輸出結果：**
    *   印出計算出的總和和平均值。

**C++ 程式碼範例：**

```cpp
#include <iostream>
#include <numeric> // For std::accumulate (optional, for advanced users)

int main() {
    int numbers[] = {15, 20, 25, 30, 35};
    int size = sizeof(numbers) / sizeof(numbers[0]); // 計算陣列大小
    int sum = 0;
    double average;

    // 步驟 2: 遍歷陣列並累加
    for (int i = 0; i < size; ++i) {
        sum += numbers[i];
    }

    // 步驟 3: 計算平均值
    // 確保至少一個操作數是浮點數，以進行浮點除法
    average = static_cast<double>(sum) / size;

    // 步驟 4: 輸出結果
    std::cout << "總和: " << sum << std::endl;
    std::cout << "平均值: " << average << std::endl;

    return 0;
}
```

-----

#### 練習 2: 尋找陣列中的最大值

**題目：**
給定一個整數陣列，請編寫程式找出其中的最大值。

**輸入範例：**
`int data[] = {7, 12, 4, 9, 18, 6};`

**輸出範例：**
最大值為: 18

**詳解：**

1.  **定義陣列與初始化最大值：**
    *   宣告並初始化給定的整數陣列。
    *   宣告一個變數 `max_value` 來儲存目前找到的最大值。
    *   將 `max_value` 初始化為陣列的第一個元素。這是一個安全且常見的做法，因為陣列至少有一個元素。
2.  **遍歷陣列並比較：**
    *   使用 `for` 迴圈從索引 1（因為索引 0 已經用來初始化 `max_value`）開始遍歷到 `大小 - 1`。
    *   在迴圈中，將當前元素與 `max_value` 進行比較。
    *   如果當前元素大於 `max_value`，則更新 `max_value` 為當前元素的值。
3.  **輸出結果：**
    *   迴圈結束後，`max_value` 將儲存陣列中的最大值，將其印出。

**Java 程式碼範例：**

```java
public class ArrayMaxValue {
    public static void main(String[] args) {
        int[] data = {7, 12, 4, 9, 18, 6};
        
        // 步驟 1: 初始化最大值 (假設陣列至少有一個元素)
        int max_value = data[0];

        // 步驟 2: 遍歷陣列並比較 (從第二個元素開始)
        for (int i = 1; i < data.length; i++) {
            if (data[i] > max_value) {
                max_value = data[i];
            }
        }
        
        // 步驟 3: 輸出結果
        System.out.println("最大值為: " + max_value);
    }
}
```

-----

### 延伸閱讀與參考

*   **資料結構與演算法經典教材：**
    *   《資料結構與演算法 (Data Structures and Algorithms in C++)》 - Goodrich, Tamassia, Mount
    *   《演算法導論 (Introduction to Algorithms)》 - Cormen, Leiserson, Rivest, Stein (CLRS)
    *   《算法 (Algorithms)》 - Robert Sedgewick, Kevin Wayne (注重 Java 實現)

*   **特定語言的陣列文檔：**
    *   [C++ std::array - cppreference.com](https://en.cppreference.com/w/cpp/container/array) (靜態大小陣列)
    *   [C++ std::vector - cppreference.com](https://en.cppreference.com/w/cpp/container/vector) (動態陣列)
    *   [Java Arrays - Oracle Documentation](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)
    *   [Python Lists - Python Documentation](https://docs.python.org/3/tutorial/introduction.html#lists)

*   **相關資料結構：**
    *   **鏈結串列 (Linked List)：** 另一種線性資料結構，與陣列不同的是，其元素在記憶體中不一定是連續的，透過指標連接。優勢在於插入和刪除操作的高效率 ($O(1)$)。
    *   **動態陣列 (Dynamic Array / Vector / ArrayList)：** 在陣列基礎上實現，提供動態調整大小的能力，兼具陣列的隨機存取效率和鏈結串列的彈性。
    *   **雜湊表 (Hash Table)：** 透過雜湊函數實現快速的鍵值對儲存和檢索，通常底層會用到陣列。

*   **記憶體管理：**
    *   理解堆疊 (Stack) 與堆積 (Heap) 記憶體區域如何影響陣列的配置與生命週期。

持續學習這些相關概念，將幫助你更深入地理解陣列在不同情境下的優缺點和應用。