# Chapter 4 佇列與堆疊

本章將深入探討兩種基本且廣泛使用的線性資料結構：佇列 (Queue) 與堆疊 (Stack)。它們雖然簡單，卻是許多複雜演算法與系統設計的基石。了解它們的核心概念、實作方式及其應用，對於學習資料結構與演算法至關重要。

-----

### 核心概念與定義

堆疊與佇列是兩種特殊的線性資料結構，它們對元素的存取方式施加了嚴格的限制。

#### 堆疊 (Stack)

堆疊是一種「後進先出」(Last-In, First-Out, LIFO) 的資料結構。想像一疊盤子，你只能在最上方放盤子或取走最上方的盤子。最後放的盤子會最先被取走。

*   **定義：** 堆疊是一個元素的有序集合，其新增和刪除操作都只能在集合的一端進行，這一端稱為「頂部」(Top)。
*   **主要操作：**
    *   `push(element)`：將元素新增到堆疊的頂部。時間複雜度通常為 $O(1)$。
    *   `pop()`：移除並回傳堆疊頂部的元素。如果堆疊為空，則會引發錯誤。時間複雜度通常為 $O(1)$。
    *   `peek()` (或 `top()` )：回傳堆疊頂部的元素，但不將其移除。如果堆疊為空，則會引發錯誤。時間複雜度通常為 $O(1)$。
    *   `isEmpty()`：判斷堆疊是否為空。回傳布林值。時間複雜度通常為 $O(1)$。
    *   `size()`：回傳堆疊中元素的數量。時間複雜度通常為 $O(1)$。

*   **圖例：**
    ```
    -----      -----
    | C |      |   |  <- pop()
    -----      -----
    | B |  <- push(C)
    -----
    | A |
    -----
    底
    ```

#### 佇列 (Queue)

佇列是一種「先進先出」(First-In, First-Out, FIFO) 的資料結構。想像人們在銀行排隊，最先排隊的人會最先獲得服務。

*   **定義：** 佇列是一個元素的有序集合，其新增操作 (稱為 `enqueue`) 總是在集合的一端進行，這一端稱為「尾部」(Rear 或 Back)；刪除操作 (稱為 `dequeue`) 總是在集合的另一端進行，這一端稱為「頭部」(Front)。
*   **主要操作：**
    *   `enqueue(element)`：將元素新增到佇列的尾部。時間複雜度通常為 $O(1)$。
    *   `dequeue()`：移除並回傳佇列頭部的元素。如果佇列為空，則會引發錯誤。時間複雜度通常為 $O(1)$。
    *   `front()` (或 `peek()` )：回傳佇列頭部的元素，但不將其移除。如果佇列為空，則會引發錯誤。時間複雜度通常為 $O(1)$。
    *   `isEmpty()`：判斷佇列是否為空。回傳布林值。時間複雜度通常為 $O(1)$。
    *   `size()`：回傳佇列中元素的數量。時間複雜度通常為 $O(1)$。

*   **圖例：**
    ```
    <- dequeue() [ A | B | C ] <- enqueue(D)
                 頭          尾
    ```

-----

### 實作方式與典型應用

堆疊與佇列作為抽象資料型別 (Abstract Data Type, ADT)，可以透過不同的底層資料結構來實作，最常見的是陣列和鏈結串列。

#### 堆疊的實作

無論是陣列或鏈結串列，實作堆疊的關鍵是確保所有操作都集中在一個「頂部」進行。

*   **以陣列實作堆疊 (Array-based Stack):**
    *   **概念：** 使用一個固定大小的陣列來儲存元素，並用一個整數變數 (例如 `top` 或 `stackPointer`) 來追蹤堆疊頂部元素的索引。`push` 時將元素放入 `top` 所指位置並增加 `top`；`pop` 時減少 `top` 並回傳原 `top` 所指元素。
    *   **優點：** 記憶體連續，存取速度快。
    *   **缺點：** 大小固定，可能發生「堆疊溢位」(Stack Overflow) 如果嘗試新增的元素超過陣列容量。
    *   **時間複雜度：** 所有基本操作 (push, pop, peek, isEmpty) 均為 $O(1)$。

*   **以鏈結串列實作堆疊 (Linked List-based Stack):**
    *   **概念：** 將單向鏈結串列的頭部作為堆疊的頂部。`push` 操作是將新節點插入到鏈結串列的頭部；`pop` 操作是移除鏈結串列的頭部節點。
    *   **優點：** 動態大小，不需要預先知道最大容量。
    *   **缺點：** 記憶體不連續，每個元素需要額外的指針空間。
    *   **時間複雜度：** 所有基本操作 (push, pop, peek, isEmpty) 均為 $O(1)$。

*   **典型應用：**
    1.  **函式呼叫堆疊 (Call Stack)：** 程式語言中的函式呼叫機制就是利用堆疊。每次函式呼叫都會將其上下文 (參數、區域變數、回傳地址) 壓入堆疊；函式回傳時，這些資訊會從堆疊中彈出。
    2.  **運算式求值：** 例如將中綴表達式 (infix expression) 轉換為後綴表達式 (postfix expression) 或前綴表達式 (prefix expression)，以及求值這些表達式。
    3.  **深度優先搜尋 (DFS)：** 在圖形或樹狀結構中進行深度優先遍歷時，可以使用堆疊來追蹤待訪問的節點。
    4.  **括號匹配：** 判斷數學或程式碼中的括號 (如 `()`, `[]`, `{}`) 是否正確配對。
    5.  **撤銷/重做 (Undo/Redo) 功能：** 每次操作都壓入堆疊，`Undo` 時彈出堆疊。

#### 佇列的實作

無論是陣列或鏈結串列，實作佇列的關鍵是確保 `enqueue` 在尾部進行，`dequeue` 在頭部進行。

*   **以陣列實作佇列 (循環佇列, Circular Queue):**
    *   **概念：** 使用一個固定大小的陣列，並維護 `front` (隊頭指針) 和 `rear` (隊尾指針)。為了避免每次 `dequeue` 都移動大量元素，或者 `front` 不斷前進導致陣列前方空間浪費，通常採用「循環佇列」。這意味著當指針到達陣列末尾時，它會「環繞」回到陣列的開頭 (使用模運算)。
    *   **優點：** 記憶體連續，有效利用陣列空間。
    *   **缺點：** 固定大小；需要巧妙處理 `front` 和 `rear` 指針來區分佇列是「滿」還是「空」 (例如，犧牲一個陣列單元，或者額外使用一個計數器)。
    *   **時間複雜度：** 所有基本操作 (enqueue, dequeue, front, isEmpty) 均為 $O(1)$。

*   **以鏈結串列實作佇列 (Linked List-based Queue):**
    *   **概念：** 使用單向鏈結串列，並維護 `front` (指向鏈結串列頭部) 和 `rear` (指向鏈結串列尾部) 兩個指針。`enqueue` 操作是將新節點插入到鏈結串列的尾部；`dequeue` 操作是移除鏈結串列的頭部節點。
    *   **優點：** 動態大小，不需要預先知道最大容量。
    *   **缺點：** 記憶體不連續，每個元素需要額外的指針空間。
    *   **時間複雜度：** 所有基本操作 (enqueue, dequeue, front, isEmpty) 均為 $O(1)$。

*   **典型應用：**
    1.  **作業系統排程：** CPU 排程器將就緒的行程放入佇列中，按照某種策略 (如 FIFO) 進行調度。
    2.  **印表機排隊：** 多個列印任務會被放入佇列，依序等待列印。
    3.  **廣度優先搜尋 (BFS)：** 在圖形或樹狀結構中進行廣度優先遍歷時，使用佇列來追蹤待訪問的節點。
    4.  **緩衝區 (Buffer)：** 資料在處理前暫存的區域，例如網路數據包的接收緩衝。
    5.  **模擬系統：** 許多模擬應用中，事件按照時間順序被放入佇列等待處理。

-----

### 與相鄰概念的關聯

堆疊和佇列不僅是獨立的資料結構，它們與其他重要的電腦科學概念也緊密相關。

#### 抽象資料型別 (ADT) 的具體實現

堆疊與佇列是典型的**抽象資料型別 (ADT)**。它們定義了一組操作 (例如 `push`, `pop`, `enqueue`, `dequeue`)，而不管這些操作是如何具體實現的。這就是說，它們只關注「可以做什麼」，而不關注「如何做到」。

*   **關聯：** 陣列和鏈結串列是實作這些 ADT 的**具體資料結構**。選擇哪種實作方式取決於應用程式的需求，例如對空間效率、時間效率或彈性大小的要求。

#### 遞迴與堆疊

遞迴是程式設計中一個強大的工具，其底層機制與堆疊密不可分。

*   **關聯：** 當一個函式呼叫自身時 (遞迴呼叫)，每次呼叫都會在系統的**函式呼叫堆疊**上建立一個新的「堆疊幀」(Stack Frame)。這個堆疊幀包含該次呼叫的區域變數、參數和回傳地址。當函式回傳時，其堆疊幀會從堆疊中彈出。因此，遞迴的深度直接受到函式呼叫堆疊大小的限制，過深的遞迴會導致「堆疊溢位」(Stack Overflow)。

#### 圖形遍歷與堆疊/佇列

在圖形和樹狀結構的遍歷演算法中，堆疊和佇列扮演著核心角色。

*   **廣度優先搜尋 (BFS) 與佇列：** BFS 演算法從起始節點開始，首先訪問其所有鄰居節點，然後再訪問鄰居節點的鄰居，依此類推。這種一層一層向外擴展的特性，恰好與佇列的 FIFO 原則相符。新發現的節點被放入佇列尾部，等待被訪問。
*   **深度優先搜尋 (DFS) 與堆疊：** DFS 演算法從起始節點開始，盡可能深地探索圖的分支，直到無法再深入為止，然後回溯。這種「一條路走到黑」的特性，可以使用堆疊來實現。新發現的節點被壓入堆疊，等待下次訪問。當無路可走時，彈出堆疊進行回溯。DFS 也可以自然地透過遞迴實現，而遞迴本身就是利用了系統的呼叫堆疊。

-----

### 進階概念

在掌握了堆疊和佇列的基本知識後，我們可以探索一些更進階的變體和應用。

#### 雙向佇列 (Deque - Double-Ended Queue)

雙向佇列是佇列的一種變體，它允許在佇列的兩端進行插入和刪除操作。

*   **定義：** 可以在頭部和尾部都進行 `enqueue` (新增) 和 `dequeue` (刪除) 操作的線性資料結構。
*   **主要操作：**
    *   `addFront(element)`: 將元素新增到佇列的頭部。
    *   `addRear(element)`: 將元素新增到佇列的尾部。
    *   `removeFront()`: 移除並回傳佇列頭部的元素。
    *   `removeRear()`: 移除並回傳佇列尾部的元素。
    *   `getFront()`: 回傳佇列頭部的元素。
    *   `getRear()`: 回傳佇列尾部的元素。
    *   `isEmpty()`, `size()` 等。
*   **實作：** 通常使用雙向鏈結串列或循環陣列來實作。
*   **應用：**
    *   **竊取工作排程 (Work-stealing scheduling)：** 在多執行緒環境中，一個空閒的執行緒可以從另一個忙碌執行緒的雙向佇列中「竊取」任務。
    *   儲存最近訪問的歷史紀錄，可以在兩端高效地新增和移除。

#### 使用堆疊實作佇列

這是一個經典的資料結構設計問題，展示了如何用一種基本資料結構來模擬另一種。

*   **概念：** 使用兩個堆疊，稱作 `inputStack` 和 `outputStack`。
    *   **`enqueue(element)` 操作：** 直接將元素 `push` 到 `inputStack`。
    *   **`dequeue()` 操作：**
        1.  如果 `outputStack` 不為空，則直接從 `outputStack` `pop` 出元素。
        2.  如果 `outputStack` 為空，則將 `inputStack` 中的所有元素逐一 `pop` 出並 `push` 到 `outputStack` 中。這樣，`inputStack` 中最早進入的元素就變成了 `outputStack` 的頂部元素。
        3.  最後，從 `outputStack` `pop` 出元素。
    *   **`front()` 操作：** 與 `dequeue` 類似，只是在找到頭部元素後不將其移除。
*   **原理：** `inputStack` 負責接收新元素 (LIFO)，當需要 `dequeue` 時，將所有元素倒轉到 `outputStack`，此時原 `inputStack` 的「底部」元素變成了 `outputStack` 的「頂部」，從而實現 FIFO。

#### 使用佇列實作堆疊

同樣是一個經典問題，說明如何用佇列來模擬堆疊的 LIFO 特性。

*   **概念：** 使用兩個佇列，稱作 `queue1` 和 `queue2`。
    *   **`push(element)` 操作：** 簡單地將元素 `enqueue` 到 `queue1`。
    *   **`pop()` 操作：** 這是挑戰所在。為了實現 LIFO，我們需要從 `queue1` 中取出「最後」進入的元素。
        1.  將 `queue1` 中除了最後一個元素以外的所有元素，逐一 `dequeue` 出並 `enqueue` 到 `queue2`。
        2.  此時，`queue1` 中只剩下一個元素，這個元素就是我們要 `pop` 的堆疊頂部元素。將其 `dequeue` 並回傳。
        3.  最後，交換 `queue1` 和 `queue2` (即讓 `queue2` 成為新的 `queue1`)，或者將 `queue2` 中的所有元素再移回 `queue1`。
    *   **`peek()` 操作：** 與 `pop` 類似，只是在找到頂部元素後不將其移除，而是重新 `enqueue` 到 `queue2` 或 `queue1`。
*   **原理：** `push` 操作簡單，但 `pop` 操作需要將 $N-1$ 個元素移動到另一個佇列，使得「最後一個」元素成為當前佇列的頭部，然後才能將其 `pop` 出。這使得 `pop` 操作的時間複雜度為 $O(N)$。

-----

### 常見錯誤與澄清

在學習和使用堆疊與佇列時，一些概念和實作上的混淆是常見的。

#### 堆疊溢位與堆積溢位

這兩個術語雖然都包含「溢位」，但指向的是記憶體中不同區域的問題。

*   **堆疊溢位 (Stack Overflow)：**
    *   通常指**程式的函式呼叫堆疊 (Call Stack)** 空間耗盡。
    *   常見原因：
        1.  **無限遞迴：** 函式不斷呼叫自身而沒有終止條件，導致呼叫堆疊無限增長。
        2.  **深度過大的遞迴：** 即使有終止條件，如果遞迴深度超過系統預設的堆疊大小限制，也會發生溢位。
        3.  **大型區域變數：** 在函式內部聲明過大的陣列或其他資料結構作為區域變數，它們將被分配在堆疊上，可能迅速耗盡堆疊空間。
    *   發生時通常會導致程式崩潰。

*   **堆積溢位 (Heap Overflow)：**
    *   指**動態分配的記憶體區域 (Heap)** 空間耗盡。
    *   常見原因：
        1.  **記憶體洩漏：** 程式持續分配記憶體但從不釋放，導致可用堆積空間越來越少。
        2.  **分配過大記憶體：** 程式嘗試分配的記憶體大小超過系統可用堆積空間。
    *   發生時通常會導致記憶體分配失敗，程式可能崩潰或行為異常。

*   **澄清：** 堆疊 (Stack) 是一個特定的資料結構概念，而「函式呼叫堆疊」是系統用於管理函式呼叫的記憶體區域。兩者都遵循 LIFO 原則。堆積 (Heap) 則是另一個用於動態記憶體分配的記憶體區域，它與我們討論的「堆疊」資料結構完全不同。

#### 陣列實作循環佇列的「滿」與「空」判斷

使用固定大小的陣列實作循環佇列時，判斷佇列是「滿」還是「空」是一個常見的陷阱。

*   **問題：** 當 `front` 指針和 `rear` 指針都指向同一個位置時，佇列可能為空 (剛初始化) 也可能為滿 (所有元素都已被插入並環繞)。
    *   例如，假設佇列大小為 `N`。
        *   空：`front == rear`
        *   滿：`(rear + 1) % N == front` (如果 `front` 指向第一個元素，`rear` 指向最後一個元素)。
*   **解決方案：**
    1.  **犧牲一個單元：** 讓佇列最多只能儲存 `N-1` 個元素。當 `(rear + 1) % N == front` 時，判斷為滿。空時 `front == rear`。這樣 `front` 和 `rear` 之間總是至少有一個空閒單元。
    2.  **使用計數器：** 引入一個 `count` 變數來追蹤佇列中的元素數量。
        *   空：`count == 0`
        *   滿：`count == N` (或 `N-1`，取決於實作)
    3.  **使用布林旗標：** 引入 `isEmpty` 和 `isFull` 兩個布林變數來標記狀態。每當 `enqueue` 或 `dequeue` 後，更新這些旗標。

*   **澄清：** 無論採用哪種方法，關鍵是要確保「空」和「滿」的條件不會混淆。犧牲一個單元是最常見和簡潔的解決方案，但會損失一些儲存空間。

-----

### 小練習 (附詳解)

#### 練習一：有效的括號

**題目：**
給定一個只包含 `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` 的字串，判斷輸入字串是否有效。
有效字串需滿足：
1.  左括號必須用相同類型的右括號閉合。
2.  左括號必須以正確的順序閉合。
3.  每個右括號都有一個對應的相同類型的左括號。

**範例：**
*   輸入: `"()"`
    輸出: `true`
*   輸入: `"()[]{}"`
    輸出: `true`
*   輸入: `"(]"`
    輸出: `false`
*   輸入: `"([)]"`
    輸出: `false`
*   輸入: `"{[]}"`
    輸出: `true`

**思路：**
這是一個典型的堆疊應用問題。當我們遇到左括號時，將其壓入堆疊；遇到右括號時，檢查堆疊頂部是否有匹配的左括號。

**步驟：**
1.  建立一個空堆疊。
2.  遍歷給定字串中的每個字元 `c`。
3.  如果 `c` 是左括號 (`(`, `{`, `[` )，將其壓入堆疊。
4.  如果 `c` 是右括號 (`)`, `}`, `]` )：
    a.  首先檢查堆疊是否為空。如果堆疊為空，表示沒有匹配的左括號，則字串無效，回傳 `false`。
    b.  如果堆疊不為空，彈出堆疊頂部元素 `topChar`。
    c.  檢查 `c` 與 `topChar` 是否匹配。
        *   如果 `c` 是 `)` 且 `topChar` 不是 `(`, 回傳 `false`。
        *   如果 `c` 是 `}` 且 `topChar` 不是 `{`, 回傳 `false`。
        *   如果 `c` 是 `]` 且 `topChar` 不是 `[`, 回傳 `false`。
5.  遍歷完所有字元後，檢查堆疊是否為空。如果堆疊為空，表示所有左括號都找到了匹配的右括號，則字串有效，回傳 `true`。如果堆疊不為空，表示有未閉合的左括號，則字串無效，回傳 `false`。

**詳解 (以 Python 偽碼為例)：**

```python
def isValid(s: str) -> bool:
    stack = [] # 使用列表模擬堆疊
    mapping = {")": "(", "}": "{", "]": "["} # 定義括號的匹配關係

    for char in s:
        if char in mapping: # 如果是右括號
            top_element = stack.pop() if stack else '#' # 彈出棧頂元素，如果棧空則用特殊值
            if mapping[char] != top_element: # 檢查是否匹配
                return False
        else: # 如果是左括號
            stack.append(char) # 壓入堆疊

    return not stack # 最後檢查堆疊是否為空
```

#### 練習二：使用兩個堆疊實作佇列

**題目：**
請你實現一個 `MyQueue` 類別，使用兩個堆疊來實現佇列的所有功能 (`enqueue`, `dequeue`, `front`, `isEmpty`)。

**提示：**
兩個堆疊：`stack1` 用於入佇列操作，`stack2` 用於出佇列操作。

**步驟：**

1.  **類別定義：** 定義 `MyQueue` 類，包含 `stack1` 和 `stack2` 兩個成員變數（皆為堆疊）。

2.  **`enqueue(x)` 操作：**
    *   將元素 `x` 直接 `push` 到 `stack1`。

3.  **`dequeue()` 操作：**
    *   首先檢查 `stack2` 是否為空。
    *   如果 `stack2` 為空：
        *   將 `stack1` 中所有元素逐一 `pop` 出，並 `push` 到 `stack2`。
        *   這樣做的目的是將 `stack1` 中最早進入的元素移動到 `stack2` 的頂部。
    *   從 `stack2` `pop` 出頂部元素並回傳。
    *   如果兩個堆疊都為空，表示佇列為空，應拋出錯誤或回傳特殊值。

4.  **`front()` 操作：**
    *   與 `dequeue()` 類似，但只回傳元素而不移除。
    *   首先檢查 `stack2` 是否為空。
    *   如果 `stack2` 為空：
        *   將 `stack1` 中所有元素逐一 `pop` 出，並 `push` 到 `stack2`。
    *   回傳 `stack2` 的 `peek()` 頂部元素。
    *   如果兩個堆疊都為空，表示佇列為空，應拋出錯誤或回傳特殊值。

5.  **`isEmpty()` 操作：**
    *   當且僅當 `stack1` 和 `stack2` 都為空時，佇列才為空。
    *   回傳 `(stack1.isEmpty() and stack2.isEmpty())`。

**詳解 (以 Python 偽碼為例)：**

```python
class MyQueue:
    def __init__(self):
        self.stack1 = [] # 用於入佇列
        self.stack2 = [] # 用於出佇列

    def push(self, x: int) -> None:
        """將元素 x 推入佇列尾部。"""
        self.stack1.append(x)

    def pop(self) -> int:
        """從佇列頭部移除元素並回傳。"""
        self._transfer_if_empty() # 確保 stack2 有元素
        if not self.stack2:
            raise IndexError("Queue is empty")
        return self.stack2.pop()

    def peek(self) -> int:
        """回傳佇列頭部的元素，但不移除。"""
        self._transfer_if_empty() # 確保 stack2 有元素
        if not self.stack2:
            raise IndexError("Queue is empty")
        return self.stack2[-1] # Python 列表中 -1 表示最後一個元素 (棧頂)

    def empty(self) -> bool:
        """檢查佇列是否為空。"""
        return not self.stack1 and not self.stack2

    def _transfer_if_empty(self):
        """輔助方法：如果 stack2 為空，則將 stack1 所有元素轉移到 stack2。"""
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())

# 使用範例：
# myQueue = MyQueue()
# myQueue.push(1) # queue is: [1]
# myQueue.push(2) # queue is: [1, 2] (leftmost is front)
# myQueue.peek()  # return 1
# myQueue.pop()   # return 1, queue is [2]
# myQueue.empty() # return False
```

-----

### 延伸閱讀/參考

*   **資料結構與演算法經典書籍：**
    *   《演算法導論》(Introduction to Algorithms) - Thomas H. Cormen et al.
    *   《資料結構與演算法分析 (C/Java 版)》(Data Structures and Algorithm Analysis in C/Java) - Mark Allen Weiss
    *   《大話資料結構》- 程傑
*   **線上學習平台：**
    *   LeetCode: 提供了大量關於堆疊和佇列的練習題目。
    *   Hackerrank: 類似於 LeetCode，也有許多相關練習。
    *   GeeksforGeeks: 提供了豐富的資料結構和演算法教程及範例。
*   **抽象資料型別 (ADT)：** 進一步了解 ADT 的概念，以及它在軟體設計中的重要性。
*   **遞迴 (Recursion)：** 深入理解遞迴的工作原理，以及它與函式呼叫堆疊的關係。