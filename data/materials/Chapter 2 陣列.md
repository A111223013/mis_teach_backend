# Chapter 2 陣列

陣列（Array）是程式設計中最基本也最重要的一種資料結構。它允許我們以單一名稱儲存多個相同類型的資料項目，並透過索引值快速存取這些項目。理解陣列的概念、操作方式及其限制，是學習更複雜資料結構與演算法的基石。

-----

### 2.1 核心概念與定義

#### 2.1.1 什麼是陣列？

**定義：** 陣列是一種將多個**相同資料型態**的資料項目，以**連續記憶體空間**儲存的集合。每個資料項目稱為一個**元素（Element）**，並可透過一個稱為**索引（Index）**的整數值來唯一識別和存取。

**核心觀念：**
*   **同質性（Homogeneity）：** 陣列中的所有元素必須是相同的資料型態（例如，所有都是整數、所有都是浮點數或所有都是字串）。
*   **連續性（Contiguity）：** 陣列的元素在記憶體中是緊密排列的，這使得透過索引存取元素非常高效。
*   **固定大小（Fixed Size）：** 許多程式語言（如C/C++、Java的原始陣列）在宣告陣列後，其大小就固定了，無法在執行時改變。
*   **索引存取（Indexed Access）：** 陣列元素是透過其在陣列中的位置（索引）來存取的，索引通常從 0 開始。

#### 2.1.2 陣列的宣告與初始化

在不同的程式語言中，陣列的宣告和初始化語法會有所不同，但其核心概念是一致的。

**典型語法範例（概念性）：**

*   **宣告一維陣列：**
    ```
    // C/C++
    dataType arrayName[size]; // 宣告一個包含 'size' 個 'dataType' 元素的陣列
    int scores[5];           // 宣告一個包含 5 個整數的陣列

    // Java
    dataType[] arrayName = new dataType[size];
    int[] scores = new int[5];

    // Python (使用列表 List，但概念上類似)
    arrayName = [None] * size
    scores = [0] * 5
    ```

*   **初始化一維陣列：**
    ```
    // C/C++
    int scores[] = {85, 92, 78, 95, 88}; // 宣告並初始化，大小會自動推斷為 5

    // Java
    int[] scores = {85, 92, 78, 95, 88};

    // Python (列表 List)
    scores = [85, 92, 78, 95, 88]
    ```

*   **存取陣列元素：**
    ```
    // 取得第一個元素（索引為 0）
    firstElement = scores[0];

    // 修改第三個元素（索引為 2）
    scores[2] = 80;
    ```

#### 2.1.3 多維陣列（以二維陣列為例）

除了儲存單行資料的一維陣列外，我們也可以使用多維陣列來儲存表格或矩陣形式的資料。最常見的是二維陣列。

**概念：** 二維陣列可以想像成一個表格，由**行（Rows）**和**列（Columns）**組成。每個元素透過兩個索引來存取：第一個索引表示行，第二個索引表示列。

**典型語法範例（概念性）：**

*   **宣告二維陣列：**
    ```
    // C/C++
    dataType arrayName[rows][cols];
    int matrix[3][4]; // 3 行 4 列的整數矩陣

    // Java
    dataType[][] arrayName = new dataType[rows][cols];
    int[][] matrix = new int[3][4];

    // Python (列表的列表)
    matrix = [[0 for _ in range(cols)] for _ in range(rows)]
    matrix = [[0 for _ in range(4)] for _ in range(3)]
    ```

*   **初始化二維陣列：**
    ```
    // C/C++ 或 Java
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };

    // Python (列表的列表)
    matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    ```

*   **存取二維陣列元素：**
    ```
    // 取得位於第 1 行、第 2 列的元素（索引為 [0][1]）
    element = matrix[0][1]; // 結果為 2

    // 修改位於第 2 行、第 3 列的元素（索引為 [1][2]）
    matrix[1][2] = 77;
    ```

-----

### 2.2 典型例子與記憶體位址推導

#### 2.2.1 陣列遍歷與操作

遍歷（Traversal）是指依序存取陣列中的每一個元素，這是陣列最基本的操作之一。

**一維陣列遍歷範例：**
計算一個整數陣列的總和。

```cpp
// 假設陣列為 int arr[] = {10, 20, 30, 40, 50};
int sum = 0;
for (int i = 0; i < 5; i++) { // 索引從 0 到 4
    sum += arr[i];
}
// sum 的結果是 150
```

**二維陣列遍歷範例：**
列印一個 $3 \times 4$ 的整數矩陣。

```cpp
// 假設矩陣為 int matrix[3][4]
// matrix = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }
for (int i = 0; i < 3; i++) { // 遍歷行 (row)
    for (int j = 0; j < 4; j++) { // 遍歷列 (column)
        printf("%d ", matrix[i][j]);
    }
    printf("\n"); // 每列結束後換行
}
/* 輸出：
1 2 3 4
5 6 7 8
9 10 11 12
*/
```

#### 2.2.2 記憶體位址計算 (Memory Address Calculation)

陣列之所以能高效地透過索引存取元素，正是因為其元素在記憶體中是連續儲存的。我們可以根據基底位址、索引和元素大小來計算任意元素的記憶體位址。

*   **符號說明：**
    *   `BaseAddress`：陣列第一個元素（索引為 0）的記憶體位址。
    *   `ElementSize`：每個元素所佔用的記憶體大小（位元組）。
    *   `i`：欲存取元素的索引。
    *   `NumCols`：二維陣列的列數。

*   **一維陣列元素的記憶體位址：**
    當我們要存取陣列 `A` 中索引為 `i` 的元素 `A[i]` 時，其記憶體位址為：
    $$ \text{Address}(A[i]) = \text{BaseAddress} + i \times \text{ElementSize} $$

    **例子：**
    假設 `int arr[5]` 的 `BaseAddress` 是 `0x1000`，且 `sizeof(int)` 是 4 bytes。
    *   `Address(arr[0]) = 0x1000 + 0 * 4 = 0x1000`
    *   `Address(arr[1]) = 0x1000 + 1 * 4 = 0x1004`
    *   `Address(arr[4]) = 0x1000 + 4 * 4 = 0x1010`

*   **二維陣列元素的記憶體位址 (行優先 Row-Major Order)：**
    在大多數程式語言中，二維陣列是採用「行優先（Row-Major Order）」的方式儲存，即先存完第一行的所有元素，再存第二行的所有元素，依此類推。
    當我們要存取陣列 `A` 中索引為 `[i][j]` 的元素 `A[i][j]` 時，其記憶體位址為：
    $$ \text{Address}(A[i][j]) = \text{BaseAddress} + (i \times \text{NumCols} + j) \times \text{ElementSize} $$

    **例子：**
    假設 `int matrix[3][4]` 的 `BaseAddress` 是 `0x2000`，`NumCols` 是 4，`sizeof(int)` 是 4 bytes。
    *   `Address(matrix[0][0]) = 0x2000 + (0 * 4 + 0) * 4 = 0x2000`
    *   `Address(matrix[0][1]) = 0x2000 + (0 * 4 + 1) * 4 = 0x2004`
    *   `Address(matrix[1][0]) = 0x2000 + (1 * 4 + 0) * 4 = 0x2010` (第一行 4 個元素佔據了 `4 * 4 = 16` bytes)
    *   `Address(matrix[2][3]) = 0x2000 + (2 * 4 + 3) * 4 = 0x2000 + (8 + 3) * 4 = 0x2000 + 11 * 4 = 0x2000 + 44 = 0x202C`

-----

### 2.3 與相鄰概念的關聯

#### 2.3.1 陣列與變數 (Variables)

*   **單一變數：** 儲存單一資料值，例如 `int age = 30;`。
*   **陣列：** 儲存多個相同類型的資料值，並以單一名稱代表，例如 `int ages[5] = {28, 30, 25, 32, 29};`。陣列本質上是相同類型變數的集合，方便批次處理。

#### 2.3.2 陣列與指標 (Pointers)

在 C/C++ 等語言中，陣列與指標的關係非常密切：
*   **陣列名即指標：** 陣列名（沒有使用索引時）在表達式中通常會被解釋為指向其第一個元素的常數指標。例如，`arr` 等同於 `&arr[0]`。
*   **指標算術：** 透過指標算術（`ptr + i`），可以像陣列索引一樣存取元素。例如，`*(arr + i)` 等同於 `arr[i]`。
*   **記憶體位址：** 兩者都涉及到直接操作記憶體位址。指標提供了更靈活的記憶體操作能力，而陣列提供了一種結構化的方式來管理連續記憶體區塊。

#### 2.3.3 陣列與動態陣列/串列 (Dynamic Arrays/Lists)

*   **陣列（靜態陣列）：** 大小在編譯時或宣告時就固定了，無法在程式執行過程中改變。如果需要增加或減少元素，通常需要建立一個新的陣列並將舊陣列的內容複製過去。
*   **動態陣列/串列：** 許多高階語言（如 Python 的 List、Java 的 `ArrayList`）提供了動態大小的陣列或串列。這些結構在底層通常也是使用陣列實現的，但它們會自動處理記憶體重新分配和複製的工作，使得開發者不必擔心固定大小的限制。當容量不足時，它們會自動擴容（通常是增加一倍），這雖然方便，但也可能導致效能上的開銷。

#### 2.3.4 陣列與結構 (Structs/Objects)

*   **陣列：** 用於儲存**相同類型**的資料集合。
*   **結構/物件：** 用於儲存**不同類型**但邏輯上相關的資料集合，將它們綑綁成一個單元。例如，一個 `Student` 結構可能包含 `name` (字串)、`age` (整數) 和 `gpa` (浮點數)。我們可以建立一個 `Student` 結構的陣列來儲存多個學生資訊。

-----

### 2.4 進階內容：陣列作為函數參數傳遞

當陣列作為函數的參數傳遞時，通常是以**傳址（pass-by-reference）**的方式進行，而不是傳值（pass-by-value）。這意味著函數接收到的是陣列的起始記憶體位址（指標），而不是陣列本身的完整副本。因此，在函數內部對陣列元素所做的任何修改，都會直接影響到原始陣列。

**範例（C/C++ 概念）：**

```cpp
void modifyArray(int arr[], int size) {
    // 這裡的 arr 實際上是指向原始陣列的第一個元素的指標
    arr[0] = 99; // 會修改到原始陣列的第一個元素
}

int main() {
    int myArray[] = {1, 2, 3};
    modifyArray(myArray, 3);
    // 此時 myArray[0] 的值已經變為 99
    return 0;
}
```
**注意：** 在C/C++中，當你將一維陣列傳遞給函數時，函數無法直接得知陣列的「大小」。因此，通常需要額外傳遞一個表示陣列大小的整數參數。對於多維陣列，除了最左邊的維度外，其他維度的大小通常也需要指定。

-----

### 2.5 常見錯誤與澄清

1.  **陣列越界（Out-of-bounds Access）：**
    *   **錯誤：** 存取超出陣列定義範圍的索引。例如，一個大小為 5 的陣列，其有效索引為 0 到 4。如果嘗試存取 `arr[5]` 或 `arr[-1]`，就會發生越界錯誤。這可能導致程式崩潰、產生不預期的結果，甚至成為安全漏洞。
    *   **澄清：** 務必確保所有陣列存取都在其有效索引範圍內。在迴圈中遍歷陣列時，要特別注意迴圈的起始、終止條件以及索引的增減。

2.  **索引從0開始的混淆：**
    *   **錯誤：** 認為陣列的第一個元素是 `arr[1]`，或陣列大小為 `N` 時，有效索引是 `1` 到 `N`。
    *   **澄清：** 在大多數程式語言中，陣列的索引是從 `0` 開始的。因此，一個大小為 `N` 的陣列，其有效索引範圍是 `0` 到 `N-1`。

3.  **陣列大小的誤解（對於靜態陣列）：**
    *   **錯誤：** 宣告 `int arr[5];` 後，嘗試動態改變其大小，例如再添加一個元素。
    *   **澄清：** 靜態陣列一旦宣告，其大小在記憶體中就固定了。如果需要可變大小的集合，應考慮使用動態陣列（如 C++ 的 `std::vector`、Java 的 `ArrayList`、Python 的 List）。

4.  **二維陣列的遍歷順序：**
    *   **錯誤：** 混淆了行索引和列索引的順序，或者在使用巢狀迴圈時，將內外迴圈的控制變數搞錯。
    *   **澄清：** `matrix[row][col]` 始終是 `[行索引][列索引]`。通常外層迴圈控制行，內層迴圈控制列，這樣才能實現行優先的遍歷。

-----

### 2.6 小練習（附詳解）

#### 小練習一：計算陣列中奇數元素的數量

**題目：**
給定一個整數陣列 `numbers = {12, 5, 23, 8, 17, 30, 11}`，請撰寫一個程式片段，計算並輸出陣列中所有奇數元素的數量。

**詳解：**

1.  **定義陣列與變數：** 首先宣告給定的整數陣列，並初始化一個計數器變數 `oddCount` 為 0，用於儲存奇數的數量。
2.  **遍歷陣列：** 使用 `for` 迴圈遍歷陣列中的每一個元素。迴圈的範圍應從索引 0 到陣列的最後一個元素。
3.  **判斷奇偶性：** 在迴圈內部，使用模運算符 (`%`) 判斷當前元素是否為奇數。如果 `元素 % 2 != 0`，則表示它是奇數。
4.  **增加計數：** 如果判斷為奇數，則將 `oddCount` 增加 1。
5.  **輸出結果：** 迴圈結束後，輸出 `oddCount` 的值。

```cpp
#include <stdio.h> // C 語言範例，用於輸入輸出

int main() {
    int numbers[] = {12, 5, 23, 8, 17, 30, 11};
    int size = sizeof(numbers) / sizeof(numbers[0]); // 計算陣列大小
    int oddCount = 0; // 初始化奇數計數器

    printf("陣列元素為：");
    for (int i = 0; i < size; i++) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    for (int i = 0; i < size; i++) {
        if (numbers[i] % 2 != 0) { // 如果元素除以2的餘數不為0，則是奇數
            oddCount++; // 奇數計數器加1
        }
    }

    printf("陣列中的奇數數量為：%d\n", oddCount); // 輸出結果

    return 0;
}
```

**輸出：**
```
陣列元素為：12 5 23 8 17 30 11
陣列中的奇數數量為：4
```
(奇數為 5, 23, 17, 11，共 4 個)

-----

#### 小練習二：在二維陣列中尋找特定值的位置

**題目：**
給定一個 $3 \times 3$ 的整數矩陣 `matrix` 和一個目標值 `target = 7`。請撰寫一個程式片段，尋找 `target` 值在矩陣中的所有位置（行索引和列索引）。如果找不到，則輸出「未找到」。

```
matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**詳解：**

1.  **定義矩陣與目標值：** 宣告給定的 $3 \times 3$ 整數矩陣 `matrix` 和目標值 `target`。
2.  **初始化旗標：** 宣告一個布林變數 `found` 並初始化為 `false`，用於標記是否找到目標值。
3.  **遍歷二維陣列：** 使用巢狀 `for` 迴圈遍歷矩陣中的每一個元素。外層迴圈控制行索引 `i`，內層迴圈控制列索引 `j`。
4.  **比較與輸出：** 在內層迴圈中，將 `matrix[i][j]` 與 `target` 進行比較。如果相等，則輸出其 `[i][j]` 的位置，並將 `found` 設為 `true`。
5.  **判斷結果：** 巢狀迴圈結束後，檢查 `found` 變數。如果仍為 `false`，則表示未找到目標值，輸出相應訊息。

```cpp
#include <stdio.h> // C 語言範例

int main() {
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    int target = 7;
    int rows = 3;
    int cols = 3;
    _Bool found = 0; // C99 的 _Bool，0為false, 1為true

    printf("尋找目標值 %d 在矩陣中的位置：\n", target);

    for (int i = 0; i < rows; i++) { // 遍歷行
        for (int j = 0; j < cols; j++) { // 遍歷列
            if (matrix[i][j] == target) {
                printf("在 matrix[%d][%d] 找到 %d。\n", i, j, target);
                found = 1; // 標記為已找到
            }
        }
    }

    if (!found) { // 如果 found 仍為 0 (false)
        printf("未在矩陣中找到目標值 %d。\n", target);
    }

    return 0;
}
```

**輸出：**
```
尋找目標值 7 在矩陣中的位置：
在 matrix[2][0] 找到 7。
```

-----

### 2.7 延伸閱讀/參考

*   **資料結構與演算法入門書籍：** 任何一本好的資料結構書籍都會在開篇詳細介紹陣列。
    *   例如：《資料結構與演算法：Java 篇》或 《C 語言資料結構與演算法》等。
*   **W3Schools - C Arrays:** [https://www.w3schools.com/c/c_arrays.php](https://www.w3schools.com/c/c_arrays.php)
*   **GeeksforGeeks - Arrays in C/C++/Java/Python:** 尋找關於特定語言陣列的文章，通常會包含詳細的語法和應用。
*   **Stack Overflow:** 搜尋關於「array out of bounds」或「array vs list」等常見問題，可以獲得更多實務上的理解和討論。