# 6-2 記憶管理 (Memory Management)

記憶管理是作業系統的核心功能之一，它負責有效率地分配電腦的記憶體資源給執行中的程式和系統本身，確保程式能順利執行，同時避免彼此干擾或資源衝突。本章將深入探討記憶管理的基本概念、常見技術及其運作原理。

-----

## ### 核心概念與定義

#### 什麼是記憶管理？

記憶管理是指作業系統為處理程序分配和回收主記憶體（RAM）的機制。其主要目標包括：
*   **多工支援**：允許多個程式同時載入並執行，提高系統資源利用率。
*   **資源共享**：允許不同處理程序共享記憶體中的資料或程式碼，減少重複載入，節省記憶體空間。
*   **記憶體保護**：確保每個處理程序只能存取被授權的記憶體區域，防止程式互相寫入，導致系統崩潰或資料損毀。
*   **位址空間抽象**：提供一個獨立的邏輯位址空間給每個程式，讓程式設計師無須關心實體記憶體的實際配置。

-----

#### 記憶體位址：邏輯位址與實體位址

在記憶體管理中，理解不同類型的位址是至關重要的：
*   **邏輯位址 (Logical Address)**：
    *   **定義**：由CPU產生，由程式在執行時所使用的位址。它是一個虛擬位址，處理程序認為自己擁有從0開始到最大值的完整記憶體空間。
    *   **例子**：程式碼中 `int *ptr = 0x1000;` 這裡的 `0x1000` 就是一個邏輯位址。
    *   **與相鄰概念的關聯**：邏輯位址是處理程序抽象化視角的起點，最終需要被轉換為實體位址才能真正存取記憶體。

*   **實體位址 (Physical Address)**：
    *   **定義**：記憶體位址暫存器 (Memory Address Register, MAR) 所接收到的位址，是主記憶體中實際存在的儲存單元位址。
    *   **例子**：如果CPU發出的邏輯位址 `0x1000` 經過轉換後，對應到實體記憶體中的 `0x8000` 位置，那麼 `0x8000` 就是實體位址。
    *   **與相鄰概念的關聯**：這是硬體實際存取記憶體的唯一位址。所有記憶體管理機制的核心任務之一就是實現從邏輯位址到實體位址的轉換。

-----

#### 位址繫結 (Address Binding)

位址繫結是將程式碼和資料的符號位址（如變數名、函數名）轉換為實體記憶體位址的過程。繫結發生的時機不同，對記憶體管理策略有重要影響：
*   **編譯時繫結 (Compile Time Binding)**：
    *   **定義**：程式在編譯階段就確定其所有記憶體位址。
    *   **應用**：如果處理程序在編譯時就知道它將被載入到記憶體的哪個固定位置，則可生成絕對碼。
    *   **限制**：一旦編譯，程式就無法移動；不適合多工環境。

*   **載入時繫結 (Load Time Binding)**：
    *   **定義**：如果處理程序在編譯時不知道它將被載入到記憶體的哪個位置（生成可重定位碼），則載入器在將程式載入記憶體時執行位址繫結。
    *   **應用**：處理程序可以載入到記憶體中的任何可用位置，但一旦載入，其位置就固定了。

*   **執行時繫結 (Execution Time Binding / Run Time Binding)**：
    *   **定義**：位址轉換在處理程序執行過程中進行，由硬體支援，通常是記憶體管理單元 (MMU - Memory Management Unit) 完成。
    *   **應用**：這是現代作業系統中最常用的方式。它允許處理程序在執行過程中移動，支援虛擬記憶體和分頁/分段等高級功能。
    *   **與相鄰概念的關聯**：執行時繫結是實現虛擬記憶體、動態重定位和記憶體保護的基礎。

-----

#### 記憶體保護 (Memory Protection)

為了確保多個處理程序能在記憶體中安全地共存，記憶體保護機制是不可或缺的。常見方法是使用硬體暫存器：
*   **基底暫存器 (Base Register)**：
    *   **定義**：儲存一個處理程序所能存取的最小實體記憶體位址。
    *   **例子**：如果基底暫存器值為 `0x10000`，則處理程序只能存取從 `0x10000` 開始的記憶體。

*   **限制暫存器 (Limit Register)**：
    *   **定義**：儲存一個處理程序的記憶體範圍大小（或最大實體記憶體位址）。
    *   **例子**：如果限制暫存器值為 `0x4000` (16KB)，則處理程序只能存取從基底暫存器開始的 16KB 記憶體。
    *   **推導**：每次CPU發出一個邏輯位址 `LA`，MMU會檢查：
        1.  `LA < 0` 或 `LA >= Limit_Register`？ (檢查是否超出程式自身範圍)
        2.  如果合法，則實體位址 `PA = Base_Register + LA`。
        3.  否則，產生一個記憶體存取錯誤 (Memory Access Error)。
    *   **與相鄰概念的關聯**：基底和限制暫存器機制是實現連續記憶體配置中記憶體保護的基石。在分頁和分段中，雖然機制不同，但保護的核心思想一致。

-----

## ### 典型例子與轉換：記憶體配置策略

記憶體配置主要分為連續配置和非連續配置兩大類。

#### 連續記憶體配置 (Contiguous Memory Allocation)

每個處理程序都被分配一個單一的連續記憶體區塊。

##### 單一分區配置 (Single-Partition Allocation)
*   **定義**：記憶體被分為兩個區域：一個給作業系統，另一個給正在執行的單一使用者處理程序。
*   **優點**：簡單。
*   **缺點**：只支援單工，無法利用多核CPU優勢。

##### 多重分區配置 (Multiple-Partition Allocation)
*   **定義**：記憶體被分割成多個區域，每個區域可以容納一個處理程序。
*   **類型**：
    *   **固定分區 (Fixed-Partition Allocation)**：
        *   **定義**：記憶體被預先劃分為大小固定的多個分區。
        *   **缺點**：
            *   **內部碎片 (Internal Fragmentation)**：如果處理程序分配到的分區比它實際需要的記憶體大，多餘的部分在分區內部閒置，無法被其他程式使用。
            *   處理程序大小受限於最大分區。
            *   同時執行程式數量受限於分區數量。

    *   **可變分區 (Variable-Partition Allocation)**：
        *   **定義**：不預先劃分分區。當處理程序需要記憶體時，作業系統會為其尋找一個足夠大的連續可用空間 (hole)，並將其分配給處理程序。
        *   **優點**：沒有內部碎片 (或碎片極小)。
        *   **缺點**：
            *   **外部碎片 (External Fragmentation)**：記憶體中散佈著許多小的、不連續的可用空間區塊。這些零散空間加起來可能足夠大，但因為不連續，無法滿足較大處理程序的記憶體需求。
            *   需要動態管理記憶體中的可用空間列表。

##### 配置策略 (Hole-Filling Strategies)
當使用可變分區配置時，作業系統需要決定從眾多可用空間中選擇哪一個來分配給新的處理程序。
*   **首次適配 (First Fit)**：
    *   **定義**：掃描可用空間列表，分配第一個足夠大的空間。
    *   **優點**：速度快。
    *   **缺點**：容易在記憶體前端產生許多小的可用空間，增加後續搜尋時間。

*   **最佳適配 (Best Fit)**：
    *   **定義**：掃描整個可用空間列表，分配最小的那個足夠大的空間。
    *   **優點**：盡可能地保留大空間給大型處理程序，減少內部碎片。
    *   **缺點**：速度慢（需掃描整個列表），容易產生許多極小的外部碎片。

*   **最差適配 (Worst Fit)**：
    *   **定義**：掃描整個可用空間列表，分配最大的那個空間。
    *   **優點**：將大空間分割後，剩餘的空間可能仍然足夠大，可以被其他處理程序使用。
    *   **缺點**：速度慢，會快速消耗最大的可用空間。

-----

#### 非連續記憶體配置 (Non-Contiguous Memory Allocation)

將處理程序的邏輯位址空間分割成多個區塊，這些區塊可以載入到實體記憶體中不連續的位置。這有效地解決了外部碎片問題。

##### 分頁 (Paging)
分頁是目前最廣泛使用的記憶體管理技術，是虛擬記憶體的基礎。
*   **核心概念**：
    *   **頁 (Page)**：處理程序的邏輯位址空間被劃分為固定大小的區塊。
    *   **頁框 (Frame)**：實體記憶體被劃分為與頁相同大小的區塊。
    *   **頁表 (Page Table)**：每個處理程序都有一個頁表，它記錄了處理程序每一頁對應到實體記憶體的哪個頁框。頁表通常儲存在主記憶體中，其基底位址儲存在CPU的頁表基底暫存器 (Page Table Base Register, PTBR) 中。

*   **邏輯位址到實體位址的轉換**：
    邏輯位址 `LA` 被分為兩部分：
    *   **頁號 (Page Number, p)**：指示是處理程序的哪一頁。
    *   **頁偏移量 (Page Offset, d)**：指示該頁內部的位置。

    假設頁大小為 $2^x$ 位元組。
    則邏輯位址的低 $x$ 位是頁偏移量 `d`，其餘高位是頁號 `p`。

    轉換步驟：
    1.  CPU產生邏輯位址 `(p, d)`。
    2.  作業系統使用頁號 `p` 作為索引，查詢該處理程序的頁表。
    3.  從頁表中找到對應的頁框號 `f`。
    4.  實體位址 `PA = f * Page_Size + d`。 (或將 `f` 替換掉 `p`，與 `d` 組合)

    *   **例子**：
        假設一個系統的邏輯位址是 32 位元，頁大小是 4KB ($2^{12}$ 位元組)。
        則頁偏移量 `d` 佔 12 位元，頁號 `p` 佔 32 - 12 = 20 位元。
        若邏輯位址為 `0x12345678`：
        *   頁偏移量 `d` = `0x678` (後 12 位元)
        *   頁號 `p` = `0x12345` (前 20 位元)
        假設頁表查詢結果顯示頁號 `0x12345` 對應的頁框號 `f` 是 `0xABCDE`。
        則實體位址 `PA = 0xABCDE000 + 0x678 = 0xABCDE678`。

    *   **與相鄰概念的關聯**：分頁機制是實現虛擬記憶體的關鍵。它允許將處理程序的部分載入記憶體，部分保留在磁碟上，並在需要時進行交換。

*   **轉譯旁路緩衝區 (TLB - Translation Lookaside Buffer)**：
    *   **定義**：為了加速頁表查詢（因為每次記憶體存取都可能需要兩次主記憶體存取：一次查頁表，一次取資料），MMU內部通常設有一個高速緩衝區，專門儲存最近使用的頁號和頁框號對應關係。
    *   **運作**：當CPU產生邏輯位址時，MMU首先在TLB中查找頁號。如果命中 (TLB Hit)，則直接從TLB中獲取頁框號；如果未命中 (TLB Miss)，則到主記憶體的頁表中查詢，並將結果存入TLB以備後用。
    *   **與相鄰概念的關聯**：TLB是分頁效能優化的重要一環，與CPU的快取機制類似，都是利用時間和空間局部性原理。

*   **記憶體保護與共享 (Paging Protection and Sharing)**：
    *   **保護**：頁表中的每個條目通常包含保護位 (Protection Bits)，例如讀/寫/執行權限。MMU在進行位址轉換時會檢查這些保護位，如果存取權限不符則會產生保護錯誤。
    *   **共享**：多個處理程序的頁表可以指向同一個頁框，實現程式碼或資料的共享（例如共享函式庫）。

##### 分段 (Segmentation)
分段是另一種非連續記憶體配置方式，它以程式的邏輯結構為單位進行劃分。
*   **核心概念**：
    *   **段 (Segment)**：處理程序的邏輯位址空間被劃分為可變大小的段，每個段代表程式的獨立邏輯單元（例如程式碼段、資料段、堆疊段、函式）。
    *   **段表 (Segment Table)**：每個處理程序都有一個段表，記錄了每個段的基底位址 (Base Address) 和長度 (Limit)。段表基底暫存器 (Segment Table Base Register, STBR) 指向段表。

*   **邏輯位址到實體位址的轉換**：
    邏輯位址 `LA` 被分為兩部分：
    *   **段號 (Segment Number, s)**：指示是處理程序的哪一段。
    *   **段偏移量 (Offset, d)**：指示該段內部的位置。

    轉換步驟：
    1.  CPU產生邏輯位址 `(s, d)`。
    2.  作業系統使用段號 `s` 作為索引，查詢該處理程序的段表。
    3.  從段表中獲取段的基底位址 `base` 和長度 `limit`。
    4.  檢查 `d >= limit`？如果為真，表示段內存取越界，產生保護錯誤。
    5.  如果合法，則實體位址 `PA = base + d`。

    *   **與分頁的比較**：
        | 特性     | 分頁 (Paging)                        | 分段 (Segmentation)                         |
        | :------- | :----------------------------------- | :------------------------------------------ |
        | 劃分單位 | 固定大小的頁 (Page)                  | 可變大小的段 (Segment)                      |
        | 邏輯視角 | 單一、一維的位址空間                 | 多個、獨立的、二維的位址空間（程式碼、資料等） |
        | 外部碎片 | 無 (或極小，如果頁大小合理)          | 有 (因段大小可變，容易產生外部碎片)         |
        | 內部碎片 | 有 (通常小於一頁大小)                | 無 (理論上，因為按需分配)                   |
        | 硬體複雜度 | 較高（頁表管理，TLB）                | 較低（段表管理）                            |
        | 程式設計師 | 幾乎透明，無須關心記憶體劃分         | 需意識到段的存在，便於模組化              |
        | 主要用途 | 解決外部碎片，實現虛擬記憶體         | 支援程式的邏輯結構，提供更好的保護與共享    |

-----

## ### 與相鄰概念的關聯

#### 虛擬記憶體 (Virtual Memory)

*   **關聯**：分頁和分段是實現虛擬記憶體的底層機制。虛擬記憶體通過利用磁碟空間作為主記憶體的延伸，允許處理程序使用比實際物理記憶體更大的位址空間。
*   **如何運作**：當一個處理程序嘗試存取一個不在主記憶體中的頁面（或段）時，會發生「頁面錯誤」(Page Fault)。作業系統會從磁碟中將所需的頁面載入到主記憶體中的一個空閒頁框中，並更新頁表。
*   **重要性**：虛擬記憶體是現代作業系統的基石，它提高了記憶體利用率、允許執行大型程式、簡化了程式設計，並增強了系統的保護和隔離能力。

#### 處理器排程 (CPU Scheduling)

*   **關聯**：記憶體管理與處理器排程間接相關。如果作業系統無法為一個處理程序分配足夠的記憶體，該處理程序就無法載入執行，從而影響處理器排程器可選擇的程序集合。
*   **抖動 (Thrashing)**：在虛擬記憶體系統中，如果處理程序總的工作集 (working set) 大小超過了可用的實體記憶體，系統可能會花費大部分時間在頁面交換上，而不是執行程式，這種現象稱為抖動。抖動會嚴重降低CPU利用率，排程器在這種情況下將無效。

-----

## ### 常見錯誤與澄清

#### 1. 內部碎片與外部碎片的混淆

*   **錯誤**：認為所有碎片都是外部碎片。
*   **澄清**：
    *   **內部碎片**：發生在**已分配的記憶體區塊內部**。當分配給處理程序的記憶體區塊大於它實際需要的記憶體量時，多餘的部分即使是閒置的，也無法被其他處理程序使用。常見於固定分區配置和分頁 (一個頁框最後一點空間可能沒用完)。
    *   **外部碎片**：發生在**未分配的記憶體區塊之間**。當總的可用記憶體足夠，但由於這些可用空間不連續，無法滿足一個較大的連續記憶體需求時，便產生外部碎片。常見於可變分區配置和分段。
*   **比喻**：
    *   內部碎片：你租了一間大房子，但只用了其中一小部分，剩下的房間空著，但你仍要付整間房子的租金。
    *   外部碎片：你的錢包裡總共有足夠的錢買一台新手機，但這些錢分散在許多零錢包中，每個零錢包的錢都不足以買手機，你無法湊齊。

#### 2. 分頁與分段的根本區別

*   **錯誤**：將分頁和分段視為可互換的記憶體管理技術。
*   **澄清**：
    *   **分頁**：目的是解決**外部碎片**問題，將邏輯位址空間和實體記憶體都劃分為**固定大小**的區塊（頁和頁框），對程式設計師**透明**。它專注於記憶體資源的物理管理。
    *   **分段**：目的是支援程式的**邏輯結構**，將程式劃分為**可變大小**的段（如程式碼、資料），對程式設計師**可見**。它更關注程式設計師的視角和程式的模組化。
    *   **位址結構**：分頁的邏輯位址是 `(頁號, 偏移量)`，分段的邏輯位址是 `(段號, 偏移量)`。

-----

## ### 小練習 (附詳解)

#### 小練習 1：連續記憶體配置策略

**題目**：
假設主記憶體有以下可用空間（依位址順序排列）：10KB, 4KB, 20KB, 18KB, 7KB, 9KB, 12KB, 15KB。
現在有三個處理程序 P1 (12KB), P2 (10KB), P3 (9KB) 依序請求記憶體。
請分別使用 **首次適配 (First Fit)**、**最佳適配 (Best Fit)** 和 **最差適配 (Worst Fit)** 策略，說明每個處理程序被分配到哪個可用空間，並指出剩餘的可用空間列表。

**詳解**：

**1. 初始可用空間列表 (KB)**：`[10, 4, 20, 18, 7, 9, 12, 15]`

---

**1.1 首次適配 (First Fit)**

*   **P1 (12KB)**：
    *   掃描：10KB (太小), 4KB (太小), **20KB (足夠)**
    *   分配：P1 獲得 20KB 空間。
    *   剩餘：20KB - 12KB = 8KB。
    *   可用空間列表：`[10, 4, 8, 18, 7, 9, 12, 15]` (20KB 被 8KB 取代)

*   **P2 (10KB)**：
    *   掃描：10KB (足夠)
    *   分配：P2 獲得 10KB 空間。
    *   剩餘：10KB - 10KB = 0KB。
    *   可用空間列表：`[0, 4, 8, 18, 7, 9, 12, 15]` (10KB 被 0KB 取代，即該空間被完全佔用)

*   **P3 (9KB)**：
    *   掃描：0KB (太小), 4KB (太小), 8KB (太小), **18KB (足夠)**
    *   分配：P3 獲得 18KB 空間。
    *   剩餘：18KB - 9KB = 9KB。
    *   可用空間列表：`[0, 4, 8, 9, 7, 9, 12, 15]` (18KB 被 9KB 取代)

**結果 (First Fit)**：
*   P1 獲取 20KB (剩餘 8KB)
*   P2 獲取 10KB (剩餘 0KB)
*   P3 獲取 18KB (剩餘 9KB)
*   最終可用空間列表：`[0, 4, 8, 9, 7, 9, 12, 15]`

---

**1.2 最佳適配 (Best Fit)**

*   **P1 (12KB)**：
    *   掃描所有足夠大的空間：20KB, 18KB, 12KB, 15KB。
    *   最小的足夠空間是 **12KB**。
    *   分配：P1 獲得 12KB 空間。
    *   剩餘：12KB - 12KB = 0KB。
    *   可用空間列表：`[10, 4, 20, 18, 7, 9, 0, 15]` (12KB 被 0KB 取代)

*   **P2 (10KB)**：
    *   掃描所有足夠大的空間：10KB, 20KB, 18KB, 15KB。
    *   最小的足夠空間是 **10KB**。
    *   分配：P2 獲得 10KB 空間。
    *   剩餘：10KB - 10KB = 0KB。
    *   可用空間列表：`[0, 4, 20, 18, 7, 9, 0, 15]` (10KB 被 0KB 取代)

*   **P3 (9KB)**：
    *   掃描所有足夠大的空間：20KB, 18KB, 9KB, 15KB。
    *   最小的足夠空間是 **9KB**。
    *   分配：P3 獲得 9KB 空間。
    *   剩餘：9KB - 9KB = 0KB。
    *   可用空間列表：`[0, 4, 20, 18, 7, 0, 0, 15]` (9KB 被 0KB 取代)

**結果 (Best Fit)**：
*   P1 獲取 12KB (剩餘 0KB)
*   P2 獲取 10KB (剩餘 0KB)
*   P3 獲取 9KB (剩餘 0KB)
*   最終可用空間列表：`[0, 4, 20, 18, 7, 0, 0, 15]`

---

**1.3 最差適配 (Worst Fit)**

*   **P1 (12KB)**：
    *   掃描所有足夠大的空間，找到最大的：**20KB**。
    *   分配：P1 獲得 20KB 空間。
    *   剩餘：20KB - 12KB = 8KB。
    *   可用空間列表：`[10, 4, 8, 18, 7, 9, 12, 15]` (20KB 被 8KB 取代)

*   **P2 (10KB)**：
    *   掃描所有足夠大的空間，找到最大的：18KB。
    *   分配：P2 獲得 18KB 空間。
    *   剩餘：18KB - 10KB = 8KB。
    *   可用空間列表：`[10, 4, 8, 8, 7, 9, 12, 15]` (18KB 被 8KB 取代)

*   **P3 (9KB)**：
    *   掃描所有足夠大的空間，找到最大的：15KB。
    *   分配：P3 獲得 15KB 空間。
    *   剩餘：15KB - 9KB = 6KB。
    *   可用空間列表：`[10, 4, 8, 8, 7, 9, 12, 6]` (15KB 被 6KB 取代)

**結果 (Worst Fit)**：
*   P1 獲取 20KB (剩餘 8KB)
*   P2 獲取 18KB (剩餘 8KB)
*   P3 獲取 15KB (剩餘 6KB)
*   最終可用空間列表：`[10, 4, 8, 8, 7, 9, 12, 6]`

---

#### 小練習 2：分頁位址轉換

**題目**：
假設一個系統使用分頁記憶體管理。
*   邏輯位址空間大小：$2^{16}$ 位元組
*   實體記憶體大小：$2^{14}$ 位元組
*   頁面大小 (Page Size)：512 位元組

請回答以下問題：
1.  邏輯位址的位元數是多少？頁偏移量佔多少位元？頁號佔多少位元？
2.  實體位址的位元數是多少？頁框數 (Frame Count) 是多少？
3.  如果一個處理程序的頁表中有一個條目顯示邏輯頁號 5 對應的實體頁框號是 10。現在處理程序要存取邏輯位址 `0x153A`，請計算對應的實體位址。

**詳解**：

**1. 邏輯位址的位元數、頁偏移量與頁號**

*   **邏輯位址的位元數**：
    邏輯位址空間大小是 $2^{16}$ 位元組，因此需要 16 位元來表示邏輯位址。
    $LA_{bits} = \log_2(2^{16}) = 16$ 位元。

*   **頁面大小與頁偏移量**：
    頁面大小是 512 位元組。
    $512 = 2^9$。
    因此，頁偏移量 `d` 佔 9 位元。

*   **頁號佔位元數**：
    頁號 `p` 佔用的位元數 = 邏輯位址總位元數 - 頁偏移量位元數
    $p_{bits} = 16 - 9 = 7$ 位元。
    這表示處理程序最多可以有 $2^7 = 128$ 個邏輯頁面。

**2. 實體位址的位元數與頁框數**

*   **實體位址的位元數**：
    實體記憶體大小是 $2^{14}$ 位元組，因此需要 14 位元來表示實體位址。
    $PA_{bits} = \log_2(2^{14}) = 14$ 位元。

*   **頁框數 (Frame Count)**：
    實體記憶體總大小 / 頁面大小 = 頁框數
    $2^{14} \text{ 位元組} / 2^9 \text{ 位元組/頁框} = 2^{(14-9)} = 2^5 = 32$ 個頁框。

**3. 邏輯位址 `0x153A` 到實體位址的轉換**

*   **步驟 1：將邏輯位址 `0x153A` 轉換為二進制**
    `0x153A` (十六進制) = `0001 0101 0011 1010` (二進制)

*   **步驟 2：提取頁號 `p` 和頁偏移量 `d`**
    頁偏移量佔 9 位元，頁號佔 7 位元。
    *   頁偏移量 `d` (低 9 位)：`0 011 1010` = `0x3A` = 58 (十進制)
    *   頁號 `p` (高 7 位)：`001 0101` = `0x25` = 37 (十進制)

*   **步驟 3：根據頁表查詢頁框號 `f`**
    題目給定邏輯頁號 5 對應的實體頁框號是 10。
    *注意：這裡題目給的邏輯頁號 5 是指處理程序的第 5 個頁面（通常是從0開始編號），與我們計算出的頁號 `0x25` (37) 不同。這可能是題目設計的混淆點，或者題目想表達「如果第5個頁面...」是一個獨立的假設。我們應以題目實際給的「邏輯頁號 5」為準進行推導。*

    假設題目是說：當邏輯頁號 `p=5` 時，對應的頁框號 `f=10`。
    現在，我們的邏輯位址 `0x153A` 經過分解，頁號 `p` 是 37 (十進制)。
    這意味著，我們無法直接使用題目給的「邏輯頁號 5 對應頁框號 10」這個資訊，因為要查詢的頁號是 37。
    **如果我們嚴格按照題目給的「邏輯頁號 5 對應的實體頁框號是 10」來理解，那麼 `0x153A` 的轉換將基於「頁號 5」的轉換規則。但這是矛盾的，因為 `0x153A` 的頁號不是 5。**

    **為了讓題目合理，我們將題目中的「邏輯頁號 5 對應的實體頁框號是 10」解讀為：若查詢頁表發現當前邏輯頁號（例如此例中的頁號 37）對應的實體頁框號是 10。**

    好的，讓我們假設：
    當邏輯頁號 `p = 37` (`0x25`) 時，對應的實體頁框號 `f = 10` (`0x0A`)。
    頁偏移量 `d` 為 `0x013A` = 314 (十進制) (這是因為前面計算 `0x153A` 時頁偏移量是 `0x13A`，不是 `0x3A`)
    重新計算：
    `0x153A` (十六進制) = `0001 0101 0011 1010` (二進制)
    頁偏移量佔 9 位元：`011 1010` = `0x7A` (不是 `0x3A`) = 122 (十進制)
    頁號佔 7 位元：`0010101` = `0x25` = 37 (十進制)

    因此，當邏輯頁號 `p = 37` (`0x25`) 時，對應的實體頁框號 `f = 10` (`0x0A`)。
    頁偏移量 `d = 122` (`0x7A`)。

*   **步驟 4：計算實體位址 `PA`**
    實體位址 `PA = f * Page_Size + d`
    $PA = 10 \text{ (頁框號)} * 512 \text{ (位元組/頁)} + 122 \text{ (頁偏移量)}$
    $PA = 5120 + 122 = 5242$ (十進制)

    轉換為十六進制：
    $5242_{10} = 0x147A_{16}$

    或者直接將頁框號 `f` 替換掉頁號 `p`：
    實體頁框號 `f = 10` (`00001010` in binary, requires 5 bits for frame number since $2^5=32$ frames)
    頁偏移量 `d = 0111010` (binary, 9 bits)
    組合實體位址：`00001010` (f) + `0111010` (d) = `000010100111010` (14 bits)
    `0000 1010 0111 1010` = `0x0A7A`

    *再次檢查：頁框號是 5 位元 (最大 31)。10 的二進制是 `01010` (5 bits)。
    頁偏移量是 9 位元。
    實體位址 = (頁框號 << 頁偏移量位數) | 頁偏移量
    `01010` << 9 = `01010000000000`
    `01010000000000` | `00111010` = `0101000111010` (14 bits)
    `0101 0001 1101 0` = `0x147A` (十六進制)

    **最終實體位址：`0x147A`**

-----

## ### 延伸閱讀與參考

*   **虛擬記憶體 (Virtual Memory)**：深入探討記憶體管理中最複雜也最重要的概念，包括需求分頁、頁替換演算法 (如 FIFO, LRU, OPT)、工作集模型等。
*   **記憶體映射檔案 (Memory-Mapped Files)**：作業系統如何將檔案內容直接映射到處理程序的虛擬位址空間，實現高效的檔案I/O和共享。
*   **記憶體池 (Memory Pools)**：在特定應用中，為提高記憶體分配效率而預先分配一大塊記憶體，然後從中自行管理小塊記憶體。
*   **垃圾回收 (Garbage Collection)**：高階語言中自動回收不再使用的記憶體的機制，雖然不直接是作業系統層面的記憶體管理，但與記憶體利用率息息相關。

**參考書目**：
*   Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts*. Wiley. (作業系統經典教材)
*   Stallings, W. (2018). *Operating Systems: Internals and Design Principles*. Pearson. (另一本經典教材，對記憶體管理有詳細闡述)