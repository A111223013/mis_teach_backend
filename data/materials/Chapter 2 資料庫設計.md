# Chapter 2 資料庫設計

本章將帶您深入了解資料庫設計的核心概念與實務方法。一個良好的資料庫設計，是確保資料庫效能、完整性與可維護性的基石。我們將從抽象的概念模型（實體-關係模型）開始，逐步轉換為具體的關聯式模型，並透過正規化技術優化設計。

-----

## 1. 核心概念與定義

### #### 什麼是資料庫設計？
資料庫設計是一個將現實世界的資料結構化，並儲存在資料庫中的過程。其主要目標是建立一個能夠有效儲存、檢索、更新資料，同時確保資料完整性、一致性、減少冗餘的資料庫架構。

**核心目標：**
*   **資料完整性 (Data Integrity)：** 確保資料的正確性與一致性。
*   **減少資料冗餘 (Reduce Data Redundancy)：** 避免相同資料在多處重複儲存，造成儲存空間浪費與更新異常。
*   **提高查詢效率 (Improve Query Efficiency)：** 優化資料結構，讓資料檢索更快速。
*   **彈性與可擴展性 (Flexibility & Scalability)：** 易於適應未來變動與資料增長。

### #### 資料庫設計的生命週期
資料庫設計通常遵循以下階段：

1.  **需求分析 (Requirements Analysis)：** 收集用戶對資料的儲存、檢索和操作需求。
2.  **概念設計 (Conceptual Design)：** 使用高階資料模型（如實體-關係模型 ER Model）來描述資料，獨立於任何特定的資料庫管理系統 (DBMS)。
3.  **邏輯設計 (Logical Design)：** 將概念模型轉換為特定資料模型（如關聯式模型）的結構，仍然獨立於特定的 DBMS 實作。
4.  **物理設計 (Physical Design)：** 定義資料在儲存媒體上的具體儲存方式，包括索引、分區等，高度依賴於選定的 DBMS。

本章將主要聚焦於概念設計與邏輯設計。

### #### 實體-關係模型 (Entity-Relationship Model, ER Model)
ER 模型是一種高階概念資料模型，用於描述真實世界中的實體、實體的屬性以及實體之間的關係。它是資料庫設計的第一步，透過繪製 ER 圖來視覺化資料結構。

**核心元素：**

*   **實體 (Entity)：** 代表真實世界中可區分的「事物」或「概念」，例如：學生、課程、部門。在 ER 圖中通常用**矩形**表示。
    *   **實體集 (Entity Set)：** 相同類型實體的集合。

*   **屬性 (Attribute)：** 描述實體特徵的性質，例如：學生的姓名、學號、出生日期；課程的名稱、學分。在 ER 圖中通常用**橢圓形**表示，並與其所屬實體連接。
    *   **簡單屬性 (Simple Attribute)：** 無法再分解的屬性（如：學號）。
    *   **複合屬性 (Composite Attribute)：** 可再分解為更小組件的屬性（如：地址可分解為省、市、街）。
    *   **多值屬性 (Multivalued Attribute)：** 一個實體可擁有多個值的屬性（如：電話號碼，一人可能有多個）。在 ER 圖中用**雙橢圓**表示。
    *   **衍生屬性 (Derived Attribute)：** 可以從其他屬性或實體計算得出的屬性（如：年齡可從出生日期計算）。在 ER 圖中用**虛線橢圓**表示。
    *   **鍵屬性 (Key Attribute)：** 能夠唯一識別實體集中每個實體的屬性或屬性集（如：學號、身份證號）。在 ER 圖中用**底線**標示。

*   **關係 (Relationship)：** 描述兩個或多個實體之間的關聯。例如：學生「選修」課程，教師「任教」部門。在 ER 圖中通常用**菱形**表示。
    *   **關係的度數 (Degree of a Relationship)：** 參與關係的實體集數量。
        *   **一元關係 (Unary/Recursive)：** 一個實體集與自身的關係（例如：員工「管理」其他員工）。
        *   **二元關係 (Binary)：** 兩個實體集之間的關係（最常見）。
        *   **三元關係 (Ternary)：** 三個實體集之間的關係。
    *   **基數比 (Cardinality Ratio)：** 表示一個實體集中的實體在關係中能與另一個實體集中的多少個實體相關聯。常見的基數比有：
        *   **1:1 (一對一)：** 例如，一個學生只有一個學籍檔案，一個學籍檔案只屬於一個學生。
        *   **1:N (一對多)：** 例如，一個部門有多個員工，但一個員工只屬於一個部門。
        *   **M:N (多對多)：** 例如，一個學生可以選修多門課程，一門課程可以被多個學生選修。
    *   **參與限制 (Participation Constraint)：** 實體集中的實體是否必須參與關係。
        *   **全部參與 (Total Participation)：** 實體集中的每個實體都必須參與關係。在 ER 圖中用**雙線**連接實體與關係。
        *   **部分參與 (Partial Participation)：** 實體集中的部分實體參與關係。在 ER 圖中用**單線**連接實體與關係。

-----

## 2. 典型例子與轉換/推導

### #### ER 模型繪製範例：學生選課系統

**情境描述：**
一個大學的學生選課系統需要管理學生、課程和教師。
*   每個**學生**有唯一的學號、姓名、出生日期。
*   每門**課程**有唯一的課程號、課程名稱、學分。
*   每個**教師**有唯一的教師號、姓名、職稱。
*   學生可以**選修**多門課程，一門課程可以被多個學生選修。學生選修課程後會有一個成績。
*   教師可以**任教**多門課程，一門課程只能由一位教師任教。
*   課程屬於一個**系所**，一個系所包含多門課程。系所有系所編號和名稱。

**ER 圖設計：**

*   **實體：**
    *   `學生` (Student): 屬性 {`學號`(主鍵, 底線), `姓名`, `出生日期`}
    *   `課程` (Course): 屬性 {`課程號`(主鍵, 底線), `課程名稱`, `學分`}
    *   `教師` (Teacher): 屬性 {`教師號`(主鍵, 底線), `姓名`, `職稱`}
    *   `系所` (Department): 屬性 {`系所編號`(主鍵, 底線), `系所名稱`}

*   **關係：**
    *   `選修` (Enroll): `學生` M:N `課程`。關係屬性 {`成績`}。
        *   學生：部分參與 (`部分學生可能未選課`)
        *   課程：部分參與 (`部分課程可能無學生選修`)
    *   `任教` (Teach): `教師` 1:N `課程`。
        *   教師：部分參與 (`部分教師可能未任教課程`)
        *   課程：全部參與 (`所有課程都必須由一位教師任教`)
    *   `屬於` (Belongs_to): `系所` 1:N `課程`。
        *   系所：部分參與 (`部分系所可能暫無開設課程`)
        *   課程：全部參與 (`所有課程都必須屬於一個系所`)

ER 圖 (文本表示，實際繪圖為圖形化)：
```
+--------------+        +--------------+        +--------------+
|    學生      |        |     選修     |        |    課程      |
+--------------+        +--------------+        +--------------+
| 學號(PK)      |<-----| 成績         |----->| 課程號(PK)   |
| 姓名         |        +--------------+        | 課程名稱     |
| 出生日期      |                                | 學分         |
+--------------+                                +--------------+
        (N) |      (M)
            |      /
            |     /
            |    /
            |   /
            |  /
            | /
+--------------+        +--------------+
|    教師      |        |     任教     |
+--------------+        +--------------+
| 教師號(PK)   |<-----|             |----->|
| 姓名         |        +--------------+        |
| 職稱         |                                |
+--------------+                                |
        (1) |                               (N) |
            |                                   |
            |                                   |
            |                                   |
+--------------+        +--------------+        |
|    系所      |        |     屬於     |        |
+--------------+        +--------------+        |
| 系所編號(PK)  |<-----|             |----->|
| 系所名稱     |        +--------------+        |
+--------------+                                |
        (1)                               (N)
```

### #### 從 ER 模型到關聯式模型的轉換規則

一旦 ER 圖設計完成，下一步是將其轉換為邏輯設計，即關聯式模型的表格結構。

1.  **實體集 (Strong Entity Set) 轉換為表格：**
    *   每個強實體集轉換為一個關聯 (表格)。
    *   實體的屬性成為表格的欄位。
    *   實體的鍵屬性成為表格的主鍵。
    *   *範例：* `學生(學號, 姓名, 出生日期)`，`課程(課程號, 課程名稱, 學分)`，`教師(教師號, 姓名, 職稱)`，`系所(系所編號, 系所名稱)`。

2.  **弱實體集 (Weak Entity Set) 轉換為表格：**
    *   每個弱實體集轉換為一個關聯 (表格)。
    *   表格的主鍵由其自身的部分鍵 (Partial Key) 和其所依賴的強實體集的主鍵組成。
    *   *範例：* 如果有一個「家屬」弱實體依賴於「員工」強實體，則 `家屬(員工ID(FK), 家屬姓名(Partial Key), ...)`。

3.  **1:1 二元關係 (One-to-One Binary Relationship)：**
    *   將其中一個實體的主鍵作為外部鍵 (Foreign Key) 放置到另一個實體的表格中。通常選擇參與限制為全部參與的那一方。
    *   *範例：* `學生`與`學籍檔案`是1:1。可以在`學生`表中添加`學籍檔案ID`，或在`學籍檔案`表中添加`學號`。

4.  **1:N 二元關係 (One-to-Many Binary Relationship)：**
    *   將「1」端實體的主鍵作為外部鍵放置到「N」端實體的表格中。
    *   *範例：* `教師`任教`課程` (1:N)。將`教師號`作為外部鍵添加到`課程`表格中：`課程(課程號, 課程名稱, 學分, 教師號(FK))`。
    *   *範例：* `系所`包含`課程` (1:N)。將`系所編號`作為外部鍵添加到`課程`表格中：`課程(課程號, 課程名稱, 學分, 教師號(FK), 系所編號(FK))`。

5.  **M:N 二元關係 (Many-to-Many Binary Relationship)：**
    *   為此關係創建一個新的表格。
    *   新表格的主鍵由關係兩端實體的主鍵組成 (複合主鍵)。
    *   新表格包含關係本身的屬性（如果有）。
    *   *範例：* `學生`選修`課程` (M:N) 且有`成績`屬性。創建新表格`選修`：`選修(學號(FK), 課程號(FK), 成績)`。其中 `(學號, 課程號)` 是複合主鍵。

6.  **多值屬性 (Multivalued Attribute)：**
    *   為多值屬性創建一個獨立的表格。
    *   新表格的主鍵由原實體的主鍵和多值屬性本身組成。
    *   *範例：* `員工`有一個多值屬性`電話號碼`。創建表格`員工電話`：`員工電話(員工ID(FK), 電話號碼)`。

7.  **複合屬性 (Composite Attribute)：**
    *   只保留其組件屬性，不保留複合屬性本身。
    *   *範例：* `地址`包含`省`、`市`、`街`。在表格中只創建`省`、`市`、`街`三個欄位。

8.  **衍生屬性 (Derived Attribute)：**
    *   通常不儲存，而是在需要時計算。
    *   但在某些情況下，如果計算成本高且頻繁使用，也可以考慮儲存並在資料更新時維護。

**轉換結果 (以學生選課系統為例)：**

*   `學生` (學號, 姓名, 出生日期)
    *   `學號` 是主鍵 (Primary Key, PK)
*   `教師` (教師號, 姓名, 職稱)
    *   `教師號` 是主鍵 (PK)
*   `系所` (系所編號, 系所名稱)
    *   `系所編號` 是主鍵 (PK)
*   `課程` (課程號, 課程名稱, 學分, **教師號**, **系所編號**)
    *   `課程號` 是主鍵 (PK)
    *   `教師號` 是外部鍵 (Foreign Key, FK) 參考`教師`表的`教師號`
    *   `系所編號` 是外部鍵 (FK) 參考`系所`表的`系所編號`
*   `選修` (學號, 課程號, 成績)
    *   `(學號, 課程號)` 是複合主鍵 (Composite PK)
    *   `學號` 是外部鍵 (FK) 參考`學生`表的`學號`
    *   `課程號` 是外部鍵 (FK) 參考`課程`表的`課程號`

### #### 關聯式資料庫的正規化 (Normalization)

正規化是一種系統化的過程，用於分析關聯式資料庫表格，以減少資料冗餘、消除更新異常（插入、刪除、更新異常）並提高資料完整性。它基於函數相依性理論。

**核心概念：**

*   **函數相依性 (Functional Dependency, FD)：**
    如果在一關聯 $R$ 中，屬性集 $X$ 的值能唯一確定屬性集 $Y$ 的值，則稱 $Y$ 函數相依於 $X$，記為 $X \rightarrow Y$。
    例如：在`學生`表中，`學號` $\rightarrow$ `姓名`，因為一個學號只對應一個姓名。

*   **鍵 (Keys)：**
    *   **超鍵 (Super Key)：** 能唯一識別表格中每一筆記錄的一個或多個屬性組合。
    *   **候選鍵 (Candidate Key)：** 最小的超鍵，即移走其中任何屬性後就不再是超鍵。
    *   **主鍵 (Primary Key)：** 從候選鍵中選定的一個鍵，用來唯一識別表格中的每一筆記錄。
    *   **外部鍵 (Foreign Key)：** 一個表格中的屬性 (或屬性組合) 參考另一個表格的主鍵。用於建立表格間的關聯。

**正規形 (Normal Forms)：**

1.  **第一正規形 (First Normal Form, 1NF)：**
    *   **定義：** 表格中每個屬性都是原子性的，不可再分解。不允許有複合屬性、多值屬性或重複群組。
    *   **推導：** 確保所有欄位都只包含單一值，且不可再分。
    *   **範例：** 原始表格`員工(員工ID, 姓名, 電話號碼)`，如果`電話號碼`是多值的（一人有多個），則不符合1NF。應分解為`員工(員工ID, 姓名)`和`員工電話(員工ID, 電話號碼)`。

2.  **第二正規形 (Second Normal Form, 2NF)：**
    *   **定義：** 必須先滿足 1NF，並且所有非主鍵屬性都必須「完全函數相依」於主鍵。也就是說，不能有部分相依性。
    *   **部分相依性 (Partial Dependency)：** 非主鍵屬性僅依賴於複合主鍵的某個部分。
    *   **推導：** 如果表格存在複合主鍵，檢查是否有非主鍵屬性只依賴於主鍵的一部分。若有，則將該部分和相依屬性分離到新表格中。
    *   **範例：** 表格`選修(學號, 課程號, 成績, 課程名稱)`。主鍵是`(學號, 課程號)`。`課程名稱`只依賴於`課程號`（主鍵的一部分），因此存在部分相依性。分解為：`選修(學號, 課程號, 成績)` 和 `課程資訊(課程號, 課程名稱)`。

3.  **第三正規形 (Third Normal Form, 3NF)：**
    *   **定義：** 必須先滿足 2NF，並且所有非主鍵屬性都不能「遞移相依」於主鍵。
    *   **遞移相依性 (Transitive Dependency)：** 非主鍵屬性 $A$ 透過另一個非主鍵屬性 $B$ 間接依賴於主鍵 $P$（即 $P \rightarrow B$ 且 $B \rightarrow A$）。
    *   **推導：** 檢查是否存在非主鍵屬性 $X$ 依賴於非主鍵屬性 $Y$，而 $Y$ 又依賴於主鍵。若有，將 $Y$ 和 $X$ 分離到新表格中。
    *   **範例：** 表格`員工(員工ID, 姓名, 部門名稱, 部門電話)`。`員工ID` $\rightarrow$ `部門名稱`，`部門名稱` $\rightarrow$ `部門電話`。`部門電話`遞移相依於`員工ID`。分解為：`員工(員工ID, 姓名, 部門名稱(FK))` 和 `部門(部門名稱, 部門電話)`。

4.  **Boyce-Codd 正規形 (BCNF)：**
    *   **定義：** 必須先滿足 3NF，並且對於每一個非平凡的函數相依性 $X \rightarrow Y$， $X$ 必須是超鍵。
    *   **推導：** BCNF 比 3NF 更嚴格。3NF 允許某些情況下非主鍵屬性透過候選鍵遞移相依，而 BCNF 則不允許。如果一個表格有多個重疊的候選鍵，且存在非平凡的函數相依性，其左側不是超鍵，則可能需要進一步分解。
    *   **注意：** 任何處於 3NF 且只有一個候選鍵的表格，自動滿足 BCNF。對於大多數應用，達到 3NF 已經足夠。

-----

## 3. 與相鄰概念的關聯

### #### ER 模型與物件導向分析設計的關聯
ER 模型在概念層次描述資料，強調實體、屬性與關係。物件導向分析設計 (OOAD) 則以「物件」為中心，包含資料（屬性）和行為（方法）。兩者在許多方面有共通點：
*   **實體 (Entity) vs. 物件 (Object) / 類別 (Class)：** ER 模型中的實體集與 OOAD 中的類別概念高度相似，都代表一組具有共同特徵的事物。
*   **屬性 (Attribute)：** 兩者都用屬性來描述實體的特徵。
*   **關係 (Relationship) vs. 關聯 (Association)：** ER 模型的關係與 OOAD 中的關聯 (Association) 概念對應。基數比和參與限制在 UML 關聯中也有類似的表達方式。
*   **繼承 (Inheritance) / 特化-泛化 (Specialization-Generalization)：** 雖然 ER 模型本身不直接提供繼承機制，但可以透過特化-泛化 (或超型別/子型別) 的概念來模擬，這與物件導向中的繼承概念相似。

許多 CASE (Computer-Aided Software Engineering) 工具允許從 UML 類別圖自動生成 ER 圖，反之亦然，顯示了兩者在系統設計中的緊密結合。

### #### 正規化與資料庫效能、資料冗餘、更新異常的關聯
*   **減少資料冗餘：** 正規化透過分解表格，避免了相同資料在多處儲存，從根本上減少了資料冗餘。例如，部門名稱和電話號碼只會出現在 `部門` 表中一次，而不是在每個員工記錄中重複。
*   **消除更新異常：**
    *   **插入異常 (Insertion Anomaly)：** 在未正規化的表格中，若要插入一個新的部門，但該部門目前沒有任何員工，可能無法插入（因為主鍵或外鍵限制）。正規化後，新部門可直接插入到 `部門` 表。
    *   **刪除異常 (Deletion Anomaly)：** 若刪除最後一個屬於某部門的員工記錄，可能會導致該部門的資訊（如部門名稱、電話）也一併被刪除。正規化後，刪除員工不會影響 `部門` 表中的部門資訊。
    *   **更新異常 (Update Anomaly)：** 若某部門的電話號碼需要更新，在未正規化表格中，需要更新所有屬於該部門的員工記錄。若有任何遺漏，將導致資料不一致。正規化後，只需更新 `部門` 表中的一條記錄。
*   **效能影響：**
    *   **讀取 (Read) 效能：** 高度正規化的表格可能需要更多的 JOIN 操作才能獲取完整資訊，這可能降低查詢效能。
    *   **寫入 (Write) 效能：** 由於冗餘減少，更新操作所需的資料量減少，通常會提高寫入效能。
    *   在實際應用中，有時會進行**反正規化 (Denormalization)**，為了提高特定查詢的效能，而故意引入少量冗餘。這是在正規化基礎上，為了應用場景的效能需求所做的權衡。

### #### 資料庫設計與系統分析/軟體工程的關聯
資料庫設計是軟體工程生命週期中不可或缺的一部分，特別是在系統分析與設計階段：
*   **需求分析階段：** 資料庫設計從系統的需求分析開始，理解業務流程、資料流，並定義資料實體、關係和約束。
*   **系統設計階段：** 概念設計 (ER 模型) 和邏輯設計 (關聯式模型) 是系統設計的核心部分，它們定義了系統如何儲存和管理資料。
*   **實作階段：** 資料庫設計的輸出（SQL DDL 語句）直接用於建立資料庫結構。
*   **維護階段：** 良好的資料庫設計有助於系統的長期維護、功能擴展和效能優化。
一個成功的資訊系統，其底層資料庫設計往往是其穩定性和效率的關鍵。

-----

## 4. 進階內容

### #### 實體-關係模型中的特化與泛化 (Specialization and Generalization)

在更複雜的 ER 模型中，我們可能遇到一些實體集是另一些實體集的「子類別」或「超類別」的情況。

*   **泛化 (Generalization)：** 是一種自底向上的設計方法，從多個相似的實體集（子類別）中抽象出一個更通用的實體集（超類別），將它們的共同屬性或關係提升到超類別中。
    *   *範例：* `研究生`和`大學生`都是`學生`。`學生`是超類別，`研究生`和`大學生`是子類別。

*   **特化 (Specialization)：** 是一種自頂向下的設計方法，從一個實體集（超類別）中派生出一個或多個更具體的實體集（子類別），每個子類別擁有超類別的所有屬性和關係，並可能增加自己的特定屬性或關係。
    *   *範例：* `員工`可以特化為`工程師`和`銷售員`，他們有共同的員工屬性，但各自有獨特的屬性（例如`工程師`有`技術專長`，`銷售員`有`銷售區域`）。

**特化/泛化的表示：**
在 ER 圖中，通常使用一個圓圈連接超類別與子類別，並用 `IS-A` 關係表示。

**約束條件：**
*   **不交疊 (Disjoint, `d`)：** 一個實體最多只能屬於一個子類別。
*   **交疊 (Overlapping, `o`)：** 一個實體可以同時屬於多個子類別。
*   **完全 (Total)：** 超類別中的每個實體都必須屬於某個子類別。
*   **部分 (Partial)：** 超類別中的某些實體可能不屬於任何子類別。

**轉換到關聯式模型：**
有多種策略將特化/泛化結構轉換為表格：
1.  **每個類別一個表格 (Table for each class)：** 為超類別和每個子類別都創建一個表格。子類別表格透過外部鍵關聯到超類別表格。
2.  **所有類別一個表格 (Single table with nulls)：** 只創建一個表格，包含超類別和所有子類別的屬性，子類別特有的屬性在不適用時為 NULL。
3.  **只有子類別表格 (Tables for subclasses only)：** 不為超類別創建獨立表格，將超類別的屬性重複放置到每個子類別表格中。

選擇哪種策略取決於實際情況，如資料稀疏度、查詢模式等。

-----

## 5. 常見錯誤與澄清

1.  **誤將屬性視為實體：**
    *   **錯誤：** 將「電話號碼」、「地址」等直接作為獨立實體。
    *   **澄清：** 實體應是具有獨立存在意義且可被明確區分的事物。電話號碼和地址通常是實體的屬性，除非它們本身擁有更複雜的屬性或關係，例如「電話號碼服務提供商」或「地理區域」。判斷標準是：它是否能獨立存在並具有自身關鍵屬性，或者它只是描述另一個實體的特徵？

2.  **關係的基數比混淆 (1:1, 1:N, M:N)：**
    *   **錯誤：** 將「一個學生選修一門課程」誤標為 1:1，但實際應是「一個學生選修多門課程，一門課程被多個學生選修」（M:N）。
    *   **澄清：** 基數比是從關係的「兩端」觀察的。要判斷 $A$ 與 $B$ 的關係，需問兩個問題：
        *   一個 $A$ 的實例，可以和多少個 $B$ 的實例關聯？
        *   一個 $B$ 的實例，可以和多少個 $A$ 的實例關聯？
        將這些數字組合起來，就得到基數比。

3.  **未能正確識別主鍵和候選鍵：**
    *   **錯誤：** 隨意選擇一個欄位作為主鍵，而該欄位可能無法唯一識別記錄，或不是最小的唯一識別符。
    *   **澄清：** 主鍵必須能夠**唯一**識別表格中的每一行，且其值**永不為 NULL**。候選鍵是最小的超鍵。若存在多個候選鍵，通常選擇一個穩定、簡潔的作為主鍵。複合主鍵在許多 M:N 關係的連接表中很常見。

4.  **正規化不足或過度正規化：**
    *   **不足：** 導致資料冗餘、更新異常，影響資料庫完整性與維護性。這通常是因為未能正確識別函數相依性或未能將表格分解到合適的正規形。
    *   **過度：** 將表格分解得過於細緻，導致查詢時需要大量的 JOIN 操作，從而降低讀取效能。在某些情況下，為了效能考量，可以容忍一定的非正規化（反正規化），但這需要謹慎權衡和設計。
    *   **澄清：** 通常達到 3NF 已經足以解決大多數資料庫設計問題。是否進一步到 BCNF 需視具體情況。反正規化應是基於明確的效能需求分析後的選擇，而不是設計初期的默認做法。

5.  **弱實體的判斷：**
    *   **錯誤：** 將所有依賴於其他實體存在的實體都視為弱實體。
    *   **澄清：** 弱實體不僅依賴於強實體的存在，更重要的是，它**無法獨立擁有主鍵**，其主鍵的一部分（或全部）必須由其所依賴的強實體的主鍵提供。例如，`訂單項目`依賴於`訂單`，但它通常有自己的`項目編號`，並且`(訂單ID, 項目編號)`構成主鍵，因此它可能不是嚴格意義上的弱實體，而是一個關係中的實體。`家屬`則通常沒有獨立 ID，需藉助`員工ID`來識別。

-----

## 6. 小練習 (附詳解)

### #### 小練習 1: ER 模型設計

**情境：**
請為一家小型電影租賃店設計一個 ER 模型。該店有以下需求：
*   管理**客戶**：每個客戶有唯一的客戶ID、姓名、地址、電話。
*   管理**電影**：每部電影有唯一的電影ID、標題、發行年份、導演姓名。一部電影可以有多個拷貝，每個拷貝有自己的拷貝ID和狀態（如：可租借、已租借、維修中）。
*   管理**租借**：客戶可以租借電影拷貝。每次租借會記錄租借日期和歸還日期。
*   管理**員工**：每個員工有唯一的員工ID、姓名、職位。
*   員工負責**處理租借**業務。一個租借業務由一位員工處理，一個員工可以處理多個租借業務。

**要求：** 繪製 ER 圖 (使用文本描述即可)，標註實體、屬性 (包含主鍵、多值/複合/衍生屬性)、關係、基數比和參與限制。

**詳解步驟：**

1.  **識別實體：**
    *   `客戶` (Customer)
    *   `電影` (Movie)
    *   `拷貝` (Copy)
    *   `租借` (Rental) - 這裡`租借`本身就是一個事件，包含資訊，可以視為一個實體。
    *   `員工` (Employee)

2.  **識別屬性並標註主鍵：**
    *   `客戶`：{`客戶ID`(PK), `姓名`, `地址`(複合屬性：`街道`, `城市`, `郵遞區號`), `電話`(多值屬性)}
    *   `電影`：{`電影ID`(PK), `標題`, `發行年份`, `導演姓名`}
    *   `拷貝`：{`拷貝ID`(PK), `狀態`}. 注意：`拷貝ID` 在電影範圍內是唯一的，但整體唯一識別可能需要結合`電影ID`。這裡假設`拷貝ID`是全局唯一的。或者更嚴謹地，`拷貝ID`是針對`電影ID`的部分鍵，使其成為一個弱實體。我們假設`拷貝ID`是全局唯一，方便起見。
    *   `租借`：{`租借ID`(PK), `租借日期`, `歸還日期`(可為NULL)}
    *   `員工`：{`員工ID`(PK), `姓名`, `職位`}

3.  **識別關係與基數比、參與限制：**
    *   `客戶` -- `租借` (進行):
        *   一個客戶可以進行多次租借 (1:N)。
        *   一個租借業務只能由一個客戶發起 (1:1)。
        *   客戶：部分參與 (不是所有客戶都會租借)。
        *   租借：全部參與 (每個租借業務都必須有一個客戶)。
    *   `拷貝` -- `租借` (包含):
        *   一個拷貝可以被租借多次 (但不同時間) (1:N)。
        *   一個租借業務只包含一個電影拷貝 (1:1)。
        *   拷貝：部分參與 (不是所有拷貝都被租借過)。
        *   租借：全部參與 (每個租借業務都必須有一個拷貝)。
    *   `電影` -- `拷貝` (擁有):
        *   一部電影可以擁有許多拷貝 (1:N)。
        *   一個拷貝只屬於一部電影 (1:1)。
        *   電影：部分參與 (可能新電影還沒有拷貝)。
        *   拷貝：全部參與 (每個拷貝都必須屬於一部電影)。
    *   `員工` -- `租借` (處理):
        *   一個員工可以處理多個租借 (1:N)。
        *   一個租借業務只能由一位員工處理 (1:1)。
        *   員工：部分參與 (不是所有員工都處理租借)。
        *   租借：全部參與 (每個租借業務都必須由一位員工處理)。

**ER 圖 (文本表示)：**

```
+--------------+    進行(1:N)    +--------------+    包含(1:1)    +--------------+
|    客戶      |<--------------|    租借      |<--------------|     拷貝     |
+--------------+                +--------------+                +--------------+
| 客戶ID(PK)    |                | 租借ID(PK)   |                | 拷貝ID(PK)   |
| 姓名         |                | 租借日期     |                | 狀態         |
| 地址         |                | 歸還日期     |                +--------------+
|   (街道,城市,郵遞區號)        +--------------+                        ^
| 電話(多值)   |                                                        | 擁有(1:N)
+--------------+                                                        |
                                                                        |
                                                                  +--------------+
                                                                  |    電影      |
                                                                  +--------------+
                                                                  | 電影ID(PK)   |
                                                                  | 標題         |
                                                                  | 發行年份     |
                                                                  | 導演姓名     |
                                                                  +--------------+

+--------------+    處理(1:N)    +--------------+
|    員工      |<--------------|    租借      |
+--------------+                +--------------+
| 員工ID(PK)   |                | ...           |
| 姓名         |                +--------------+
| 職位         |
+--------------+
```

### #### 小練習 2: 正規化

**情境：**
假設你收到一個包含學生選課資訊的表格 `Student_Course`，其結構和函數相依性如下：

`Student_Course` (學號, 學生姓名, 系所名稱, 系所地點, 課程號, 課程名稱, 學分, 成績)

函數相依性 (FDs)：
1.  `學號` $\rightarrow$ `學生姓名, 系所名稱` (學號決定學生姓名和所屬系所名稱)
2.  `系所名稱` $\rightarrow$ `系所地點` (系所名稱決定系所地點)
3.  `(學號, 課程號)` $\rightarrow$ `成績` (學號和課程號共同決定成績)
4.  `課程號` $\rightarrow$ `課程名稱, 學分` (課程號決定課程名稱和學分)

**要求：** 將此表格分解到第三正規形 (3NF)。請列出每一步驟和分解後的表格。

**詳解步驟：**

1.  **找出所有候選鍵：**
    *   從 FD (3) `(學號, 課程號)` $\rightarrow$ `成績`，我們知道 `(學號, 課程號)` 可以決定 `成績`。
    *   結合 FD (1) `學號` $\rightarrow$ `學生姓名, 系所名稱`，可以得到 `(學號, 課程號)` $\rightarrow$ `學生姓名, 系所名稱`。
    *   結合 FD (2) `系所名稱` $\rightarrow$ `系所地點`，可以得到 `(學號, 課程號)` $\rightarrow$ `系所地點`。
    *   結合 FD (4) `課程號` $\rightarrow$ `課程名稱, 學分`，可以得到 `(學號, 課程號)` $\rightarrow$ `課程名稱, 學分`。
    *   因此，`學號`和`課程號`的組合 `(學號, 課程號)` 可以唯一決定表格中所有其他屬性。
    *   **候選鍵：** `(學號, 課程號)`

2.  **檢查 1NF：**
    *   所有屬性 (學號, 學生姓名, 系所名稱, 系所地點, 課程號, 課程名稱, 學分, 成績) 都是原子性的，沒有複合屬性、多值屬性或重複群組。
    *   **結論：** `Student_Course` 表格符合 1NF。

3.  **檢查 2NF：**
    *   **定義：** 必須先滿足 1NF，且所有非主鍵屬性必須完全函數相依於主鍵 (沒有部分相依性)。
    *   主鍵是 `(學號, 課程號)`。
    *   檢查非主鍵屬性：`學生姓名`, `系所名稱`, `系所地點`, `課程名稱`, `學分`, `成績`。
    *   部分相依性檢查：
        *   `學號` $\rightarrow$ `學生姓名, 系所名稱` (非主鍵屬性 `學生姓名`, `系所名稱` 只依賴於主鍵的一部分 `學號`) - **存在部分相依性**。
        *   `課程號` $\rightarrow$ `課程名稱, 學分` (非主鍵屬性 `課程名稱`, `學分` 只依賴於主鍵的一部分 `課程號`) - **存在部分相依性**。
        *   `成績` 函數相依於 `(學號, 課程號)`，這是完全相依。

    *   **分解以消除部分相依性：**
        *   將 `學號` 及其決定的屬性分解出來：
            *   新表格 `學生` (學號, 學生姓名, 系所名稱)
            *   其餘屬性：`Student_Course_temp` (學號, 系所地點, 課程號, 課程名稱, 學分, 成績)
        *   將 `課程號` 及其決定的屬性分解出來：
            *   新表格 `課程` (課程號, 課程名稱, 學分)
            *   其餘屬性：`Student_Course_temp_2` (學號, 系所名稱, 系所地點, 課程號, 成績)
        *   原始表中只剩下與複合主鍵完全相依的屬性，即 `成績`。
            *   新表格 `選課` (學號, 課程號, 成績)

    *   **分解後的表格 (2NF)：**
        *   `學生` (學號, 學生姓名, 系所名稱)
        *   `課程` (課程號, 課程名稱, 學分)
        *   `選課` (學號, 課程號, 成績)

4.  **檢查 3NF：**
    *   **定義：** 必須先滿足 2NF，且所有非主鍵屬性不能遞移相依於主鍵 (沒有遞移相依性)。
    *   檢查分解後的表格：
        *   **表格 `學生` (學號, 學生姓名, 系所名稱)：**
            *   主鍵：`學號`
            *   非主鍵屬性：`學生姓名`, `系所名稱`
            *   FDs: `學號` $\rightarrow$ `學生姓名`, `學號` $\rightarrow$ `系所名稱`
            *   但是，我們還有 `系所名稱` $\rightarrow$ `系所地點` 這個 FD。如果 `系所地點` 在 `學生` 表中，那麼 `系所地點` 會遞移相依於 `學號` 透過 `系所名稱`。
            *   在我們目前的 `學生` 表中，沒有 `系所地點`。但是，`系所名稱` 是一個非主鍵屬性。如果存在 `系所名稱` $\rightarrow$ `系所地點` 的 FD，那麼 `系所地點` 就不能留在 `學生` 表中。
            *   **重新檢查：** 原始 FD (2) 是 `系所名稱` $\rightarrow$ `系所地點`。在 `學生` 表中，`學號` 是主鍵，`系所名稱` 是非主鍵屬性。如果 `系所地點` 在 `學生` 表中，那麼 `學號` $\rightarrow$ `系所名稱` 且 `系所名稱` $\rightarrow$ `系所地點`，這就是遞移相依性。
            *   因此，我們需要將 `系所名稱` 及其決定的屬性 `系所地點` 分解出去。
            *   分解 `學生` 表：
                *   `學生_新` (學號, 學生姓名, 系所名稱(FK))
                *   `系所` (系所名稱, 系所地點)
        *   **表格 `課程` (課程號, 課程名稱, 學分)：**
            *   主鍵：`課程號`
            *   非主鍵屬性：`課程名稱`, `學分`
            *   FDs: `課程號` $\rightarrow$ `課程名稱`, `課程號` $\rightarrow$ `學分`
            *   沒有非主鍵屬性之間形成遞移相依性。
            *   **結論：** `課程` 表格符合 3NF。
        *   **表格 `選課` (學號, 課程號, 成績)：**
            *   主鍵：`(學號, 課程號)`
            *   非主鍵屬性：`成績`
            *   FD: `(學號, 課程號)` $\rightarrow$ `成績`
            *   沒有非主鍵屬性，所以不可能有遞移相依性。
            *   **結論：** `選課` 表格符合 3NF。

    *   **最終分解後的表格 (3NF)：**
        *   `學生` (學號, 學生姓名, 系所名稱)
        *   `課程` (課程號, 課程名稱, 學分)
        *   `選課` (學號, 課程號, 成績)
        *   `系所` (系所名稱, 系所地點)

    *   **更正：** 在分解 2NF 時，`學生`表格中的`系所名稱`並不是部分相依，它完全相依於`學號`。但`系所名稱` $\rightarrow$ `系所地點` 是另外一個 FD。因此，`系所地點` 原始在 `Student_Course` 表中，它遞移相依於 `學號` 透過 `系所名稱`。
    *   **正確分解思路：**

        **原始表格：** `R` (學號, 學生姓名, 系所名稱, 系所地點, 課程號, 課程名稱, 學分, 成績)
        **主鍵：** `(學號, 課程號)`

        **1. 找出所有函數相依性：**
            1. `學號` $\rightarrow$ `學生姓名, 系所名稱`
            2. `系所名稱` $\rightarrow$ `系所地點`
            3. `(學號, 課程號)` $\rightarrow$ `成績`
            4. `課程號` $\rightarrow$ `課程名稱, 學分`

        **2. 分解到 2NF (消除部分相依性)：**
            *   非主鍵屬性 `學生姓名`, `系所名稱`, `系所地點` 部分依賴於 `學號`。
            *   非主鍵屬性 `課程名稱`, `學分` 部分依賴於 `課程號`。
            *   分解為：
                *   `學生_資訊` (學號, 學生姓名, 系所名稱, 系所地點)  -- 來自 `學號` 的部分依賴
                *   `課程_資訊` (課程號, 課程名稱, 學分) -- 來自 `課程號` 的部分依賴
                *   `選課_成績` (學號, 課程號, 成績) -- 剩下的完全依賴

        **3. 分解到 3NF (消除遞移相依性)：**
            *   檢查 `學生_資訊` (學號, 學生姓名, 系所名稱, 系所地點)：
                *   主鍵是 `學號`。
                *   存在 `學號` $\rightarrow$ `系所名稱` 且 `系所名稱` $\rightarrow$ `系所地點`。
                *   `系所地點` 遞移相依於 `學號`。
                *   分解 `學生_資訊`：
                    *   `學生` (學號, 學生姓名, 系所名稱(FK))
                    *   `系所` (系所名稱, 系所地點)
            *   檢查 `課程_資訊` (課程號, 課程名稱, 學分)：
                *   主鍵是 `課程號`。
                *   沒有非主鍵屬性之間的遞移相依。
                *   符合 3NF。
            *   檢查 `選課_成績` (學號, 課程號, 成績)：
                *   主鍵是 `(學號, 課程號)`。
                *   沒有非主鍵屬性，因此符合 3NF。

        **最終 3NF 表格：**
        1.  **`學生`** (學號, 學生姓名, 系所名稱)
            *   主鍵: `學號`
            *   外部鍵: `系所名稱` 參考 `系所` 表格
        2.  **`系所`** (系所名稱, 系所地點)
            *   主鍵: `系所名稱`
        3.  **`課程`** (課程號, 課程名稱, 學分)
            *   主鍵: `課程號`
        4.  **`選課`** (學號, 課程號, 成績)
            *   主鍵: `(學號, 課程號)`
            *   外部鍵: `學號` 參考 `學生` 表格
            *   外部鍵: `課程號` 參考 `課程` 表格

-----

## 7. 延伸閱讀/參考

*   **資料庫系統概念 (Database System Concepts)** by Abraham Silberschatz, Henry F. Korth, S. Sudarshan. (經典教科書，涵蓋資料庫理論和實作的方方面面，詳細解釋 ER 模型和正規化。)
*   **資料庫管理系統 (Database Management Systems)** by Raghu Ramakrishnan, Johannes Gehrke. (另一本廣泛使用的資料庫教科書，以其清晰的解釋和實用案例著稱。)
*   **資料庫設計實務 (Database Design for Mere Mortals): A Hands-On Guide to Relational Database Design** by Michael J. Hernandez. (更注重實務設計和最佳實踐的書籍，適合初學者從零開始學習設計。)
*   **W3Schools SQL Tutorial:** 線上資源，提供基礎 SQL 語法教學，有助於理解關聯式資料庫操作。
    *   [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)
*   **Lucidchart / draw.io：** 線上繪圖工具，可用於繪製 ER 圖和流程圖。
    *   [https://www.lucidchart.com/](https://www.lucidchart.com/)
    *   [https://app.diagrams.net/](https://app.diagrams.net/)