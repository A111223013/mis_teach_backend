# 資料庫：數據管理的基石

本章節將帶您深入了解資料庫的核心概念、運作原理、以及在現代資訊系統中的關鍵角色。從最基本的定義到進階的設計考量，您將學會如何理解、設計並與資料庫互動。

-----

## 1. 資料庫核心概念

### 什麼是資料庫？

#### 定義

資料庫（Database，簡稱 DB）是**有組織地儲存、管理和存取相關數據的集合**。它允許數據被有效地儲存、檢索、更新和刪除。資料庫的目的是為了方便數據管理，確保數據的一致性、完整性和安全性。

#### 核心觀念

*   **數據（Data）**: 儲存的原始事實、數字或資訊。
*   **資訊（Information）**: 經過處理、組織、結構化的數據，使其具有意義和價值。
*   **數據的持久性（Persistence）**: 資料庫中的數據在應用程式關閉後依然存在，不會消失。

#### 例子

想像一個圖書館。圖書館有大量的書籍。如果我們把每本書的資訊（書名、作者、出版年份、館藏號碼、借閱狀態）都寫在一張張紙上隨意堆放，那麼要找書、統計借閱量、管理歸還日期會非常困難且容易出錯。

一個資料庫就像是圖書館的分類系統和卡片目錄：
*   所有書籍的資訊都以結構化的方式儲存（例如，每本書在一個「記錄」中，每個記錄有固定的「欄位」）。
*   可以快速查詢特定作者的書、某年份出版的書、或當前被借走的書。
*   確保同一本書不會被重複登錄，借閱狀態能即時更新。

-----

### 資料庫管理系統 (DBMS)

#### 定義

資料庫管理系統（Database Management System，簡稱 DBMS）是**一套軟體，用於定義、創建、維護和控制資料庫的存取**。它充當使用者、應用程式和資料庫之間的介面。

#### 核心觀念

DBMS 的主要功能包括：
1.  **資料定義 (Data Definition)**: 允許使用者定義資料的結構、型態、限制條件。
2.  **資料操作 (Data Manipulation)**: 提供介面來新增、查詢、修改和刪除資料。
3.  **資料控制 (Data Control)**: 管理資料的安全性（誰可以存取什麼）和完整性（確保數據正確無誤）。
4.  **數據共享與多使用者存取 (Data Sharing & Multi-user Access)**: 允許多個使用者同時存取資料庫而不會互相衝突。
5.  **數據恢復與備份 (Data Recovery & Backup)**: 在系統故障時能夠恢復資料庫到一致狀態。

#### 種類

根據數據模型，DBMS 可分為多種類型：
*   **關聯式資料庫管理系統 (RDBMS)**: 最常見，以表格（Table）形式儲存數據，透過關聯（Relationship）連接不同表格。代表有 MySQL, PostgreSQL, Oracle, SQL Server。
*   **NoSQL 資料庫**: "Not only SQL"，為了解決傳統 RDBMS 在處理大數據、高併發等方面的限制而出現。包括：
    *   **鍵值對資料庫 (Key-Value Store)**: Redis, DynamoDB。
    *   **文件資料庫 (Document Store)**: MongoDB, Couchbase。
    *   **欄族資料庫 (Column-Family Store)**: Cassandra, HBase。
    *   **圖形資料庫 (Graph Database)**: Neo4j。

#### 與相鄰概念的關聯

*   **資料庫 (Database)** 就像是一間裝滿書籍的圖書館。
*   **資料庫管理系統 (DBMS)** 就像是圖書館的管理員、目錄系統、借閱規則等一切管理書籍的制度和工具。
*   **資料庫系統 (Database System)** 則是資料庫、DBMS 和所有相關應用程式的總稱。

-----

### 資料庫的三層架構

資料庫系統通常採用三層架構（Three-Schema Architecture），旨在將資料庫的物理儲存細節與使用者對資料的邏輯視圖分離，以提供數據獨立性。

1.  **外部視圖 (External Schema / View Level)**
    *   **定義**: 這是使用者或應用程式所看到的資料模型。每個使用者或應用程式可能只關心資料庫中的一部分數據，並且對這些數據有自己特定的組織方式。
    *   **目的**: 簡化使用者介面，提供數據安全性（隱藏不需要的數據），實現數據邏輯獨立性。

2.  **概念視圖 (Conceptual Schema / Logical Level)**
    *   **定義**: 這是整個資料庫的邏輯結構描述。它定義了資料庫中所有數據、它們之間的關係、屬性以及所有數據的完整性約束。
    *   **目的**: 整合所有外部視圖，提供資料庫的整體邏輯視圖，實現數據物理獨立性。它獨立於任何物理儲存細節。

3.  **內部視圖 (Internal Schema / Physical Level)**
    *   **定義**: 這是資料庫的物理儲存結構描述。它定義了數據如何儲存於磁碟上，包括儲存方式、檔案組織、索引結構、存取路徑等。
    *   **目的**: 管理實際的數據儲存，優化存取效能。

#### 數據獨立性

三層架構帶來了兩種重要的數據獨立性：
*   **邏輯數據獨立性 (Logical Data Independence)**: 概念視圖的改變不會影響外部視圖。例如，在概念視圖中新增一個欄位，如果外部視圖不使用該欄位，則外部視圖無需修改。
*   **物理數據獨立性 (Physical Data Independence)**: 內部視圖的改變不會影響概念視圖。例如，改變資料的儲存方式或索引結構，概念視圖和外部視圖都無需修改。

-----

### 資料模型簡介

資料模型是描述資料、資料間關係、資料語義和資料完整性約束的概念工具集合。以下是幾種常見的資料模型，其中關聯式模型最為廣泛使用。

#### 關聯式資料模型 (Relational Model)

*   **核心觀念**: 數據以二維表格（Table/Relation）的形式組織。每個表格由列（Row/Tuple/Record）和欄（Column/Attribute/Field）組成。表格之間透過共同的欄位建立關聯。
*   **構成要素**:
    *   **表格 (Table)**: 關聯式資料庫中的基本儲存單元，類似於 Excel 工作表。
    *   **列 (Row/Record)**: 表格中的一條記錄，代表一個實體（例如，一位學生、一本書）。
    *   **欄 (Column/Attribute)**: 表格中的一個屬性，定義了每條記錄的一個特定資訊（例如，學號、姓名）。
    *   **主鍵 (Primary Key, PK)**: 一個或一組欄位，其值能唯一識別表格中的每一列。主鍵的值必須是唯一的且不能為空（NOT NULL）。
    *   **外部鍵 (Foreign Key, FK)**: 一個或一組欄位，它引用了另一個表格的主鍵。外部鍵用於建立兩個表格之間的關聯。

#### 關聯式資料庫範例

**情境**: 設計一個學校資料庫，包含學生和課程資訊。

1.  **學生資料表 (Students)**
    *   `StudentID` (主鍵, PK): 學生的唯一識別碼，例如 S001。
    *   `Name`: 學生姓名。
    *   `Major`: 主修科系。

| StudentID (PK) | Name | Major |
| :------------- | :--- | :---- |
| S001           | 小明 | CS    |
| S002           | 小華 | EE    |
| S003           | 小美 | CS    |

2.  **課程資料表 (Courses)**
    *   `CourseID` (主鍵, PK): 課程的唯一識別碼，例如 C101。
    *   `CourseName`: 課程名稱。
    *   `Credits`: 學分數。

| CourseID (PK) | CourseName | Credits |
| :------------ | :--------- | :------ |
| C101          | 資料庫     | 3       |
| C102          | 演算法     | 4       |
| C103          | 作業系統   | 3       |

3.  **選課資料表 (Enrollments)** - 用於連結學生和課程，建立多對多關聯。
    *   `EnrollmentID` (主鍵, PK): 選課記錄的唯一識別碼。
    *   `StudentID` (外部鍵, FK): 引用 Students 表的 StudentID。
    *   `CourseID` (外部鍵, FK): 引用 Courses 表的 CourseID。
    *   `Grade`: 成績。

| EnrollmentID (PK) | StudentID (FK) | CourseID (FK) | Grade |
| :---------------- | :------------- | :------------ | :---- |
| E001              | S001           | C101          | A     |
| E002              | S001           | C102          | B+    |
| E003              | S002           | C101          | B     |
| E004              | S003           | C103          | A-    |

#### 資料表關聯 (Relationships)

表格之間的關聯描述了它們數據如何相互連結。主要有三種類型：

1.  **一對一 (One-to-One, 1:1)**
    *   **定義**: 表 A 中的一條記錄最多與表 B 中的一條記錄相關聯，反之亦然。
    *   **例子**: 一個人只有一個身分證號碼，一個身分證號碼只屬於一個人。通常為了減少單一表格的欄位過多，或將敏感資訊獨立儲存時使用。
    *   **實現**: 通常將一方的主鍵作為另一方的外部鍵，並對該外部鍵施加唯一性約束 (UNIQUE)。

2.  **一對多 (One-to-Many, 1:N)**
    *   **定義**: 表 A 中的一條記錄可以與表 B 中的多條記錄相關聯，但表 B 中的一條記錄只能與表 A 中的一條記錄相關聯。
    *   **例子**: 一位老師可以教多門課程，但一門課程通常只有一位主要老師（簡化情況）。一個部門有多名員工，但一個員工只屬於一個部門。
    *   **實現**: 將「一」方表格的主鍵作為「多」方表格的外部鍵。

3.  **多對多 (Many-to-Many, N:M)**
    *   **定義**: 表 A 中的一條記錄可以與表 B 中的多條記錄相關聯，同時表 B 中的一條記錄也可以與表 A 中的多條記錄相關聯。
    *   **例子**: 一位學生可以選修多門課程，一門課程可以被多位學生選修。這是前面學生和課程範例的關聯類型。
    *   **實現**: 需要引入一個**中間表（或稱連接表/關聯表）**。這個中間表至少包含兩個外部鍵，分別引用參與多對多關聯的兩個主表格的主鍵。

-----

### 資料庫操作：CRUD

CRUD 是指對資料庫中最基本的四種操作：
*   **Create (建立)**: 將新的數據添加到資料庫中。
*   **Read (讀取)**: 從資料庫中檢索數據。
*   **Update (更新)**: 修改資料庫中現有的數據。
*   **Delete (刪除)**: 從資料庫中移除數據。

這些操作是所有資料庫互動的基礎。

-----

### 資料庫語言：SQL

結構化查詢語言（Structured Query Language，簡稱 SQL）是與關聯式資料庫互動的標準語言。它主要分為以下幾種類型：

1.  **資料定義語言 (Data Definition Language, DDL)**
    *   用於定義資料庫的結構、表格、視圖、索引等。
    *   **常見語句**: `CREATE` (創建), `ALTER` (修改), `DROP` (刪除)。
    *   **例子**:
        ```sql
        CREATE TABLE Students (
            StudentID CHAR(4) PRIMARY KEY,
            Name VARCHAR(50) NOT NULL,
            Major VARCHAR(50)
        );
        ```

2.  **資料操作語言 (Data Manipulation Language, DML)**
    *   用於管理資料庫中的數據，即 CRUD 操作。
    *   **常見語句**: `INSERT` (插入), `SELECT` (查詢), `UPDATE` (更新), `DELETE` (刪除)。
    *   **例子**:
        ```sql
        INSERT INTO Students (StudentID, Name, Major) VALUES ('S001', '小明', 'CS');
        SELECT * FROM Students WHERE Major = 'CS';
        UPDATE Students SET Major = 'EE' WHERE StudentID = 'S001';
        DELETE FROM Students WHERE StudentID = 'S001';
        ```

3.  **資料控制語言 (Data Control Language, DCL)**
    *   用於管理使用者權限和資料庫存取控制。
    *   **常見語句**: `GRANT` (授權), `REVOKE` (撤銷授權)。
    *   **例子**:
        ```sql
        GRANT SELECT ON Students TO user1;
        REVOKE DELETE ON Students FROM user1;
        ```

4.  **交易控制語言 (Transaction Control Language, TCL)**
    *   用於管理交易（Transaction）的行為，確保資料的一致性和完整性。
    *   **常見語句**: `COMMIT` (提交), `ROLLBACK` (回滾), `SAVEPOINT` (儲存點)。
    *   **例子**:
        ```sql
        START TRANSACTION;
        UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 'A1';
        UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 'A2';
        COMMIT; -- 如果兩筆更新都成功，則提交；否則 ROLLBACK
        ```

-----

## 2. 資料庫的優勢與比較

### 與檔案系統的比較

在資料庫出現之前，應用程式通常直接使用檔案系統來儲存數據。資料庫管理系統 (DBMS) 解決了檔案系統的許多弊端。

| 特性             | 檔案系統 (File System)                    | 資料庫管理系統 (DBMS)                     |
| :--------------- | :---------------------------------------- | :---------------------------------------- |
| **數據冗餘 (Data Redundancy)** | 每個應用程式可能維護自己的數據副本，導致數據重複。 | 數據集中儲存，減少冗餘，透過關聯實現數據共享。 |
| **數據一致性 (Data Inconsistency)** | 冗餘數據更新不同步時，容易出現數據不一致。 | 透過一致性約束和交易管理，確保數據一致性。 |
| **數據完整性 (Data Integrity)** | 應用程式負責數據驗證，邏輯分散，難以統一約束。 | 透過 DDL 定義的完整性約束（PK, FK, CHECK 等）由 DBMS 統一管理和強制執行。 |
| **數據共享與並發 (Data Sharing & Concurrency)** | 難以有效支援多使用者同時存取，容易產生衝突或錯誤。 | 提供鎖機制和交易管理，允許多使用者安全並發存取。 |
| **數據安全性 (Data Security)** | 操作系統級別的安全控制，粒度較粗，難以實現精細權限。 | 提供細粒度的權限控制（使用者、角色、對象、操作），集中管理安全策略。 |
| **數據恢復 (Data Recovery)** | 需應用程式自行處理，故障恢復複雜且可能丟失數據。 | 提供備份、恢復、日誌機制，能在故障後恢復到一致狀態。 |
| **數據獨立性 (Data Independence)** | 應用程式與數據物理儲存緊密耦合。         | 透過三層架構實現物理和邏輯數據獨立性。     |

#### 與相鄰概念的關聯

檔案系統是作業系統提供的基本數據儲存服務。DBMS 則是在檔案系統之上，建立了一套更複雜、更智能的數據管理框架，解決了直接使用檔案系統進行數據管理的局限性。

-----

### ACID 特性

ACID 是衡量資料庫交易（Transaction）可靠性的四個重要特性，尤其在關聯式資料庫中至關重要。

1.  **原子性 (Atomicity)**
    *   **定義**: 一個交易是一個不可分割的工作單元。要麼交易中的所有操作都成功完成，要麼全部回滾（撤銷），回到交易開始前的狀態。
    *   **例子**: 銀行轉帳操作包含「從 A 帳戶扣款」和「向 B 帳戶存款」兩步。如果其中一步失敗，整個轉帳交易必須被撤銷，A 帳戶的錢不能扣，B 帳戶的錢也不能加。

2.  **一致性 (Consistency)**
    *   **定義**: 交易完成後，資料庫必須從一個有效狀態轉換到另一個有效狀態。這意味著交易不能破壞資料庫的完整性約束（例如，主鍵唯一性、外鍵約束、CHECK 條件）。
    *   **例子**: 轉帳後，總金額保持不變。如果轉帳導致帳戶餘額為負（而規定不能為負），則此交易違反了一致性，應被回滾。

3.  **隔離性 (Isolation)**
    *   **定義**: 多個併發交易之間互不干擾。每個交易感覺就像是單獨執行的一樣，不受其他交易的影響。
    *   **例子**: 當兩個人同時從同一個帳戶取錢時，資料庫必須確保這兩個操作不會互相影響，導致取錢數額重複計算或帳戶餘額錯誤。

4.  **持久性 (Durability)**
    *   **定義**: 一旦交易提交（Commit），其對資料庫的修改就是永久性的，即使系統發生故障（例如斷電），這些修改也不會丟失。
    *   **例子**: 銀行轉帳提交成功後，即使伺服器立即崩潰，帳戶餘額的更新也不會消失，在系統恢復後仍然存在。

#### 與相鄰概念的關聯

ACID 特性是**交易（Transaction）**的基石，而交易是確保資料庫在多使用者、高併發環境下數據正確和可靠的關鍵機制。沒有 ACID 特性，資料庫的可靠性將大打折扣。

-----

## 3. 進階資料庫概念

### 資料庫正規化 (Normalization)

#### 定義

正規化是一套用於**設計關聯式資料庫表格結構的過程**，旨在**減少數據冗餘**和**提高數據完整性**。它將大型表格分解成較小、管理更方便的表格，並定義它們之間的關聯。

#### 核心觀念

正規化通過一系列的「範式」（Normal Forms）來實現，最常見的有：

1.  **第一範式 (First Normal Form, 1NF)**
    *   **要求**: 每個欄位都是原子性的（不可再分割），並且不包含重複的組。
    *   **例子**: 如果一個欄位 `PhoneNumbers` 儲存了多個電話號碼，這就違反了 1NF。應該將每個電話號碼拆分為獨立的列或獨立的表格。

2.  **第二範式 (Second Normal Form, 2NF)**
    *   **要求**: 必須滿足 1NF，並且**所有非主鍵屬性都必須完全依賴於主鍵**（對於複合主鍵，非主鍵屬性不能只依賴於主鍵的一部分）。
    *   **例子**: 表格 `(OrderID, ProductID, OrderDate, ProductName, Price)`。如果 `(OrderID, ProductID)` 是複合主鍵，`ProductName` 只依賴於 `ProductID` (主鍵的一部分)，則違反了 2NF。應拆分為 `Orders(OrderID, OrderDate)` 和 `OrderDetails(OrderID, ProductID, Price)` 和 `Products(ProductID, ProductName)`。

3.  **第三範式 (Third Normal Form, 3NF)**
    *   **要求**: 必須滿足 2NF，並且**沒有非主鍵屬性對另一個非主鍵屬性有傳遞依賴**。
    *   **例子**: 表格 `(StudentID, Name, Major, MajorAdvisor)`。如果 `MajorAdvisor` 依賴於 `Major`，而 `Major` 又依賴於 `StudentID` (透過 `StudentID` 識別 `Major`)，那麼 `MajorAdvisor` 就是對 `StudentID` 的傳遞依賴。應該拆分為 `Students(StudentID, Name, Major)` 和 `Majors(Major, MajorAdvisor)`。

#### 目的與優點

*   **減少數據冗餘**: 避免重複儲存相同的數據，節省儲存空間。
*   **提高數據完整性**: 減少更新異常、插入異常和刪除異常。
    *   **更新異常**: 修改一個數據時，需要修改多處，容易導致不一致。
    *   **插入異常**: 某些數據在沒有其他數據的情況下無法插入。
    *   **刪除異常**: 刪除一條記錄時，意外地刪除了其他重要數據。
*   **數據結構清晰**: 使得資料庫設計更具邏輯性和易於理解。

#### 與相鄰概念的關聯

正規化是資料庫設計（Database Design）的核心環節，它直接影響了資料表的結構和關聯關係，進而影響了數據的儲存效率、查詢性能和維護成本。

-----

### 資料庫索引 (Index)

#### 定義

索引是**一種特殊的查找表，用於加速資料庫的數據檢索操作**。它類似於書的目錄或字典的索引，能幫助資料庫系統快速定位到所需數據，而無需掃描整個表格。

#### 核心觀念

*   **加速查詢**: 索引建立在一個或多個欄位上，當查詢條件包含這些欄位時，DBMS 可以直接跳轉到包含目標數據的儲存位置，大大減少查詢時間。
*   **代價**: 雖然索引能加速讀取，但會增加數據寫入（INSERT, UPDATE, DELETE）操作的開銷，因為每次數據變動時，索引本身也需要同步更新。同時，索引會佔用額外的磁碟空間。
*   **種類**:
    *   **B-Tree 索引**: 最常見的索引類型，適用於等值查詢、範圍查詢、排序等。
    *   **Hash 索引**: 適用於等值查詢，速度極快，但不適用於範圍查詢或排序。
    *   **全文索引**: 用於文本內容的模糊搜索。

#### 例子

假設我們有一個 `Employees` 表格，包含 `EmployeeID`, `Name`, `DepartmentID` 等欄位。如果我們經常查詢 `WHERE Name = '張三'`，那麼在 `Name` 欄位上建立索引將會顯著提高查詢速度。

```sql
CREATE INDEX idx_employee_name ON Employees (Name);
```

#### 與相鄰概念的關聯

索引是**資料庫性能優化**的重要手段。合理的索引設計能顯著提升查詢效率，但不當的索引也會降低寫入性能。它與**查詢優化器**緊密相關，查詢優化器會根據查詢語句和可用的索引，選擇最佳的執行計畫。

-----

### 交易 (Transaction)

#### 定義

交易是指**一系列邏輯上相關的資料庫操作，這些操作要麼全部成功，要麼全部失敗回滾**。一個交易是資料庫操作的最小工作單元。

#### 核心觀念

*   **原子性 (Atomicity)**: 如 ACID 特性所述，交易是不可分割的。
*   **一致性 (Consistency)**: 如 ACID 特性所述，交易後資料庫保持合法狀態。
*   **隔離性 (Isolation)**: 如 ACID 特性所述，併發交易互不影響。
*   **持久性 (Durability)**: 如 ACID 特性所述，提交的交易永久生效。

#### 交易的狀態

一個交易在生命週期中會經歷以下狀態：
*   **活動狀態 (Active)**: 交易正在執行。
*   **部分提交狀態 (Partially Committed)**: 交易的最後一個操作已經完成，但數據還未寫入持久化儲存。
*   **已提交狀態 (Committed)**: 交易成功完成，所有修改已永久儲存。
*   **失敗狀態 (Failed)**: 交易因某種錯誤（例如，數據衝突、系統故障）而無法繼續執行。
*   **已中止狀態 (Aborted)**: 交易失敗後，所有修改被撤銷（回滾），資料庫恢復到交易開始前的狀態。

#### 例子

一個轉帳操作：
1.  **開始交易**
2.  從 `AccountA` 扣除 $100
3.  向 `AccountB` 增加 $100
4.  **提交交易** (如果兩步都成功) 或 **回滾交易** (如果任何一步失敗)

這整個過程必須被視為一個單一的交易來處理，以確保資金不會憑空消失或產生。

#### 與相鄰概念的關聯

交易是實現資料庫**一致性、可靠性和並發控制**的核心機制。它是 ACID 特性的直接體現和實現方式。理解交易對於編寫穩健的資料庫應用程式至關重要。

-----

## 4. 常見錯誤與澄清

### 1. 誤將 Excel 檔案視為資料庫

*   **錯誤觀念**: 「我的數據都在 Excel 裡，這不就是資料庫嗎？」
*   **澄清**: Excel 是一個電子試算表工具，可以儲存表格數據，但它**缺乏 DBMS 的核心功能**，例如：
    *   **數據完整性控制**: 難以強制欄位型態、唯一性、外鍵關係。
    *   **多使用者存取與並發控制**: Excel 不適合多使用者同時修改，容易產生衝突和數據丟失。
    *   **安全性**: 缺乏精細的權限管理。
    *   **數據量限制**: 對於大量數據（數十萬行以上）處理效率低下。
    *   **數據獨立性**: 應用程式與數據緊密耦合。
    *   **交易管理**: 沒有 ACID 特性。
    *   因此，Excel 適合個人或小團隊進行少量、非並發的數據管理和分析，但不能替代資料庫系統。

### 2. 誤以為 NoSQL 就能完全取代 RDBMS

*   **錯誤觀念**: 「NoSQL 技術很潮，關聯式資料庫過時了，以後都用 NoSQL 就好。」
*   **澄清**: NoSQL 資料庫旨在解決 RDBMS 在特定場景（如海量數據、高併發、彈性擴展）下的局限性，但**它並非 RDBMS 的完全替代品**。
    *   **優勢不同**: NoSQL 通常在擴展性、靈活性方面表現更佳；RDBMS 在數據一致性、複雜查詢和交易完整性方面更為強大。
    *   **適用場景不同**:
        *   **RDBMS 適合**: 需要強一致性、複雜多表關聯查詢、明確的數據結構和 ACID 交易的應用（如銀行系統、訂單管理、人事系統）。
        *   **NoSQL 適合**: 需要高吞吐量、海量數據儲存、彈性數據模型、弱一致性可接受的應用（如日誌儲存、實時數據分析、內容管理、社交媒體）。
    *   **「最佳工具」原則**: 選擇哪種資料庫取決於具體的業務需求和技術場景，通常會根據需求混合使用。

### 3. 主鍵與唯一鍵的混淆

*   **錯誤觀念**: 「主鍵和唯一鍵不都是確保唯一性嗎？有什麼區別？」
*   **澄清**:
    *   **主鍵 (Primary Key)**:
        *   **唯一性 (Unique)**: 每個值必須唯一。
        *   **非空性 (Not Null)**: 值不能為空（NULL）。
        *   **一個表只能有一個主鍵**。
        *   其作用是唯一識別表中的每一條記錄。
        *   通常會自動創建叢集索引 (Clustered Index)，影響數據的物理儲存順序。
    *   **唯一鍵 (Unique Key)**:
        *   **唯一性 (Unique)**: 每個值必須唯一。
        *   **可空性 (Nullable)**: 可以包含一個或多個 NULL 值（但各個 DBMS 對於多個 NULL 值的處理可能不同，例如 MySQL 允許，SQL Server 僅允許一個 NULL）。
        *   **一個表可以有多個唯一鍵**。
        *   其作用是確保特定欄位的值在表內是唯一的，但通常不作為記錄的唯一識別。
        *   通常會創建非叢集索引 (Non-Clustered Index)。

### 4. 資料庫效能不佳只歸咎於硬體

*   **錯誤觀念**: 「資料庫跑得很慢，肯定是伺服器硬體不夠好，加記憶體換 SSD 就解決了。」
*   **澄清**: 雖然硬體是影響資料庫效能的重要因素，但**資料庫效能問題往往是多方面原因造成的**，不應單純歸咎於硬體。常見的軟體層面問題包括：
    *   **不合理的資料庫設計**: 缺乏正規化、不當的資料模型、主鍵外鍵定義不當。
    *   **缺乏索引或索引設計不佳**: 查詢常用欄位沒有索引，或索引過多導致寫入變慢。
    *   **低效的 SQL 語句**: 沒有優化的 `SELECT` 語句，使用 `SELECT *` 檢索不必要的數據，`JOIN` 操作不當，導致全表掃描。
    *   **配置不當的 DBMS 參數**: 記憶體分配、緩存大小、連接池設置不合理。
    *   **應用程式設計問題**: 頻繁開啟關閉連接、一次性檢索大量數據到客戶端、不當的 ORM 使用。
    *   **缺乏維護**: 沒有定期分析和優化表、重建索引。
    在考慮升級硬體之前，應首先進行效能監控和分析，找出真正的瓶頸。

-----

## 5. 小練習（附詳解）

### 小練習一：設計訂單系統資料庫

**情境**: 您需要設計一個簡單的電商訂單系統資料庫，包含客戶、產品和訂單資訊。

**需求**:
1.  儲存客戶資訊：客戶有唯一的 ID、姓名、Email 和聯絡電話。
2.  儲存產品資訊：產品有唯一的 ID、名稱、價格和庫存數量。
3.  儲存訂單資訊：訂單有唯一的 ID、訂單日期、總金額、以及哪個客戶下的訂單。
4.  儲存訂單詳情：每筆訂單包含多個產品，需要記錄每個產品的數量和當時的單價。

請設計這些資料表，定義其欄位、資料型態、主鍵（PK）和外部鍵（FK），並說明各表之間的關聯。

**詳解**:

**步驟 1: 識別實體與屬性**

*   **客戶 (Customers)**: `CustomerID`, `Name`, `Email`, `Phone`
*   **產品 (Products)**: `ProductID`, `ProductName`, `Price`, `StockQuantity`
*   **訂單 (Orders)**: `OrderID`, `OrderDate`, `TotalAmount`, `CustomerID`
*   **訂單詳情 (OrderItems)**: `OrderItemID`, `OrderID`, `ProductID`, `Quantity`, `UnitPriceAtOrder`

**步驟 2: 定義資料表結構與關聯**

1.  **Customers (客戶表)**
    *   **Purpose**: 儲存客戶基本資訊。
    *   **欄位**:
        *   `CustomerID` (INT, PRIMARY KEY, AUTO_INCREMENT): 客戶唯一識別碼，自動增長。
        *   `Name` (VARCHAR(100), NOT NULL): 客戶姓名。
        *   `Email` (VARCHAR(100), UNIQUE, NOT NULL): 客戶 Email，唯一且非空。
        *   `Phone` (VARCHAR(20)): 聯絡電話。
    *   **關聯**: 被 `Orders` 表引用。

2.  **Products (產品表)**
    *   **Purpose**: 儲存產品基本資訊。
    *   **欄位**:
        *   `ProductID` (INT, PRIMARY KEY, AUTO_INCREMENT): 產品唯一識別碼，自動增長。
        *   `ProductName` (VARCHAR(255), UNIQUE, NOT NULL): 產品名稱，唯一且非空。
        *   `Price` (DECIMAL(10, 2), NOT NULL): 產品單價，精度為 10 位數，小數點後 2 位。
        *   `StockQuantity` (INT, NOT NULL, DEFAULT 0): 庫存數量。
    *   **關聯**: 被 `OrderItems` 表引用。

3.  **Orders (訂單表)**
    *   **Purpose**: 儲存訂單主資訊。
    *   **欄位**:
        *   `OrderID` (INT, PRIMARY KEY, AUTO_INCREMENT): 訂單唯一識別碼，自動增長。
        *   `CustomerID` (INT, FOREIGN KEY REFERENCES Customers(CustomerID)): 關聯到下訂單的客戶。
        *   `OrderDate` (DATETIME, NOT NULL, DEFAULT CURRENT_TIMESTAMP): 訂單日期時間，預設為當前時間。
        *   `TotalAmount` (DECIMAL(10, 2), NOT NULL): 訂單總金額。
    *   **關聯**:
        *   `Orders` 與 `Customers` 之間是**多對一**關聯（一個客戶可以有多個訂單，一個訂單只屬於一個客戶）。
        *   `Orders` 與 `OrderItems` 之間是**一對多**關聯（一個訂單可以有多個訂單詳情項）。

4.  **OrderItems (訂單詳情表)**
    *   **Purpose**: 儲存每筆訂單中包含的產品及其數量和當時單價。這是處理 `Orders` 與 `Products` 之間**多對多**關聯的連結表。
    *   **欄位**:
        *   `OrderItemID` (INT, PRIMARY KEY, AUTO_INCREMENT): 訂單詳情項唯一識別碼。
        *   `OrderID` (INT, FOREIGN KEY REFERENCES Orders(OrderID)): 關聯到所屬的訂單。
        *   `ProductID` (INT, FOREIGN KEY REFERENCES Products(ProductID)): 關聯到訂單中的產品。
        *   `Quantity` (INT, NOT NULL): 該產品在訂單中的數量。
        *   `UnitPriceAtOrder` (DECIMAL(10, 2), NOT NULL): 產品下單時的單價（避免產品價格變動影響歷史訂單）。
    *   **複合唯一鍵**: `(OrderID, ProductID)` 應設為唯一，以防止同一產品在同一個訂單中重複出現多條訂單詳情。
    *   **關聯**:
        *   `OrderItems` 與 `Orders` 之間是**多對一**關聯。
        *   `OrderItems` 與 `Products` 之間是**多對一**關聯。

**步驟 3: 寫出 SQL DDL 語句 (MySQL 為例)**

```sql
-- 創建客戶表
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY AUTO_INCREMENT,
    Name VARCHAR(100) NOT NULL,
    Email VARCHAR(100) UNIQUE NOT NULL,
    Phone VARCHAR(20)
);

-- 創建產品表
CREATE TABLE Products (
    ProductID INT PRIMARY KEY AUTO_INCREMENT,
    ProductName VARCHAR(255) UNIQUE NOT NULL,
    Price DECIMAL(10, 2) NOT NULL,
    StockQuantity INT NOT NULL DEFAULT 0
);

-- 創建訂單表
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY AUTO_INCREMENT,
    CustomerID INT NOT NULL,
    OrderDate DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    TotalAmount DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

-- 創建訂單詳情表 (處理訂單與產品的多對多關係)
CREATE TABLE OrderItems (
    OrderItemID INT PRIMARY KEY AUTO_INCREMENT,
    OrderID INT NOT NULL,
    ProductID INT NOT NULL,
    Quantity INT NOT NULL,
    UnitPriceAtOrder DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID),
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID),
    UNIQUE (OrderID, ProductID) -- 確保同一訂單不會重複添加同一產品
);
```

### 小練習二：數據查詢

**情境**: 沿用上述訂單系統資料庫。

**需求**:
1.  插入一些測試數據。
2.  查詢所有客戶的訂單數量。
3.  查詢某個特定客戶的所有訂單，並顯示訂單中的所有產品及其數量。

**詳解**:

**步驟 1: 插入測試數據**

```sql
-- 插入客戶數據
INSERT INTO Customers (Name, Email, Phone) VALUES
('張三', 'zhangsan@example.com', '0912345678'),
('李四', 'lisi@example.com', '0923456789');

-- 插入產品數據
INSERT INTO Products (ProductName, Price, StockQuantity) VALUES
('筆記型電腦', 35000.00, 50),
('無線滑鼠', 800.00, 200),
('機械鍵盤', 2500.00, 100);

-- 插入訂單數據 (假設張三(CustomerID=1)下了一個訂單，李四(CustomerID=2)下了一個訂單)
INSERT INTO Orders (CustomerID, TotalAmount) VALUES
(1, 35800.00), -- 張三的訂單
(2, 2500.00);  -- 李四的訂單

-- 插入訂單詳情數據
-- 張三的訂單 (OrderID=1) 包含筆記型電腦和無線滑鼠
INSERT INTO OrderItems (OrderID, ProductID, Quantity, UnitPriceAtOrder) VALUES
(1, 1, 1, 35000.00), -- 筆記型電腦
(1, 2, 1, 800.00);   -- 無線滑鼠

-- 李四的訂單 (OrderID=2) 包含機械鍵盤
INSERT INTO OrderItems (OrderID, ProductID, Quantity, UnitPriceAtOrder) VALUES
(2, 3, 1, 2500.00);
```

**步驟 2: 查詢所有客戶的訂單數量**

```sql
SELECT
    c.Name AS CustomerName,
    COUNT(o.OrderID) AS OrderCount
FROM
    Customers c
LEFT JOIN
    Orders o ON c.CustomerID = o.CustomerID
GROUP BY
    c.Name
ORDER BY
    OrderCount DESC;
```
*   **解釋**:
    *   使用 `LEFT JOIN` 將 `Customers` 表與 `Orders` 表連接，即使沒有訂單的客戶也會被列出。
    *   `ON c.CustomerID = o.CustomerID` 指定連接條件。
    *   `COUNT(o.OrderID)` 計算每個客戶的訂單數量。
    *   `GROUP BY c.Name` 將結果按客戶姓名分組。
    *   `AS CustomerName`, `AS OrderCount` 為結果欄位取別名，增加可讀性。

**步驟 3: 查詢特定客戶（例如：張三，其 CustomerID=1）的所有訂單，並顯示訂單中的所有產品及其數量**

```sql
SELECT
    c.Name AS CustomerName,
    o.OrderID,
    o.OrderDate,
    o.TotalAmount,
    p.ProductName,
    oi.Quantity,
    oi.UnitPriceAtOrder
FROM
    Customers c
JOIN
    Orders o ON c.CustomerID = o.CustomerID
JOIN
    OrderItems oi ON o.OrderID = oi.OrderID
JOIN
    Products p ON oi.ProductID = p.ProductID
WHERE
    c.CustomerID = 1 -- 查詢 CustomerID 為 1 的客戶 (張三)
ORDER BY
    o.OrderDate DESC, o.OrderID, p.ProductName;
```
*   **解釋**:
    *   使用多個 `JOIN` 子句將 `Customers`, `Orders`, `OrderItems`, `Products` 這四個相關的表連接起來。
    *   `ON` 子句定義了各表之間的連接條件。
    *   `WHERE c.CustomerID = 1` 過濾出 CustomerID 為 1 的客戶（張三）的訂單。
    *   選取所需的欄位，並為部分欄位取別名。
    *   `ORDER BY` 語句用於對結果進行排序，使得同一個訂單內的產品按名稱排序。

-----

## 6. 延伸閱讀/參考

*   **資料庫系統概念 (Database System Concepts)** by Silberschatz, Korth, and Sudarshan: 資料庫領域的經典教科書，涵蓋了廣泛的理論和實踐知識。
*   **SQL 入門教學**: W3Schools SQL Tutorial 或 Codecademy SQL Course。
*   **關聯式資料庫設計原則**: 深入了解正規化範式 (1NF, 2NF, 3NF, BCNF) 的詳細規則和實踐。
*   **不同 DBMS 的官方文件**:
    *   [MySQL Documentation](https://dev.mysql.com/doc/)
    *   [PostgreSQL Documentation](https://www.postgresql.org/docs/)
    *   [MongoDB Documentation](https://www.mongodb.com/docs/)
    *   [Redis Documentation](https://redis.io/docs/)
*   **雲端資料庫服務**: 了解 AWS RDS, Google Cloud SQL, Azure SQL Database 等託管資料庫服務。
*   **資料庫效能調優 (Database Performance Tuning)**: 學習如何分析查詢計畫、優化索引、調整伺服器參數等。