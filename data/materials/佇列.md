# 佇列 (Queue)

佇列（Queue）是一種重要的抽象資料類型 (Abstract Data Type, ADT)，它模擬了日常生活中「排隊」的行為。在電腦科學中，佇列廣泛應用於作業系統、網路傳輸、演算法等領域，是理解資料結構與演算法的基石之一。

---

### 1. 核心概念與定義

#### 1.1 什麼是佇列？

佇列是一種線性資料結構，其特點是資料的**插入 (Insertion)** 和**刪除 (Deletion)** 發生在不同的端點。這使得佇列遵循「**先進先出 (First-In, First-Out, FIFO)**」的原則。想像一下人們在銀行櫃檯前排隊：第一個排隊的人會是第一個獲得服務的人。

*   **FIFO 原則**: 最早進入佇列的元素，會是最早離開佇列的元素。

#### 1.2 佇列的基本操作

一個典型的佇列資料結構支援以下基本操作：

*   `enqueue(item)` / `push(item)`：將一個元素 `item` 加入到佇列的**尾端 (rear/tail)**。
*   `dequeue()` / `pop()`：從佇列的**前端 (front/head)** 移除並返回一個元素。如果佇列為空，此操作通常會拋出錯誤或返回特殊值。
*   `front()` / `peek()`：返回佇列前端的元素，但不將其移除。如果佇列為空，此操作通常會拋出錯誤或返回特殊值。
*   `isEmpty()`：檢查佇列是否為空。如果為空，返回 `true`；否則返回 `false`。
*   `size()`：返回佇列中元素的數量。

-----

### 2. 典型例子與轉換/推導

#### 2.1 日常生活中的佇列

最直觀的例子就是現實生活中的各種「排隊」：

*   **銀行或超市排隊**: 客戶一個接一個地排隊，最前面的人最先得到服務。
*   **自助餐取餐**: 人們依序從餐檯取餐，第一個排隊的人第一個拿到食物。
*   **電話客服等待線**: 來電者依序等待客服人員接聽，先撥打的人會先被服務。

#### 2.2 電腦科學中的應用

在電腦科學中，佇列扮演著關鍵角色：

*   **作業系統排程**:
    *   CPU 排程器使用佇列來管理等待執行的行程 (processes)。當多個行程需要 CPU 資源時，它們會被放入一個佇列，按照先來先服務 (First-Come, First-Served, FCFS) 的原則來分配 CPU 時間。
    *   I/O 請求 (例如磁碟讀寫) 也常用佇列來處理。
*   **廣度優先搜尋 (BFS) 演算法**:
    *   BFS 是一種圖形遍歷演算法，它使用佇列來儲存待訪問的節點。它會先訪問離起點近的節點，再訪問遠的節點，這正是 FIFO 的體現。
*   **緩衝區 (Buffer)**:
    *   在資料傳輸或處理中，當生產者產生資料的速度快於消費者處理資料的速度時，佇列可以用作緩衝區，暫存這些資料，以平滑資料流。例如，印表機佇列 (print queue) 用來存放待列印的文件。
*   **網際網路路由**: 路由器內部使用佇列來緩衝和轉發網路封包。

#### 2.3 佇列的實現方式

佇列可以透過多種底層資料結構來實現，最常見的兩種是：

*   **陣列 (Array)**：
    *   使用一個固定大小的陣列來儲存元素。需要維護兩個指標：一個指向佇列的前端 (front)，另一個指向佇列的後端 (rear)。
    *   入隊時，`rear` 向後移動並插入元素。出隊時，`front` 向後移動並返回元素。
    *   缺點是當 `rear` 到達陣列末端時，即使前面有空位，也可能無法再插入元素（「假溢位」），需要特別處理，例如使用循環佇列。
*   **鏈結串列 (Linked List)**：
    *   使用節點 (Node) 連接起來的串列來儲存元素。每個節點包含資料和指向下一個節點的指針。
    *   通常維護一個指向前端節點的指針和一個指向後端節點的指針。
    *   入隊時，在後端新增一個節點。出隊時，移除前端的節點。
    *   優點是動態大小，不會有固定容量的限制（除非記憶體不足）。

-----

### 3. 與相鄰概念的關聯

#### 3.1 佇列與堆疊 (Stack)

佇列和堆疊是兩種最基本的線性資料結構，但它們的核心操作原則完全相反：

| 特性     | 佇列 (Queue)       | 堆疊 (Stack)       |
| :------- | :----------------- | :----------------- |
| **原則** | 先進先出 (FIFO)    | 後進先出 (LIFO)    |
| **插入** | `enqueue()` / `push()` 在尾端 (rear) | `push()` 在頂端 (top) |
| **刪除** | `dequeue()` / `pop()` 在前端 (front) | `pop()` 在頂端 (top) |
| **應用** | 排程、BFS、緩衝區  | 函數呼叫、運算式求值、DFS |
| **類比** | 排隊               | 疊盤子             |

#### 3.2 佇列與串列 (List)

串列（例如陣列串列或鏈結串列）是一種更通用的線性資料結構，它允許在任意位置進行插入、刪除和訪問。佇列可以看作是串列的一種「受限」應用：

*   **串列 (List)**: 提供任意位置的插入、刪除、訪問。
*   **佇列 (Queue)**: 僅允許在特定兩端（前端和尾端）進行插入和刪除，且必須遵循 FIFO 原則。

可以說，佇列是基於串列實現的一種「抽象資料類型」，它限制了對串列的操作方式，以達到特定的行為模式 (FIFO)。

-----

### 4. 進階內容

#### 4.1 循環佇列 (Circular Queue)

當使用固定大小的陣列來實現佇列時，可能會遇到「假溢位」問題：即使陣列前端有空位，但如果 `rear` 指針已經到達陣列末端，就無法再執行 `enqueue` 操作。

循環佇列解決了這個問題，它將陣列的尾部和頭部連接起來，形成一個邏輯上的環形結構。當 `rear` 指針到達陣列末端後，如果陣列前端有空位，它會「繞回」到陣列開頭的位置。

**實現思路：**

1.  使用一個陣列 `arr` 和兩個指標 `front` 和 `rear`。
2.  `enqueue` 操作：`rear = (rear + 1) % capacity`。
3.  `dequeue` 操作：`front = (front + 1) % capacity`。
4.  需要額外處理佇列滿和佇列空的判斷，例如：
    *   額外使用一個計數器 `count` 記錄元素數量。
    *   或在陣列中保留一個空位來區分滿和空。

#### 4.2 雙向佇列 (Deque - Double-Ended Queue)

雙向佇列是佇列的變種，它允許在佇列的**兩端**進行插入和刪除操作。這表示它結合了佇列和堆疊的一些特性。

*   可以在前端 `push_front` 和 `pop_front`。
*   可以在尾端 `push_back` 和 `pop_back`。

它通常用於那些需要從兩端操作資料的演算法中，例如某些滑動視窗問題。

#### 4.3 優先級佇列 (Priority Queue)

雖然名稱中有「佇列」，但優先級佇列的核心原則**不是 FIFO**。它是一種特殊類型的佇列，其中每個元素都帶有一個優先級。每次出隊時，總是移除**優先級最高**（或最低，取決於實現）的元素，而不是最先進入的元素。

優先級佇列通常使用**堆積 (Heap)** 資料結構來實現，而不是普通的陣列或鏈結串列。

-----

### 5. 常見錯誤與澄清

1.  **混淆入隊與出隊的方向**：
    *   **錯誤**：認為入隊和出隊都在同一端進行。
    *   **澄清**：入隊在尾端，出隊在前端。這是 FIFO 原則的基礎。
2.  **陣列實現時的「假溢位」**：
    *   **錯誤**：在使用陣列實現佇列時，一旦 `rear` 到達陣列末端，就認為佇列已滿，即使陣列開頭有空位。
    *   **澄清**：這是假溢位。應採用循環佇列的策略，讓 `rear` 指針能繞回陣列開頭的空位。
3.  **認為所有「排隊」都是佇列**：
    *   **錯誤**：將所有表示「等待」或「序列」的資料結構都稱為佇列。
    *   **澄清**：佇列特指遵循 FIFO 原則的資料結構。例如，優先級佇列雖然也是「排隊」，但其出隊順序是基於優先級而非進入時間，因此不是傳統意義上的 FIFO 佇列。
4.  **對 `front()` 和 `dequeue()` 的誤解**：
    *   **錯誤**：認為 `front()` 和 `dequeue()` 是相同的操作。
    *   **澄清**：`front()` 僅查看隊頭元素，不移除它；`dequeue()` 會移除隊頭元素並返回它。

-----

### 6. 小練習（附詳解）

#### 小練習 1：佇列操作模擬

假設有一個空的整數佇列，請模擬以下一系列操作，並在每次 `dequeue` 或 `front` 操作後寫出返回的值，以及所有操作完成後佇列的最終狀態。

1.  `enqueue(10)`
2.  `enqueue(20)`
3.  `front()`
4.  `enqueue(30)`
5.  `dequeue()`
6.  `enqueue(40)`
7.  `dequeue()`
8.  `front()`
9.  `dequeue()`
10. `isEmpty()`
11. `dequeue()`

**詳解：**

1.  **`enqueue(10)`**: 佇列: `[10]`
2.  **`enqueue(20)`**: 佇列: `[10, 20]`
3.  **`front()`**: 返回 `10`。佇列: `[10, 20]`
4.  **`enqueue(30)`**: 佇列: `[10, 20, 30]`
5.  **`dequeue()`**: 返回 `10`。佇列: `[20, 30]`
6.  **`enqueue(40)`**: 佇列: `[20, 30, 40]`
7.  **`dequeue()`**: 返回 `20`。佇列: `[30, 40]`
8.  **`front()`**: 返回 `30`。佇列: `[30, 40]`
9.  **`dequeue()`**: 返回 `30`。佇列: `[40]`
10. **`isEmpty()`**: 返回 `false`。佇列: `[40]`
11. **`dequeue()`**: 返回 `40`。佇列: `[]` (空)

**最終狀態**: 佇列為空 `[]`。

-----

#### 小練習 2：判斷佇列序列

給定一個空的佇列和一系列入隊 (E) 及出隊 (D) 操作。請判斷以下給出的出隊序列是否可能發生。如果可能，請給出一個操作順序；如果不可能，請解釋原因。

**操作序列:** E(1), E(2), D, E(3), D, E(4), D

**假設的出隊序列 (依序返回的值):** 1, 3, 4

**詳解：**

**判斷是否可能:** 可能。

**操作順序及佇列狀態：**

1.  **E(1)**：佇列: `[1]`
2.  **E(2)**：佇列: `[1, 2]`
3.  **D**：返回 `1`。佇列: `[2]` (此時出隊了 `1`，符合預期序列的第一個元素)
4.  **E(3)**：佇列: `[2, 3]`
5.  **D**：返回 `2`。佇列: `[3]` (此時出隊了 `2`，不符合預期序列的第二個元素 `3`。這說明我們前面對操作序列的解讀或假設是錯誤的。)

讓我們重新思考，給定的 **操作序列** 是固定的：`E(1), E(2), D, E(3), D, E(4), D`。
而 **假設的出隊序列** 是 `1, 3, 4`。我們需要檢查這個出隊序列是否能由給定的操作序列產生。

**重新推導：**

1.  **E(1)**：佇列: `[1]`
2.  **E(2)**：佇列: `[1, 2]`
3.  **D**：從佇列前端取出 `1`。**輸出: `1`**。佇列: `[2]`
4.  **E(3)**：佇列: `[2, 3]`
5.  **D**：從佇列前端取出 `2`。**輸出: `2`**。佇列: `[3]`
6.  **E(4)**：佇列: `[3, 4]`
7.  **D**：從佇列前端取出 `3`。**輸出: `3`**。佇列: `[4]`

**結論：**

根據給定的操作序列 `E(1), E(2), D, E(3), D, E(4), D`，實際產生的出隊序列是 `1, 2, 3`。
而題目中假設的出隊序列是 `1, 3, 4`。

因為 `1, 2, 3` 不等於 `1, 3, 4`，所以**不可能**產生 `1, 3, 4` 這個出隊序列。

**解釋原因:**
在步驟 5 `D` 操作時，佇列前端的元素是 `2`，所以必須出隊 `2`。然而，預期的出隊序列是 `1, 3, 4`，這就要求在第二次 `D` 操作時出隊 `3`。這與佇列的 FIFO 原則相矛盾，因為 `2` 是在 `3` 之前入隊且仍在佇列中的。

-----

### 7. 延伸閱讀/參考

*   **經典資料結構與演算法書籍**：
    *   *Introduction to Algorithms* by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein (簡稱 CLRS)
    *   *Data Structures and Algorithms in Java/Python/C++* by Michael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser
*   **線上教學資源**：
    *   LeetCode、HackerRank 等平台上的資料結構與演算法專題。
    *   GeeksforGeeks、TutorialsPoint 等網站上的佇列教學。
*   **程式語言官方文件**：
    *   不同程式語言（如 Java 的 `java.util.Queue` 介面、Python 的 `collections.deque`、C++ 的 `std::queue` 和 `std::deque`）的官方文件，了解其具體實作與 API。
*   **演算法應用**：
    *   學習廣度優先搜尋 (BFS) 演算法，這是佇列在圖形遍歷中最經典的應用之一。
    *   研究作業系統中的排程演算法，了解佇列如何管理系統資源。