# 4-1 物件導向設計與實務

## ### 1. 核心概念與定義

物件導向程式設計（Object-Oriented Programming, OOP）是一種程式設計的典範，它將軟體系統的設計與開發，從傳統的以功能為導向，轉變為以「物件」為中心。這種典範的核心思想是將資料（屬性）與操作這些資料的行為（方法）封裝在一起，形成一個個獨立的「物件」，並讓這些物件之間相互協作來完成系統的功能。

#### #### 1.1 什麼是物件導向？

-   **定義**：物件導向程式設計是一種將軟體系統組織成獨立、互動的物件集合的程式設計範式。它強調透過建立物件來模型化真實世界的實體，並讓這些物件彼此傳遞訊息以執行任務。
-   **核心觀念**：
    -   **模組化 (Modularity)**：將複雜系統分解為獨立且可管理的模組（即物件），每個物件負責特定的職責。
    -   **抽象化 (Abstraction)**：只呈現必要資訊給外部，隱藏內部複雜的實作細節。
    -   **關注點分離 (Separation of Concerns)**：將不同職責的程式碼分開處理，提高可讀性和可維護性。
-   **與程序導向的關聯**：傳統的程序導向（Procedural Programming）以函數為中心，資料與函式通常是分離的。物件導向則將資料和處理資料的函式（稱為方法）緊密綁定在物件中，提供更自然、更易於理解和維護的程式結構。

-----

#### #### 1.2 物件 (Object) 與 類別 (Class)

物件導向的核心是物件，而類別則是生成物件的藍圖。

-   **類別 (Class)**
    -   **定義**：類別是一個抽象的範本、藍圖或原型，它定義了某種特定類型物件的共同屬性（資料）和行為（方法）。類別本身不佔用記憶體，它只是描述物件的結構。
    -   **例子**：我們可以定義一個 `Car`（汽車）類別。這個類別可能包含 `brand`（品牌）、`model`（型號）、`color`（顏色）等屬性，以及 `startEngine()`（啟動引擎）、`accelerate()`（加速）、`brake()`（煞車）等行為。
-   **物件 (Object)**
    -   **定義**：物件是類別的一個具體實例（Instance）。它是一個具有特定狀態（屬性值）和行為的實體，佔用實際的記憶體空間。
    -   **例子**：根據 `Car` 類別，我們可以創建一個 `myCar` 物件，它的屬性可能是 `brand="Toyota"`、`model="Camry"`、`color="Blue"`。我們可以對 `myCar` 物件執行 `startEngine()` 等方法。
-   **與相鄰概念的關聯**：類別是物件的設計圖，物件是類別的實體化結果。沒有類別，就無法定義物件的結構；沒有物件，類別就只是空泛的概念。

-----

#### #### 1.3 物件導向三大特性

物件導向程式設計主要基於以下三個核心特性：封裝、繼承和多型。它們共同提供了強大的組織和重用機制。

##### ##### 1.3.1 封裝 (Encapsulation)

-   **定義**：封裝是將物件的資料（屬性）和操作這些資料的方法（行為）綁定在一起，形成一個獨立的單元。同時，它也意味著對外部隱藏物件內部的實作細節，只透過定義好的介面（公開方法）與外部互動。
-   **核心觀念**：
    -   **資訊隱藏 (Information Hiding)**：物件的內部狀態不應直接從外部訪問，只能透過物件提供的方法來修改或讀取。這保護了資料的完整性，防止不當修改。
    -   **降低耦合**：物件的內部變更不會影響到外部使用它的程式碼，只要公開介面不變。
-   **例子**：
    考慮一個 `BankAccount` 類別。它有一個 `balance`（餘額）屬性。為了確保餘額的正確性，我們不希望外部程式直接修改 `balance`。因此，我們會將 `balance` 設為私有（或受保護），並提供 `deposit(amount)`（存款）和 `withdraw(amount)`（提款）等公開方法來操作餘額。
    ```python
    class BankAccount:
        def __init__(self, initial_balance):
            self.__balance = initial_balance # 私有屬性，前面加兩個底線

        def deposit(self, amount):
            if amount > 0:
                self.__balance += amount
                print(f"存款 {amount} 元成功。新餘額: {self.__balance} 元。")
            else:
                print("存款金額必須大於零。")

        def withdraw(self, amount):
            if amount > 0 and self.__balance >= amount:
                self.__balance -= amount
                print(f"提款 {amount} 元成功。新餘額: {self.__balance} 元。")
            elif amount <= 0:
                print("提款金額必須大於零。")
            else:
                print("餘額不足。")

        def get_balance(self):
            return self.__balance

    # 外部程式無法直接存取 __balance
    # my_account = BankAccount(1000)
    # print(my_account.__balance) # 這會導致錯誤
    ```
-   **與相鄰概念的關聯**：封裝是實現模組化的基礎，它確保物件的完整性和獨立性，為後續的繼承和多型提供了穩固的基石。

##### ##### 1.3.2 繼承 (Inheritance)

-   **定義**：繼承是一種機制，允許一個類別（稱為子類、衍生類或派生類）繼承另一個類別（稱為父類、基底類或超類）的屬性與行為。子類可以重用父類的程式碼，並在此基礎上添加新的功能或修改現有功能。
-   **核心觀念**：
    -   **程式碼重用 (Code Reusability)**：避免重複撰寫相同的程式碼，提高開發效率。
    -   **建立階層關係 (Hierarchy)**：反映真實世界中「是一種 (is-a)」的關係，例如「狗是一種動物」。
    -   **擴展性**：在不修改父類的情況下，透過創建子類來擴展功能。
-   **例子**：
    我們可以有一個 `Animal`（動物）父類，它可能有一個 `speak()`（發聲）方法。然後，我們可以創建 `Dog`（狗）和 `Cat`（貓）子類，它們都繼承了 `Animal` 的特性，但可以覆寫 `speak()` 方法來發出不同的聲音。
    ```python
    class Animal:
        def __init__(self, name):
            self.name = name

        def speak(self):
            return "某種動物發出聲音"

    class Dog(Animal): # Dog 繼承自 Animal
        def __init__(self, name, breed):
            super().__init__(name) # 呼叫父類別的建構子
            self.breed = breed

        def speak(self): # 覆寫父類別的方法
            return "汪汪！"

    class Cat(Animal): # Cat 繼承自 Animal
        def __init__(self, name, color):
            super().__init__(name)
            self.color = color

        def speak(self): # 覆寫父類別的方法
            return "喵喵~"

    # my_dog = Dog("小黑", "柴犬")
    # print(f"{my_dog.name}: {my_dog.speak()}") # 輸出：小黑: 汪汪！

    # my_cat = Cat("咪咪", "白")
    # print(f"{my_cat.name}: {my_cat.speak()}") # 輸出：咪咪: 喵喵~
    ```
-   **與相鄰概念的關聯**：繼承是實現多型的基礎之一，它建立了類別之間的泛化與特化關係。然而，過度使用繼承可能導致緊密耦合，需要謹慎權衡。

##### ##### 1.3.3 多型 (Polymorphism)

-   **定義**：多型意指「多種形態」，在物件導向中，它允許不同的物件對同一訊息（方法呼叫）產生不同的反應。簡單來說，就是「一個介面，多種實作」。
-   **核心觀念**：
    -   **介面統一，行為多樣**：程式碼可以統一地處理不同類型的物件，而無需知道其具體類型，只要這些物件實作了相同的介面或繼承了共同的父類。
    -   **彈性與擴展性**：當有新的物件類型加入時，只要它符合既定的介面，現有的程式碼就可以直接處理，無需修改。
-   **例子**：
    延續上面的 `Animal` 例子。由於 `Dog` 和 `Cat` 都繼承了 `Animal` 並實作了 `speak()` 方法，我們可以創建一個動物列表，並迭代呼叫每個動物的 `speak()` 方法，每個動物都會發出符合自己種類的聲音。
    ```python
    # 延續上面的 Animal, Dog, Cat 類別定義

    def animal_sound(animal):
        print(f"{animal.name} 說: {animal.speak()}")

    my_dog = Dog("小黑", "柴犬")
    my_cat = Cat("咪咪", "白")
    some_animal = Animal("匿名動物")

    animals = [my_dog, my_cat, some_animal]

    for animal in animals:
        animal_sound(animal)
    # 輸出：
    # 小黑 說: 汪汪！
    # 咪咪 說: 喵喵~
    # 匿名動物 說: 某種動物發出聲音
    ```
    在這裡，`animal_sound` 函數並不需要知道傳入的是 `Dog`、`Cat` 還是 `Animal` 的實例，它只需知道這些物件都具有 `speak()` 方法，這就是多型的體現。
-   **與相鄰概念的關聯**：多型通常透過繼承和介面（後述）來實現。它是物件導向設計中實現彈性和可擴展性的關鍵，使得系統更易於維護和演進。

-----

## ### 2. 典型例子與轉換

理解物件導向的思考方式，是從程式導向思維轉變的關鍵。

#### #### 2.1 從程序導向到物件導向的思考轉換

-   **程序導向思維**：
    -   關注點：如何「做」一件事（函式、步驟）。
    -   組織方式：一系列的函式，資料獨立於函式。
    -   缺點：當資料結構改變時，許多操作它的函式都需要修改；資料的安全性較難保證。
-   **物件導向思維**：
    -   關注點：有哪些「物件」（實體），它們有什麼「屬性」，能做什麼「行為」。
    -   組織方式：將資料和行為捆綁在物件中，物件之間透過訊息傳遞協作。
    -   優點：高內聚、低耦合，資料安全，易於擴展和維護。

-   **例子：計算圓形的面積和周長**

    -   **程序導向實現**：
        ```python
        import math

        def calculate_circle_area(radius):
            return math.pi * radius * radius

        def calculate_circle_circumference(radius):
            return 2 * math.pi * radius

        # 使用
        r = 5
        area = calculate_circle_area(r)
        circumference = calculate_circle_circumference(r)
        print(f"圓形半徑 {r} 的面積是: {area:.2f}")
        print(f"圓形半徑 {r} 的周長是: {circumference:.2f}")
        ```
        這裡，`radius` 是獨立的資料，函式 `calculate_circle_area` 和 `calculate_circle_circumference` 操作這個資料。

    -   **物件導向實現**：
        ```python
        import math

        class Circle:
            def __init__(self, radius):
                if radius <= 0:
                    raise ValueError("半徑必須大於零。")
                self.__radius = radius # 封裝半徑

            def get_area(self):
                return math.pi * self.__radius * self.__radius

            def get_circumference(self):
                return 2 * math.pi * self.__radius

            def get_radius(self):
                return self.__radius

        # 使用
        my_circle = Circle(5) # 創建一個圓形物件
        print(f"圓形半徑 {my_circle.get_radius()} 的面積是: {my_circle.get_area():.2f}")
        print(f"圓形半徑 {my_circle.get_radius()} 的周長是: {my_circle.get_circumference():.2f}")

        # 可以創建另一個圓形物件
        another_circle = Circle(10)
        print(f"另一個圓形半徑 {another_circle.get_radius()} 的面積是: {another_circle.get_area():.2f}")
        ```
        在這裡，`Circle` 是一個類別，它將半徑 (`__radius`) 和計算面積/周長的方法 (`get_area()`, `get_circumference()`) 封裝在一起。每個 `Circle` 物件都擁有自己的半徑和計算能力。這使得程式碼更貼近真實世界中「圓」這個概念。

-----

#### #### 2.2 物件導向設計原則簡介 (SOLID 原則)

為了寫出高品質、可維護、可擴展的物件導向程式碼，遵循一些設計原則至關重要。SOLID 原則是由 Robert C. Martin (Uncle Bob) 提出的五個核心原則的縮寫，是物件導向設計的基石。

1.  **S (Single Responsibility Principle, SRP) - 單一職責原則**
    -   一個類別只應有一個改變的理由。換句話說，一個類別應該只負責一件事。
    -   目標：降低耦合，提高內聚。
    -   例子：一個處理訂單的類別不應該同時負責訂單的顯示和日誌記錄。

2.  **O (Open/Closed Principle, OCP) - 開放封閉原則**
    -   軟體實體（類別、模組、函式等）應該對擴展開放，對修改封閉。
    -   目標：在不修改現有程式碼的情況下增加新功能。通常透過繼承和多型（介面/抽象類別）實現。
    -   例子：一個報告生成器應該能夠生成不同格式的報告，而無需修改其核心邏輯。

3.  **L (Liskov Substitution Principle, LSP) - Liskov 替換原則**
    -   子類別必須能夠替換其父類別，並且程式不會發生錯誤。換句話說，任何接受父類別物件的地方，都能透明地接受子類別物件。
    -   目標：確保繼承的正確使用，維持多型的有效性。
    -   例子：如果有一個 `Bird` 類別和一個 `FlyableBird` 子類，那麼`Penguin`（企鵝）就不應該是 `FlyableBird` 的子類，因為企鵝不能飛，這會破壞替換原則。

4.  **I (Interface Segregation Principle, ISP) - 介面隔離原則**
    -   客戶端不應該被強制依賴它們不使用的介面。
    -   目標：避免「胖介面」，將大的介面分解成更小、更專用的介面。
    -   例子：一個 `Workable` 介面不應該同時包含 `eat()` 和 `sleep()` 方法，如果不是所有工作者都只會工作。應該是 `Workable` 介面給工作者，`Eatable` 介面給可以吃的，`Sleepable` 介面給可以睡的。

5.  **D (Dependency Inversion Principle, DIP) - 依賴反轉原則**
    -   高層模組不應依賴低層模組，兩者都應依賴抽象。抽象不應依賴於細節，細節應依賴於抽象。
    -   目標：降低高層模組和低層模組之間的耦合，提高彈性和可測試性。
    -   例子：一個 `LightSwitch` 類別不應該直接依賴於一個具體的 `LightBulb` 類別，而應該依賴於一個抽象的 `SwitchableDevice` 介面。

-   **推導與關聯**：SOLID 原則並非獨立存在，它們相互支持，共同指導開發者設計出更健壯、更靈活的物件導向系統。遵循這些原則，可以更好地應用物件導向的三大特性，從而應對不斷變化的需求。

-----

## ### 3. 與相鄰概念的關聯

物件導向設計並非孤立的技術，它與許多軟體開發的概念和實踐緊密相關。

#### #### 3.1 與「模組化程式設計」的關係

-   **核心觀念**：模組化程式設計旨在將一個大型程式分解成相互獨立、可組合的較小單元（模組）。每個模組負責特定的功能，並提供明確的介面與其他模組互動。
-   **物件導向的體現**：物件導向是實現高效模組化的一種強大方式。
    -   **物件即模組**：每個物件或類別都可以看作一個模組，它封裝了自己的資料和行為。
    -   **更強的內聚**：物件將資料與操作資料的方法綁定在一起，使得相關的程式碼更加集中，提高了模組的內聚性。
    -   **更低的耦合**：透過封裝和介面，物件之間的依賴關係被明確且限制，降低了模組之間的耦合度，使得修改一個模組時，對其他模組的影響最小。
-   **關聯**：物件導向提供了比純粹的函式模組化更細粒度、更具語義的模組化方式，它不僅是程式碼的簡單分組，更是對問題領域中實體的抽象和建模。

-----

#### #### 3.2 與「設計模式」的關係

-   **核心觀念**：設計模式（Design Patterns）是解決軟體設計中常見問題的通用、可重用的解決方案。它們是經驗法則的總結，通常以類別和物件之間如何互動來描述。
-   **物件導向的體現**：絕大多數的設計模式都是基於物件導向的原則和特性（如封裝、繼承、多型）來構建的。
    -   **利用多型**：策略模式（Strategy Pattern）利用多型來讓物件在執行時動態切換不同的演算法。
    -   **利用繼承**：模板方法模式（Template Method Pattern）利用繼承來定義演算法的骨架，而將具體步驟的實作延遲到子類。
    -   **利用封裝**：工廠模式（Factory Pattern）將物件的創建邏輯封裝起來，隱藏了複雜的創建過程。
-   **關聯**：物件導向是設計模式的基礎語言和工具集。學習設計模式可以幫助開發者更好地應用物件導向的原則，設計出更靈活、更具彈性、更易於維護和擴展的系統架構。設計模式提供了在特定情境下應用物件導向原則的最佳實踐。

-----

#### #### 3.3 與「軟體工程」的關係

-   **核心觀念**：軟體工程是一門研究如何規劃、設計、開發、測試、部署和維護高品質軟體的學科。它關注於軟體開發過程的效率和效果。
-   **物件導向的體現**：物件導向在軟體工程的各個階段都扮演著重要角色。
    -   **需求分析**：物件導向分析（OOA）透過識別領域中的物件及其關係來理解需求。
    -   **系統設計**：物件導向設計（OOD）將分析結果轉化為具體的類別結構和物件交互模型，促進清晰的軟體架構。
    -   **開發與維護**：物件導向的模組化、可重用性、擴展性（透過繼承和多型）有助於提高開發效率，降低維護成本，並方便團隊協作。
    -   **測試**：獨立的物件單元更容易進行單元測試。
-   **關聯**：物件導向提供了一套強大的概念和工具，使得軟體工程能夠更好地實現其目標，即在預算內按時交付滿足客戶需求的高品質軟體。它使得複雜系統的建模、分解和管理變得更加可行和高效。

-----

## ### 4. 進階內容

在深入理解物件導向的三大特性後，我們還可以探討一些更進階的概念和設計考量，這些對於構建更靈活、更穩健的系統至關重要。

#### #### 4.1 抽象類別 (Abstract Class) 與 介面 (Interface)

抽象類別和介面都是實現多型和定義合約的重要機制，但它們在用途和功能上有所區別。

##### ##### 4.1.1 抽象類別 (Abstract Class)

-   **定義**：抽象類別是一種不能被直接實例化的類別。它通常包含至少一個抽象方法（沒有實作的方法），也可以包含具體方法和屬性。抽象類別的目的是作為其子類別的基底，定義一個共同的介面和部分實作。
-   **核心觀念**：
    -   **不完整性**：抽象類別因為包含抽象方法，所以本身是不完整的，必須由子類別來提供抽象方法的具體實作。
    -   **部分實作**：可以提供部分方法的預設實作，減少子類別的重複程式碼。
    -   **「是一種」關係**：抽象類別適用於表達強烈的「是一種」繼承關係。
-   **例子**：
    假設我們有各種圖形，它們都有計算面積和周長的行為，但具體計算方式不同。
    ```python
    from abc import ABC, abstractmethod # 導入抽象基底類別模組

    class Shape(ABC): # 宣告為抽象類別
        def __init__(self, name):
            self.name = name

        @abstractmethod # 宣告為抽象方法
        def get_area(self):
            pass # 抽象方法沒有實作

        @abstractmethod
        def get_perimeter(self):
            pass

        def describe(self): # 具體方法
            return f"這是一個 {self.name}。"

    class Circle(Shape):
        def __init__(self, name, radius):
            super().__init__(name)
            self.radius = radius

        def get_area(self): # 必須實作抽象方法
            return 3.14159 * self.radius * self.radius

        def get_perimeter(self): # 必須實作抽象方法
            return 2 * 3.14159 * self.radius

    # s = Shape("通用形狀") # 錯誤！無法實例化抽象類別
    my_circle = Circle("圓形", 5)
    print(my_circle.describe())
    print(f"面積: {my_circle.get_area():.2f}, 周長: {my_circle.get_perimeter():.2f}")
    ```

##### ##### 4.1.2 介面 (Interface)

-   **定義**：介面是一種完全抽象的類別（在某些語言中，如Java），或僅包含抽象方法的「協議」（在Python中，通常透過 `abc` 模組或Duck Typing實現）。它只定義了行為的簽章（方法名稱、參數、回傳值），而不提供任何實作。
-   **核心觀念**：
    -   **合約**：介面定義了一組類別必須遵守的行為合約。任何實作該介面的類別都必須提供介面中所有方法的具體實作。
    -   **行為規範**：強調「能做什麼 (can-do)」，而非「是什麼 (is-a)」。
    -   **解耦**：使用者程式碼只依賴介面，而非具體實作，極大地降低了耦合度。
-   **例子**：
    考慮一個可以飛行的物件。
    ```python
    from abc import ABC, abstractmethod

    class Flyable(ABC): # 宣告為抽象基底類別，作為介面使用
        @abstractmethod
        def fly(self):
            pass

        @abstractmethod
        def take_off(self):
            pass

        @abstractmethod
        def land(self):
            pass

    class Airplane(Flyable):
        def fly(self):
            print("飛機在空中飛行。")

        def take_off(self):
            print("飛機起飛。")

        def land(self):
            print("飛機降落。")

    class Bird(Flyable):
        def fly(self):
            print("小鳥拍動翅膀飛行。")

        def take_off(self):
            print("小鳥從樹枝上起飛。")

        def land(self):
            print("小鳥降落在巢穴中。")

    def make_it_fly(obj: Flyable): # 函數接收任何實作 Flyable 介面的物件
        obj.take_off()
        obj.fly()
        obj.land()

    my_plane = Airplane()
    sparrow = Bird()

    make_it_fly(my_plane)
    print("-----")
    make_it_fly(sparrow)
    ```
-   **與相鄰概念的關聯**：
    -   **繼承**：抽象類別是繼承樹的一部分，子類別「繼承」抽象類別，並且通常「是一種」抽象類別。
    -   **多型**：抽象類別和介面都是實現多型的重要工具。它們定義了統一的介面，允許不同的具體類別以不同的方式實作這些介面，從而實現「一個介面，多種實作」。
    -   **差別**：
        -   **實作**：抽象類別可以有屬性和具體方法，介面則通常只有抽象方法（行為）。
        -   **繼承限制**：大多數語言只支援單一繼承（只能繼承一個抽象類別），但可以實作多個介面。
        -   **目的**：抽象類別用於定義基底行為和通用結構；介面用於定義跨不同繼承體系的行為合約。

-----

#### #### 4.2 組合優於繼承 (Composition over Inheritance)

這是一個重要的物件導向設計原則，它建議在設計類別關係時，優先考慮使用物件組合（Composition）而不是繼承（Inheritance）。

-   **核心觀念**：
    -   **繼承的缺點**：
        -   **緊密耦合 (Tight Coupling)**：子類別與父類別之間形成強烈的耦合關係，父類別的變更可能影響所有子類別。
        -   **打破封裝**：繼承暴露了父類別的內部實作細節給子類別，可能破壞父類別的封裝性。
        -   **「菱形繼承」問題 (Diamond Problem)**：在多重繼承的語言中，如果一個類別從兩個有共同祖先的類別繼承，會導致方法衝突和複雜性。
        -   **不靈活**：繼承關係在編譯時就確定，難以在運行時改變物件的行為。
    -   **組合的優點**：
        -   **鬆散耦合 (Loose Coupling)**：物件透過包含其他物件來獲得功能，這些被包含的物件可以在運行時更換，增加了彈性。
        -   **高彈性**：可以動態地改變物件的行為，因為其包含的組件可以被替換。
        -   **更少的限制**：一個類別可以包含多個不同類型的物件，避免了單一繼承的限制。
        -   **更好的封裝**：物件只暴露其包含組件的必要介面，隱藏了內部實作。
-   **例子**：
    假設我們想為一輛車 (`Car`) 添加引擎 (`Engine`) 的功能。

    -   **繼承方式 (不推薦)**：
        ```python
        class Engine:
            def start(self):
                print("引擎啟動。")

            def stop(self):
                print("引擎停止。")

        # class Car(Engine): # 錯誤設計：車「是」引擎？這不符合邏輯
        #     def drive(self):
        #         self.start()
        #         print("汽車行駛。")
        #         self.stop()
        ```
        這種設計違背了「是一種 (is-a)」的原則，車不是引擎，車「有」引擎。

    -   **組合方式 (推薦)**：
        ```python
        class Engine: # 引擎類別
            def start(self):
                print("引擎啟動。")
            def stop(self):
                print("引擎停止。")

        class Car:
            def __init__(self, engine):
                self.engine = engine # Car 包含一個 Engine 物件

            def drive(self):
                self.engine.start() # 透過引擎物件啟動
                print("汽車行駛中...")
                self.engine.stop()  # 透過引擎物件停止

        # 使用
        my_engine = Engine()
        my_car = Car(my_engine) # 將引擎物件傳入汽車
        my_car.drive()
        # 輸出：
        # 引擎啟動。
        # 汽車行駛中...
        # 引擎停止。
        ```
        這裡，`Car` 類別「擁有一個 (has-a)」`Engine` 物件，而不是「是一種」`Engine`。這種方式使得 `Car` 可以輕鬆替換不同類型的 `Engine`（例如電動引擎、汽油引擎），而無需改變 `Car` 的繼承關係。
-   **推導與關聯**：組合強調物件的靈活性和獨立性，它與 SOLID 原則中的開放封閉原則和依賴反轉原則有著密切的關係。當我們需要重用功能時，應首先考慮組合，只有當兩個類別確實存在明確的「是一種」關係時才考慮繼承。

-----

## ### 5. 常見錯誤與澄清

學習物件導向時，初學者常會有一些誤解，這裡進行澄清。

#### #### 5.1 誤解一：OOP 只是「有類別和物件」而已

-   **錯誤觀念**：很多人認為只要程式碼中使用了 `class` 關鍵字並創建了物件，就是進行了物件導向程式設計。
-   **澄清**：類別和物件確實是物件導向的語法基礎，但它們只是工具。物件導向的精髓在於其設計思想和三大特性（封裝、繼承、多型）以及 SOLID 等設計原則的應用。如果只是將函式和資料簡單地包裝在類別中，而沒有合理地運用這些原則，那麼程式可能只是「穿著物件導向外衣的程序導向程式」，無法真正體現物件導向的優勢，甚至可能導致更複雜、更難以維護的程式碼。
-   **舉例**：一個只有屬性沒有方法的類別，或者一個所有方法都是 `public` 且直接操作所有屬性的類別，雖然語法上是物件導向，但它沒有實現良好的封裝，其設計品質較差。

-----

#### #### 5.2 誤解二：繼承越多越好，程式碼越少

-   **錯誤觀念**：認為繼承可以最大化程式碼重用，因此應該盡可能地建立深層的繼承結構。
-   **澄清**：
    -   **過度繼承導致緊密耦合**：繼承在父類和子類之間建立了強烈的耦合關係。父類別的任何改變都可能影響到所有子類別，導致修改風險大。
    -   **破壞封裝**：子類別通常能直接訪問父類別的受保護成員，打破了父類別的封裝性，使得父類別難以獨立演進。
    -   **「繼承瘟疫」**：深層的繼承樹會使系統變得僵硬，難以理解和修改。子類別可能繼承了它不需要的方法，或者必須覆寫不相關的方法，增加了複雜性。
    -   **難以測試**：由於耦合性高，測試單個子類別可能需要建立完整的父類別鏈，增加了測試難度。
-   **建議**：應謹慎使用繼承，只在存在明確的「是一種 (is-a)」關係時才考慮。對於需要重用功能但不存在強烈「是一種」關係的場景，通常應優先考慮「組合優於繼承」的原則。

-----

#### #### 5.3 誤解三：所有東西都必須是物件

-   **錯誤觀念**：一旦決定採用物件導向，就應該把所有程式碼、所有功能都包裝成物件。
-   **澄清**：
    -   **並非所有問題都適合 OOP**：物件導向是一種強大的範式，但並非萬能。對於一些簡單的、資料流導向的任務（例如純粹的數學計算、資料轉換腳本），使用程序導向或函數式程式設計可能更直接、更高效。
    -   **過度設計的風險**：將所有東西都抽象成物件可能導致過度設計，引入不必要的複雜性。例如，一個單純的工具函式，如果強行包裝成一個類別的靜態方法，意義不大。
    -   **平衡的考量**：應根據問題的性質、規模和團隊的偏好來選擇最合適的程式設計範式或混合使用。優秀的軟體設計往往是多種範式的結合。
-   **舉例**：一個用於計算兩個數字和的函式 `add(a, b)`，通常沒有必要為它設計一個 `Calculator` 類別。直接作為一個獨立的函式會更簡潔明瞭。

-----

## ### 6. 小練習（附詳解）

透過實際練習來鞏固物件導向的核心概念。

#### #### 6.1 練習一：設計一個圖形階層

**目標**：練習類別、物件、繼承、多型和抽象類別。

**要求**：

1.  建立一個名為 `Shape` 的抽象基底類別。
    *   `Shape` 類別應有一個 `name` 屬性（在建構子中初始化）。
    *   `Shape` 類別應包含兩個抽象方法：`get_area()` (計算面積) 和 `get_perimeter()` (計算周長)。
2.  建立 `Circle` 類別，繼承自 `Shape`。
    *   `Circle` 應有額外的 `radius` 屬性。
    *   實作 `get_area()` 和 `get_perimeter()` 方法，計算圓形的面積和周長。
        *   圓面積公式：$\pi r^2$
        *   圓周長公式：$2 \pi r$ (使用 `math.pi`)
3.  建立 `Rectangle` 類別，繼承自 `Shape`。
    *   `Rectangle` 應有額外的 `width` 和 `height` 屬性。
    *   實作 `get_area()` 和 `get_perimeter()` 方法，計算長方形的面積和周長。
        *   長方形面積公式：$width \times height$
        *   長方形周長公式：$2 \times (width + height)$
4.  創建一個包含不同圖形物件的列表（例如，一個圓形和一個長方形）。
5.  迭代該列表，對每個圖形物件呼叫 `get_area()` 和 `get_perimeter()` 方法，並列印結果。

---

**詳解**：

```python
import math
from abc import ABC, abstractmethod

# 1. 建立 Shape 抽象基底類別
class Shape(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def get_area(self):
        """計算並回傳圖形的面積。"""
        pass

    @abstractmethod
    def get_perimeter(self):
        """計算並回傳圖形的周長。"""
        pass

    def __str__(self):
        """提供一個友善的字串表示。"""
        return f"{self.name} (面積: {self.get_area():.2f}, 周長: {self.get_perimeter():.2f})"

# 2. 建立 Circle 類別
class Circle(Shape):
    def __init__(self, name, radius):
        super().__init__(name) # 呼叫父類別的建構子
        if radius <= 0:
            raise ValueError("圓形半徑必須大於零。")
        self.radius = radius

    def get_area(self):
        return math.pi * self.radius ** 2

    def get_perimeter(self):
        return 2 * math.pi * self.radius

# 3. 建立 Rectangle 類別
class Rectangle(Shape):
    def __init__(self, name, width, height):
        super().__init__(name)
        if width <= 0 or height <= 0:
            raise ValueError("長方形寬度和高度必須大於零。")
        self.width = width
        self.height = height

    def get_area(self):
        return self.width * self.height

    def get_perimeter(self):
        return 2 * (self.width + self.height)

# 4. 創建不同圖形物件的列表
shapes = [
    Circle("大圓", 10),
    Rectangle("小方塊", 5, 5),
    Circle("小圓", 3.5),
    Rectangle("長條形", 8, 2)
]

# 5. 迭代列表並列印結果
print("--- 圖形計算結果 ---")
for shape in shapes:
    print(shape) # 利用 __str__ 方法統一輸出
# 輸出預期：
# --- 圖形計算結果 ---
# 大圓 (面積: 314.16, 周長: 62.83)
# 小方塊 (面積: 25.00, 周長: 20.00)
# 小圓 (面積: 38.48, 周長: 21.99)
# 長條形 (面積: 16.00, 周長: 20.00)
```

-----

#### #### 6.2 練習二：設計一個銀行帳戶系統

**目標**：練習封裝和基本的行為邏輯。

**要求**：

1.  建立一個名為 `BankAccount` 的類別。
2.  `BankAccount` 應有一個 `_balance` 屬性來儲存帳戶餘額。此屬性應被保護，不允許外部直接修改。
    *   在建構子中初始化 `_balance`，確保初始餘額不為負數。
3.  提供 `deposit(amount)` 方法：
    *   接收一個 `amount` 參數。
    *   如果 `amount` 大於 0，則將其加到 `_balance` 中。
    *   否則，列印錯誤訊息。
4.  提供 `withdraw(amount)` 方法：
    *   接收一個 `amount` 參數。
    *   如果 `amount` 大於 0 且 `_balance` 足夠支付，則從 `_balance` 中扣除。
    *   如果 `amount` <= 0 或 `_balance` 不足，則列印相應的錯誤訊息。
5.  提供 `get_balance()` 方法：
    *   回傳當前的 `_balance` 值。
6.  創建一個 `BankAccount` 物件，進行存款、提款操作，並檢查餘額。

---

**詳解**：

```python
class BankAccount:
    def __init__(self, initial_balance):
        # 2. _balance 屬性被保護 (使用單個底線作為慣例)
        if initial_balance < 0:
            raise ValueError("初始餘額不能為負數。")
        self._balance = initial_balance
        print(f"帳戶創建成功，初始餘額: {self._balance} 元。")

    # 3. 存款方法
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
            print(f"存款 {amount} 元成功。新餘額: {self._balance} 元。")
        else:
            print("存款金額必須大於零。")

    # 4. 提款方法
    def withdraw(self, amount):
        if amount <= 0:
            print("提款金額必須大於零。")
        elif self._balance >= amount:
            self._balance -= amount
            print(f"提款 {amount} 元成功。新餘額: {self._balance} 元。")
        else:
            print(f"餘額不足。欲提款 {amount} 元，但目前餘額只有 {self._balance} 元。")

    # 5. 取得餘額方法
    def get_balance(self):
        return self._balance

    def __str__(self):
        return f"銀行帳戶目前餘額: {self.get_balance()} 元。"

# 6. 創建物件並進行操作
print("--- 銀行帳戶操作 ---")
my_account = BankAccount(1000)

print(my_account) # 檢查初始餘額

my_account.deposit(500)  # 存款
my_account.withdraw(200) # 提款
my_account.withdraw(1500) # 餘額不足的提款
my_account.deposit(-100) # 無效存款
my_account.withdraw(0)   # 無效提款

print(my_account) # 檢查最終餘額

# 嘗試直接修改受保護的屬性 (雖然Python允許，但不推薦)
# print(f"嘗試直接修改餘額前: {my_account.get_balance()}")
# my_account._balance = -500 # 外部應避免這樣做！
# print(f"嘗試直接修改餘額後: {my_account.get_balance()}")
# 輸出預期：
# --- 銀行帳戶操作 ---
# 帳戶創建成功，初始餘額: 1000 元。
# 銀行帳戶目前餘額: 1000 元。
# 存款 500 元成功。新餘額: 1500 元。
# 提款 200 元成功。新餘額: 1300 元。
# 餘額不足。欲提款 1500 元，但目前餘額只有 1300 元。
# 存款金額必須大於零。
# 提款金額必須大於零。
# 銀行帳戶目前餘額: 1300 元。
```

-----

## ### 7. 延伸閱讀/參考

深入學習物件導向設計是一個持續的過程。以下是一些推薦的資源，可以幫助您進一步提升技能。

#### #### 7.1 推薦書籍

1.  **《物件導向分析與設計 (Object-Oriented Analysis and Design with Applications)》 by Grady Booch**
    *   經典之作，深入探討物件導向的哲學、原則和應用。適合對理論基礎有興趣的讀者。
2.  **《Head First Design Patterns (深入淺出設計模式)》**
    *   以生動活潑、圖文並茂的方式介紹了物件導向設計模式，非常適合初學者理解複雜概念。
3.  **《Clean Code: A Handbook of Agile Software Craftsmanship (無瑕的程式碼)》 by Robert C. Martin (Uncle Bob)**
    *   雖然不只針對物件導向，但其中許多章節（尤其是關於類別、函式和物件的）提供了大量實用的物件導向編程和設計的最佳實踐。
4.  **《Design Patterns: Elements of Reusable Object-Oriented Software (設計模式：可再利用物件導向軟體的要素)》 by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (Gang of Four, GoF)**
    *   設計模式的經典原著，詳細描述了23種核心設計模式。內容較為理論化，適合有一定經驗的讀者。

-----

#### #### 7.2 推薦網站/文章

1.  **Refactoring Guru (重構大師)**
    *   [https://refactoring.guru/zh-hant/design-patterns](https://refactoring.guru/zh-hant/design-patterns)
    *   提供了清晰易懂的設計模式、SOLID 原則和重構技術的介紹，配有圖示和程式碼範例。是學習設計模式的絕佳資源。
2.  **Martin Fowler's Blog (馬丁·福勒的部落格)**
    *   [https://martinfowler.com/](https://martinfowler.com/)
    *   許多關於軟體設計、架構、重構和敏捷開發的權威文章，包含物件導向的深入討論。
3.  **Wikipedia (維基百科)**
    *   搜尋 "Object-Oriented Programming", "SOLID (object-oriented design)", "Design Patterns" 等關鍵字，可以獲得全面的背景知識和概念解釋。

透過這些資源的學習，您將能夠更深入地理解物件導向設計的精髓，並將這些原則應用於實際的軟體開發中，寫出更優雅、更健壯的程式碼。