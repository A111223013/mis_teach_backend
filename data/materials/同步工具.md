# 主題：同步工具

#### 1. 核心概念與定義

在多執行緒或多程序環境中，多個實體（如執行緒或程序）可能同時存取或修改共享資源。如果沒有適當的協調機制，這種並行存取可能導致資料不一致或非預期的行為，這就是所謂的「競態條件」（Race Condition）。「同步工具」的目標正是為了協調這些實體的執行順序與資源存取，確保資料的正確性與系統的穩定性。

### 1.1 什麼是同步？
*   **定義**：同步是指在並行系統中，協調多個執行緒或程序的操作順序，以確保它們能夠正確地合作、共享資源，並避免競態條件。
*   **核心觀念**：
    *   **互斥（Mutual Exclusion）**：確保在任何給定時間，只有一個執行緒可以訪問共享資源的特定區段。這是解決競態條件的基礎。
    *   **協調（Coordination）**：確保執行緒依照特定的順序執行，例如，一個執行緒必須等待另一個執行緒完成某項任務後才能繼續。
*   **為什麼需要同步？**
    *   **競態條件（Race Condition）**：當多個執行緒或程序同時存取並修改共享資料，且其結果依賴於執行順序時，就會發生競態條件。
    *   **資料不一致（Data Inconsistency）**：競態條件的直接後果就是共享資料可能處於不正確或不一致的狀態。
    *   **非預期行為**：程式邏輯可能因為執行順序的不確定性而產生難以預測的結果。
*   **例子**：兩個執行緒同時對一個共享變數 `$x$` 執行 `$x++$` 操作。如果 `$x$` 初始值為 $0$，理想結果應為 $2$。但若操作不是原子性的（即分成讀取、加一、寫回三步驟），可能出現以下情況：
    1.  執行緒 A 讀取 `$x$` (值為 $0$)。
    2.  執行緒 B 讀取 `$x$` (值為 $0$)。
    3.  執行緒 A 計算 `$0 + 1 = 1$`。
    4.  執行緒 B 計算 `$0 + 1 = 1$`。
    5.  執行緒 A 將 `$1$` 寫回 `$x$`。
    6.  執行緒 B 將 `$1$` 寫回 `$x$`。
    最終 `$x$` 的值為 $1$，而非 $2$，發生了資料不一致。

### 1.2 關鍵區段 (Critical Section)
*   **定義**：關鍵區段是指程式中存取共享資源（如共享變數、檔案、資料庫等）的程式碼片段。
*   **核心觀念**：
    *   **互斥進入**：任何時候，只允許一個執行緒在關鍵區段內執行。
    *   **進度（Progress）**：如果沒有執行緒在關鍵區段內，且有執行緒想進入，則允許其進入。
    *   **有限等待（Bounded Waiting）**：一個執行緒請求進入關鍵區段後，其等待時間應有限，不能無限期地等待。
*   **進入/退出協議**：為實現互斥性，每個關鍵區段通常包含：
    *   **進入區段（Entry Section）**：程式碼用於請求進入關鍵區段。
    *   **關鍵區段（Critical Section）**：存取共享資源的程式碼。
    *   **退出區段（Exit Section）**：程式碼用於釋放關鍵區段，允許其他執行緒進入。
    *   **剩餘區段（Remainder Section）**：關鍵區段以外的其他程式碼。
*   **與相鄰概念的關聯**：關鍵區段是同步問題的核心概念，所有同步工具的目的都是為了有效地保護關鍵區段，確保其互斥性。

### 1.3 常見同步問題
同步工具的設計和應用通常圍繞著解決一些經典的同步問題：
*   **生產者-消費者問題（Producer-Consumer Problem）**：一個或多個生產者向緩衝區中添加資料，一個或多個消費者從緩衝區中取出資料。需要協調緩衝區滿/空的情況。
*   **讀者-寫者問題（Readers-Writers Problem）**：多個讀者可以同時讀取資料，但寫者必須獨佔存取，寫入時不允許其他讀者或寫者存在。
*   **哲學家用餐問題（Dining Philosophers Problem）**：五個哲學家圍坐圓桌，每人面前一碗麵，左右各有一支筷子。哲學家需要兩支筷子才能吃飯。這個問題用於演示死鎖和飢餓。

-----

#### 2. 典型同步工具與機制

### 2.1 鎖 (Locks / Mutexes)
*   **核心觀念**：鎖（或互斥鎖，Mutex，Mutual Exclusion Lock）是最基本的同步原語，用於保護共享資源或關鍵區段，確保在任何時刻只有一個執行緒可以訪問該資源。
*   **定義**：一個二元狀態的變數，通常只有「鎖定」（locked）和「解鎖」（unlocked）兩種狀態。
*   **運作方式**：
    *   **`acquire()`** 操作：嘗試獲取鎖。如果鎖是解鎖狀態，則將其設為鎖定並返回；如果鎖已鎖定，則呼叫執行緒會被阻塞（通常進入等待佇列）直到鎖被釋放。
    *   **`release()`** 操作：釋放鎖。將鎖設為解鎖狀態，並喚醒一個正在等待該鎖的執行緒（如果有的話）。
*   **例子**：
    ```
    // 共享變數
    int balance = 1000;
    Mutex lock; // 宣告一個互斥鎖

    void deposit(int amount) {
        lock.acquire(); // 獲取鎖
        balance += amount; // 關鍵區段
        lock.release(); // 釋放鎖
    }

    void withdraw(int amount) {
        lock.acquire(); // 獲取鎖
        if (balance >= amount) {
            balance -= amount; // 關鍵區段
        }
        lock.release(); // 釋放鎖
    }
    ```
*   **與相鄰概念的關聯**：
    *   **粒度（Granularity）**：鎖的保護範圍。粒度太粗會降低並行性，粒度太細會增加鎖的開銷和複雜性。
    *   **忙等（Busy Waiting）**：某些簡單的鎖實現（如自旋鎖 Spinlock）在獲取鎖失敗時會不斷循環檢查鎖的狀態，浪費 CPU 週期。作業系統級的互斥鎖通常會讓等待的執行緒進入睡眠狀態。

### 2.2 號誌 (Semaphores)
*   **核心觀念**：號誌是一種更通用的同步工具，由荷蘭計算機科學家 Dijkstra 提出。它是一個整數變數，除了初始化外，只能透過兩個原子操作 `wait()` 和 `signal()` 來訪問。
*   **定義**：
    *   **計數號誌（Counting Semaphore）**：其值可以在任意非負數範圍內變化，用於控制對多個同類資源的存取。
    *   **二元號誌（Binary Semaphore）**：其值只能是 $0$ 或 $1$，功能上等同於互斥鎖。
*   **運作方式**：
    *   **`wait(S)` 或 `P(S)` (Proberen, "to test")**：
        如果 $S > 0$，則 $S \gets S - 1$ 並繼續執行。
        如果 $S = 0$，則執行緒被阻塞（放到號誌的等待佇列中），直到 $S > 0$。
    *   **`signal(S)` 或 `V(S)` (Verhogen, "to increment")**：
        $S \gets S + 1$。
        如果號誌的等待佇列中有被阻塞的執行緒，則喚醒其中一個。
    *   *注意*：`wait()` 和 `signal()` 操作必須是原子性的。
*   **例子**：使用號誌解決生產者-消費者問題。
    假設有一個大小為 $N$ 的緩衝區。
    ```
    Semaphore mutex = 1;      // 互斥鎖，保護對緩衝區的存取
    Semaphore empty = N;      // 緩衝區空位數量，初始為 N
    Semaphore full = 0;       // 緩衝區已佔用數量，初始為 0

    void producer() {
        while (true) {
            // ... 生產一個項目 item ...
            empty.wait();     // 等待緩衝區有空位
            mutex.wait();     // 進入關鍵區段，保護緩衝區
            // 將 item 放入緩衝區
            mutex.signal();   // 離開關鍵區段
            full.signal();    // 通知緩衝區有新項目
        }
    }

    void consumer() {
        while (true) {
            full.wait();      // 等待緩衝區有項目
            mutex.wait();     // 進入關鍵區段，保護緩衝區
            // 從緩衝區取出一個項目 item
            mutex.signal();   // 離開關鍵區段
            empty.signal();   // 通知緩衝區釋出一個空位
            // ... 處理 item ...
        }
    }
    ```
*   **與相鄰概念的關聯**：
    *   比鎖更強大，不僅能實現互斥，還能實現更複雜的協調關係（如限制資源數量）。
    *   二元號誌可直接取代互斥鎖。
    *   號誌的缺點是使用不當容易導致死鎖、飢餓等問題，且程式碼可讀性較差，容易出錯。

### 2.3 條件變數 (Condition Variables)
*   **核心觀念**：條件變數通常與互斥鎖（mutex）一起使用。它允許執行緒在某個特定條件不滿足時等待（釋放鎖並進入睡眠），並在條件滿足時被其他執行緒喚醒。它本身並不提供互斥功能，而是提供等待/通知機制。
*   **定義**：一種用於執行緒等待和通知的同步機制。
*   **運作方式**：
    *   **`wait(mutex)`**：執行緒原子性地釋放所持有的 `mutex`，然後進入睡眠狀態，等待被喚醒。當被喚醒時，重新獲取 `mutex` 並繼續執行。
    *   **`signal()` 或 `notify_one()`**：喚醒一個正在等待該條件變數的執行緒。
    *   **`broadcast()` 或 `notify_all()`**：喚醒所有正在等待該條件變數的執行緒。
    *   **注意**：`wait()` 必須在鎖定 `mutex` 的情況下呼叫，並且 `signal()` 或 `broadcast()` 通常也應在鎖定 `mutex` 的情況下呼叫。
*   **例子**：生產者-消費者問題中的應用。
    ```c++
    std::vector<int> buffer;
    std::mutex mtx;
    std::condition_variable cv_producer; // 生產者等待緩衝區有空位
    std::condition_variable cv_consumer; // 消費者等待緩衝區有數據
    const int BUFFER_SIZE = 10;

    void producer() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            cv_producer.wait(lock, []{ return buffer.size() < BUFFER_SIZE; }); // 等待緩衝區有空位
            
            // ... 生產一個項目 item ...
            buffer.push_back(item);
            std::cout << "Producer produced: " << item << std::endl;
            
            cv_consumer.notify_one(); // 通知消費者有新數據
            lock.unlock(); // 離開關鍵區段
        }
    }

    void consumer() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            cv_consumer.wait(lock, []{ return !buffer.empty(); }); // 等待緩衝區有數據

            int item = buffer.front();
            buffer.erase(buffer.begin());
            std::cout << "Consumer consumed: " << item << std::endl;
            
            cv_producer.notify_one(); // 通知生產者有空位
            lock.unlock(); // 離開關鍵區段
        }
    }
    ```
*   **與相鄰概念的關聯**：
    *   條件變數必須與互斥鎖（Mutex）配合使用，因為條件判斷和修改共享狀態本身也需要互斥保護。
    *   它彌補了互斥鎖無法讓執行緒在特定條件下等待的問題，避免了忙等。

### 2.4 讀寫鎖 (Read-Write Locks)
*   **核心觀念**：讀寫鎖是一種特殊的互斥鎖，允許多個讀取者（reader）同時訪問共享資源，但寫入者（writer）必須獨佔訪問。當有寫入者在寫入時，不允許任何其他讀取者或寫入者訪問。
*   **定義**：提供兩種模式的鎖：讀取鎖（shared lock）和寫入鎖（exclusive lock）。
*   **運作方式**：
    *   **`acquire_read()`**：嘗試獲取讀取鎖。如果沒有寫入者正在寫入，則可以獲取鎖（多個讀取者可同時獲取）。如果有寫入者正在寫入或等待寫入，讀取者可能被阻塞。
    *   **`release_read()`**：釋放讀取鎖。
    *   **`acquire_write()`**：嘗試獲取寫入鎖。必須等到所有讀取者和寫入者都釋放鎖後才能獲取。
    *   **`release_write()`**：釋放寫入鎖。
*   **例子**：資料庫或緩存系統中，資料查詢（讀）操作遠多於資料更新（寫）操作的場景。
    ```
    ReadWriteLock rwLock; // 宣告一個讀寫鎖

    void read_data() {
        rwLock.acquire_read(); // 獲取讀取鎖
        // 讀取共享資料
        rwLock.release_read(); // 釋放讀取鎖
    }

    void write_data(new_value) {
        rwLock.acquire_write(); // 獲取寫入鎖
        // 修改共享資料
        rwLock.release_write(); // 釋放寫入鎖
    }
    ```
*   **與相鄰概念的關聯**：
    *   相較於普通的互斥鎖，讀寫鎖在讀操作頻繁的場景下，可以顯著提高並行性。
    *   需要處理讀者優先或寫者優先的問題，以避免飢餓。

-----

#### 3. 與相鄰概念的關聯

### 3.1 死鎖 (Deadlock)
*   **定義**：當多個執行緒或程序在競爭資源時，每個執行緒都在等待其他執行緒釋放它所需要的資源，導致所有執行緒都無法繼續執行，陷入無限期等待的狀態。
*   **關聯**：同步工具（特別是鎖和號誌）使用不當是導致死鎖的主要原因。
*   **死鎖發生的四個必要條件（Coffman 條件）**：
    1.  **互斥（Mutual Exclusion）**：資源不能共享。
    2.  **持有並等待（Hold and Wait）**：一個程序至少持有一個資源，並等待獲取其他程序持有的資源。
    3.  **不可搶佔（No Preemption）**：資源不能被強制從持有它的程序中搶走。
    4.  **循環等待（Circular Wait）**：存在一個程序鏈，每個程序都在等待鏈中下一個程序持有的資源。
*   **例子**：兩個執行緒，兩個鎖。
    執行緒 A 嘗試獲取鎖 $L_1$，然後鎖 $L_2$。
    執行緒 B 嘗試獲取鎖 $L_2$，然後鎖 $L_1$。
    如果 A 獲取了 $L_1$，同時 B 獲取了 $L_2$，則 A 在等待 $L_2$ 而 B 在等待 $L_1$，形成死鎖。

### 3.2 活鎖 (Livelock)
*   **定義**：與死鎖類似，執行緒無法取得進展，但它們並不是被阻塞，而是在不斷地改變狀態以回應其他執行緒的行為，卻始終無法完成工作。
*   **關聯**：通常發生在使用忙等（Spinlock）的無死鎖演算法中，當多個執行緒同時嘗試獲取資源時，由於彼此不斷退讓或重試，導致都無法成功。
*   **例子**：兩個人在狹窄的走廊相向而行，都想避讓對方，結果同時向左或向右移動，始終擋住對方，無法通過。

### 3.3 飢餓 (Starvation)
*   **定義**：一個或多個執行緒因無法獲得其所需的資源，而無限期地等待，導致永遠無法執行。
*   **關聯**：同步工具的排程或策略可能導致飢餓。例如，在讀寫鎖中，如果寫入者優先級較低，且不斷有新的讀取者到來，寫入者可能永遠無法獲得寫入鎖。
*   **例子**：在作業系統中，一個優先級較低的程序可能因為高優先級程序持續執行，而永遠無法得到 CPU 時間。

### 3.4 並行性 (Concurrency) 與平行性 (Parallelism)
*   **定義**：
    *   **並行性（Concurrency）**：指一個系統同時處理多個任務的能力。即使只有一個 CPU，透過時間共享（上下文切換）也能實現並行。
    *   **平行性（Parallelism）**：指一個系統同時執行多個任務的能力。通常需要多個 CPU 核心或處理器才能實現真正的平行。
*   **關聯**：同步工具是管理並行和實現平行性的基石。它們確保多個任務在共享資源時的正確性，無論這些任務是在單核 CPU 上並行執行，還是在多核 CPU 上平行執行。沒有同步，並行和平行都會帶來資料不一致的問題。

-----

#### 4. 進階內容

### 4.1 原子操作 (Atomic Operations)
*   **核心觀念**：原子操作是不可被中斷的單一操作。它要麼完全執行成功，要麼完全不執行，不會出現執行到一半的情況。
*   **定義**：由硬體層面保證其執行不可分割。
*   **運作方式**：許多處理器提供特殊的機器指令來實現原子操作，例如 `TestAndSet`、`CompareAndSwap` (CAS)。這些指令通常用於構建更高級的同步原語。
*   **例子**：
    *   C++11 引入了 `std::atomic` 類型，提供了原子性的基本算術和邏輯操作。
    *   `_InterlockedIncrement` (Windows)、`__sync_fetch_and_add` (GCC) 等內建函數。
*   **與相鄰概念的關聯**：原子操作是實現無鎖（Lock-Free）演算法和自旋鎖（Spinlock）的基礎。它們在底層提供了比軟體鎖更高效的互斥。

### 4.2 記憶體屏障 (Memory Barriers / Fences)
*   **核心觀念**：記憶體屏障是指令集中的特殊指令，用於確保指令的執行順序。它強制處理器在屏障之前的所有記憶體操作完成後，才能執行屏障之後的記憶體操作。
*   **定義**：一種阻止編譯器和處理器重排序記憶體操作的機制。
*   **運作方式**：解決編譯器優化和處理器亂序執行（out-of-order execution）導致的多執行緒可見性問題。
*   **例子**：在某些底層同步原語（如自旋鎖）的實現中，需要記憶體屏障來確保變數的寫入對其他核心是可見的，並且讀取操作不會被過早地執行。
*   **與相鄰概念的關聯**：與處理器架構和編譯器優化緊密相關。是確保多處理器系統中共享記憶體正確同步的關鍵。

### 4.3 無鎖演算法 (Lock-Free Algorithms)
*   **核心觀念**：無鎖演算法（或非阻塞同步演算法）旨在避免使用傳統的鎖機制來實現同步，從而消除死鎖、活鎖和飢餓的可能性，並可能在某些情況下提高性能。
*   **定義**：一種並行演算法，保證系統中的至少一個執行緒總能取得進展，即便其他執行緒被任意延遲或終止。
*   **運作方式**：通常依賴於底層的原子操作，如 `Compare-And-Swap` (CAS)。執行緒嘗試修改共享資料，如果發現資料在讀取後被其他執行緒修改過，則重試。
*   **例子**：實現無鎖的堆疊、佇列或計數器。例如，使用 CAS 更新一個共享變數：
    ```
    int current_value = shared_counter;
    int new_value = current_value + 1;
    // 如果 shared_counter 仍是 current_value，則更新為 new_value，否則重試
    while (!compare_and_swap(&shared_counter, current_value, new_value)) {
        current_value = shared_counter;
        new_value = current_value + 1;
    }
    ```
*   **與相鄰概念的關聯**：是高級並行程式設計的範疇，需要對原子操作和記憶體模型有深入理解。可以避免鎖帶來的開銷和死鎖風險，但設計和實現非常複雜。

-----

#### 5. 常見錯誤與澄清

### 5.1 號誌的誤用
*   **錯誤**：`wait()` 和 `signal()` 操作順序顛倒，或者 `signal()` 次數與 `wait()` 次數不匹配。
*   **澄清**：
    *   **順序顛倒**：如果保護共享資源的 `wait(mutex)` 和 `signal(mutex)` 順序錯誤（例如先 `signal()` 後 `wait()`），可能導致一個執行緒在沒有獲得互斥權的情況下進入關鍵區段，破壞互斥性。
    *   **計數錯誤**：計數號誌的初始化值或操作次數不當，可能導致過早阻塞（`empty.wait()` 時緩衝區明明有空位）或資源超限存取（`mutex.signal()` 多次）。
    *   **遺忘 `signal()`**：如果一個執行緒在關鍵區段內因為異常或其他原因沒有呼叫 `signal()`，那麼它將永遠持有資源，導致其他等待該資源的執行緒永久阻塞（死鎖）。

### 5.2 條件變數的誤用
*   **錯誤**：在呼叫 `wait()` 之前沒有鎖定相關的互斥鎖；對 `wait()` 的返回值沒有進行條件檢查（虛假喚醒）。
*   **澄清**：
    *   **未加鎖呼叫 `wait()`**：條件變數的 `wait()` 方法要求在呼叫前必須持有相關的互斥鎖。否則，可能會在判斷條件後但在進入等待之前，條件就被另一個執行緒改變，導致執行緒永久等待（Lost Wakeup）。
    *   **虛假喚醒（Spurious Wakeup）**：條件變數的 `wait()` 方法可能在沒有 `signal()` 或 `broadcast()` 的情況下被喚醒。因此，喚醒後必須重新檢查等待的條件是否真的滿足。這通常透過在 `wait()` 外部使用 `while` 迴圈來檢查條件（或 C++11 條件變數提供帶有謂詞的版本）來實現：
        ```c++
        // 錯誤範例：使用 if
        // if (condition_not_met) { cv.wait(lock); }
        // 正確範例：使用 while
        while (condition_not_met) { cv.wait(lock); }
        // 或使用謂詞
        cv.wait(lock, []{ return condition_is_met; });
        ```
    *   **忘記 `notify()`**：當條件滿足時，必須主動呼叫 `notify_one()` 或 `notify_all()` 來喚醒等待的執行緒，否則執行緒將永遠等待。

### 5.3 死鎖的預防與檢測
*   **錯誤**：忽略死鎖發生的可能性，或試圖在程式碼中簡單地「重試」以避免死鎖。
*   **澄清**：
    *   **預防**：
        *   **破壞持有並等待**：一次性請求所有需要的資源，或者在請求新資源時釋放已持有的資源。
        *   **破壞不可搶佔**：允許搶佔資源（通常複雜且不適用於所有資源）。
        *   **破壞循環等待**：對所有資源進行排序，並強制執行緒按照嚴格遞增（或遞減）的順序獲取資源。
    *   **檢測與恢復**：在執行時檢測死鎖，一旦發生則採取措施（如終止死鎖程序、資源搶佔）來恢復。這通常由作業系統完成。
    *   **避免**：銀行家演算法等，在分配資源前檢查是否會導致不安全狀態。

### 5.4 忙等 (Busy Waiting) 與睡眠 (Sleeping)
*   **錯誤**：不加區分地使用忙等或睡眠。
*   **澄清**：
    *   **忙等（Spinlock）**：執行緒在等待鎖時，會持續佔用 CPU 週期檢查鎖的狀態。
        *   **優點**：在等待時間極短的情況下，可以避免上下文切換的開銷，性能可能更高。
        *   **缺點**：如果等待時間較長，會大量浪費 CPU 資源。
    *   **睡眠（Mutex/Semaphore/Condition Variable）**：執行緒在等待時，會釋放 CPU 並進入睡眠狀態，由作業系統排程器在條件滿足時喚醒。
        *   **優點**：不浪費 CPU 週期，適合等待時間可能較長的情況。
        *   **缺點**：涉及上下文切換，開銷相對較大。
    *   **何時使用**：
        *   **忙等**：適用於多核處理器，且預期關鍵區段非常短，競爭不激烈，上下文切換開銷大於忙等開銷的場景。
        *   **睡眠**：適用於單核處理器，或多核處理器上關鍵區段可能較長，競爭激烈的場景。通常是預設和推薦的選擇。

-----

#### 6. 小練習 (附詳解)

### 練習 1：使用二元號誌（或互斥鎖）實現兩個執行緒交替列印
**目標**：設計一個程式，讓兩個執行緒 `ThreadA` 和 `ThreadB` 交替列印數字。`ThreadA` 列印 $0, 2, 4, \dots$，`ThreadB` 列印 $1, 3, 5, \dots$，直到列印到 $N-1$。

**程式碼框架（C++ 偽代碼）**：
```cpp
// 共享變數
int count = 0;
const int N = 10; // 列印到 9

// 同步工具 (你需要補齊)
Semaphore semA; // 控制 ThreadA 執行
Semaphore semB; // 控制 ThreadB 執行

void ThreadA_func() {
    while (true) {
        // 等待並獲取 semA
        // 檢查 count 是否達到 N，如果是則 break
        // 列印 count
        // count 自增
        // 釋放 semB
    }
}

void ThreadB_func() {
    while (true) {
        // 等待並獲取 semB
        // 檢查 count 是否達到 N，如果是則 break
        // 列印 count
        // count 自增
        // 釋放 semA
    }
}
```

**詳解**：

1.  **初始化號誌**：
    *   由於 `ThreadA` 應該先執行（列印 $0$），所以 `semA` 應初始化為 $1$。
    *   `ThreadB` 應等待 `ThreadA` 執行後才開始，所以 `semB` 應初始化為 $0$。

2.  **`ThreadA_func` 邏輯**：
    *   `semA.wait()`：等待獲取 `semA`。
    *   `if (count >= N) { semB.signal(); break; }`：檢查終止條件。注意，如果 `ThreadA` 結束，它需要喚醒 `ThreadB`，否則 `ThreadB` 會死鎖。
    *   `print(count)`：列印當前值。
    *   `count++`：遞增 `count`。
    *   `semB.signal()`：喚醒 `ThreadB`。

3.  **`ThreadB_func` 邏輯**：
    *   `semB.wait()`：等待獲取 `semB`。
    *   `if (count >= N) { semA.signal(); break; }`：檢查終止條件。同樣，如果 `ThreadB` 結束，它需要喚醒 `ThreadA`。
    *   `print(count)`：列印當前值。
    *   `count++`：遞增 `count`。
    *   `semA.signal()`：喚醒 `ThreadA`。

**完整程式碼（C++ 偽代碼）**：
```cpp
#include <iostream>
#include <thread>
// 假設存在一個 Semaphore 類或功能
// 例如：std::binary_semaphore (C++20) 或自定義實現
class Semaphore {
public:
    Semaphore(int initial_value) : count_(initial_value) {}

    void wait() {
        std::unique_lock<std::mutex> lock(mtx_);
        cv_.wait(lock, [&]{ return count_ > 0; });
        count_--;
    }

    void signal() {
        std::unique_lock<std::mutex> lock(mtx_);
        count_++;
        cv_.notify_one();
    }
private:
    std::mutex mtx_;
    std::condition_variable cv_;
    int count_;
};

// 共享變數
int count = 0;
const int N = 10; // 列印到 9

// 同步工具
Semaphore semA(1); // ThreadA 先執行，所以初始為 1
Semaphore semB(0); // ThreadB 初始等待，所以初始為 0

void ThreadA_func() {
    while (true) {
        semA.wait(); // 等待並獲取 semA
        if (count >= N) {
            semB.signal(); // 喚醒 ThreadB 讓它也能退出
            break;
        }
        std::cout << "ThreadA: " << count << std::endl;
        count++;
        semB.signal(); // 釋放 semB，讓 ThreadB 執行
    }
}

void ThreadB_func() {
    while (true) {
        semB.wait(); // 等待並獲取 semB
        if (count >= N) {
            semA.signal(); // 喚醒 ThreadA 讓它也能退出
            break;
        }
        std::cout << "ThreadB: " << count << std::endl;
        count++;
        semA.signal(); // 釋放 semA，讓 ThreadA 執行
    }
}

int main() {
    std::thread tA(ThreadA_func);
    std::thread tB(ThreadB_func);

    tA.join();
    tB.join();

    std::cout << "Finished printing." << std::endl;
    return 0;
}

```

### 練習 2：使用條件變數解決簡化版生產者-消費者問題
**目標**：實現一個單一生產者和單一消費者的緩衝區，緩衝區大小為 1。生產者生產數據，消費者消費數據。使用條件變數。

**程式碼框架（C++ 偽代碼）**：
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

// 共享變數
int buffer = -1; // -1 表示緩衝區為空
bool has_data = false; // 緩衝區是否有數據
std::mutex mtx;
std::condition_variable cv_producer; // 生產者等待緩衝區為空
std::condition_variable cv_consumer; // 消費者等待緩衝區有數據

void producer() {
    for (int i = 0; i < 5; ++i) { // 生產 5 個數據
        // 加鎖
        // 等待緩衝區為空 (has_data == false)
        // 放入數據 i
        // 設置 has_data = true
        // 通知消費者
        // 解鎖
    }
}

void consumer() {
    for (int i = 0; i < 5; ++i) { // 消費 5 個數據
        // 加鎖
        // 等待緩衝區有數據 (has_data == true)
        // 取出數據
        // 設置 has_data = false
        // 通知生產者
        // 解鎖
    }
}
```

**詳解**：

1.  **`producer()` 邏輯**：
    *   使用 `std::unique_lock<std::mutex> lock(mtx);` 加鎖。
    *   使用 `cv_producer.wait(lock, []{ return !has_data; });` 等待緩衝區為空。`!has_data` 是謂詞，當為真時才繼續，否則釋放鎖並等待。
    *   `buffer = i;` 放入數據。
    *   `has_data = true;` 更新狀態。
    *   `cv_consumer.notify_one();` 通知消費者。
    *   `lock` 會在離開作用域時自動解鎖。

2.  **`consumer()` 邏輯**：
    *   使用 `std::unique_lock<std::mutex> lock(mtx);` 加鎖。
    *   使用 `cv_consumer.wait(lock, []{ return has_data; });` 等待緩衝區有數據。
    *   `int data = buffer;` 取出數據。
    *   `has_data = false;` 更新狀態。
    *   `cv_producer.notify_one();` 通知生產者。
    *   `lock` 會在離開作用域時自動解鎖。

**完整程式碼（C++）**：
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector> // 這裡用 vector 模擬，但由於大小是 1，實際更像一個變數

// 共享變數
int buffer = -1; // -1 表示緩衝區為空
bool has_data = false; // 緩衝區是否有數據
std::mutex mtx;
std::condition_variable cv_producer; // 生產者等待緩衝區為空
std::condition_variable cv_consumer; // 消費者等待緩衝區有數據

void producer() {
    for (int i = 0; i < 5; ++i) { // 生產 5 個數據
        std::unique_lock<std::mutex> lock(mtx); // 加鎖
        cv_producer.wait(lock, []{ return !has_data; }); // 等待緩衝區為空

        buffer = i; // 放入數據
        has_data = true; // 設置 has_data = true
        std::cout << "Producer produced: " << buffer << std::endl;
        
        cv_consumer.notify_one(); // 通知消費者
        // lock 在這裡離開作用域自動解鎖
    }
}

void consumer() {
    for (int i = 0; i < 5; ++i) { // 消費 5 個數據
        std::unique_lock<std::mutex> lock(mtx); // 加鎖
        cv_consumer.wait(lock, []{ return has_data; }); // 等待緩衝區有數據

        int data = buffer; // 取出數據
        has_data = false; // 設置 has_data = false
        std::cout << "Consumer consumed: " << data << std::endl;

        cv_producer.notify_one(); // 通知生產者
        // lock 在這裡離開作用域自動解鎖
    }
}

int main() {
    std::thread prod_thread(producer);
    std::thread cons_thread(consumer);

    prod_thread.join();
    cons_thread.join();

    std::cout << "Production and consumption finished." << std::endl;
    return 0;
}
```

-----

#### 7. 延伸閱讀/參考

*   **作業系統原理**：任何一本經典的作業系統教材都會詳細介紹同步問題和解決方案。
    *   Abraham Silberschatz, Peter B. Galvin, Greg Gagne. "Operating System Concepts" (俗稱「恐龍書」)。
    *   Andrew S. Tanenbaum, Herbert Bos. "Modern Operating Systems"。
*   **並行程式設計**：專門探討多執行緒和並行程式設計的書籍，會深入討論同步工具的實現細節和高效使用。
    *   Doug Lea. "Concurrent Programming in Java: Design Principles and Patterns"。
    *   Maurice Herlihy, Nir Shavit. "The Art of Multiprocessor Programming"。
*   **特定語言的並行庫文件**：
    *   C++: `std::mutex`, `std::condition_variable`, `std::semaphore` (C++20), `std::atomic`。
    *   Java: `java.util.concurrent` 包下的 `Lock`, `Semaphore`, `Condition`, `Atomic` 類。
    *   Python: `threading` 模組中的 `Lock`, `Semaphore`, `Condition`, `RLock`。
    *   Go: `sync` 包中的 `Mutex`, `RWMutex`, `WaitGroup`, `Cond`。