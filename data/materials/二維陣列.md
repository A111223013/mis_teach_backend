# 二維陣列 (Two-Dimensional Arrays)

二維陣列是程式設計中一種常見且強大的資料結構，用於儲存表格化的資料。想像一個試算表或棋盤，資料被組織成行與列，這就是二維陣列最直觀的類比。

-----

### 1. 核心概念與定義

#### 什麼是二維陣列？
二維陣列是一種特殊型態的陣列，其元素本身也是陣列。它將資料組織成行 (rows) 和列 (columns) 的結構，形成一個網格狀的儲存空間。我們可以將二維陣列視為「陣列的陣列」（An array of arrays）。

#### 核心概念：
*   **維度 (Dimensions):** 二維陣列有兩個維度：一個代表行，另一個代表列。
*   **元素存取 (Element Access):** 陣列中的每個元素都透過兩個索引來定位：第一個索引通常表示行號，第二個索引表示列號。例如，`array[row_index][column_index]`。
*   **資料型態 (Data Type):** 和一維陣列一樣，二維陣列中的所有元素都必須是相同型態的資料（例如，所有都是整數、所有都是字串等）。
*   **連續記憶體 (Contiguous Memory):** 在許多程式語言中，二維陣列的元素在記憶體中通常是連續儲存的（依循某種順序，如「行主要順序」row-major order）。

#### 語法範例 (概念性)：
以下是一個 $3 \times 4$ 的整數二維陣列的宣告與初始化概念：
```
int matrix[3][4]; // 宣告一個 3 行 4 列的整數二維陣列

// 初始化範例
int grades[2][3] = {
    {85, 90, 78},  // 第一行 (索引 0)
    {92, 88, 95}   // 第二行 (索引 1)
};
```
在上述範例中：
*   `grades[0][0]` 的值是 `85`
*   `grades[1][2]` 的值是 `95`

-----

### 2. 典型例子與轉換/推導

#### 典型應用場景：
二維陣列廣泛應用於需要表格化資料的場合：
1.  **影像處理：** 影像可以被看作是一個像素點的二維陣列，每個像素點儲存其顏色資訊。
2.  **遊戲地圖：** 棋盤遊戲（如西洋棋、圍棋）或迷宮遊戲的地圖結構。
3.  **矩陣運算：** 在數學或工程領域中，矩陣的加法、乘法等運算常常利用二維陣列來實現。
4.  **試算表/資料庫表格：** 儲存類似於 Excel 表格的資料。

#### 遍歷二維陣列：
要存取或處理二維陣列中的所有元素，通常會使用巢狀迴圈 (nested loops)。外層迴圈遍歷行，內層迴圈遍歷列。

**範例：列印一個 $3 \times 4$ 陣列的所有元素**
```
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

for (int i = 0; i < 3; i++) { // 外層迴圈遍歷行 (i 從 0 到 2)
    for (int j = 0; j < 4; j++) { // 內層迴圈遍歷列 (j 從 0 到 3)
        print(matrix[i][j] + " ");
    }
    print("\n"); // 每列印完一行就換行
}
```
輸出：
```
1 2 3 4 
5 6 7 8 
9 10 11 12 
```

#### 二維陣列的記憶體映射 (Memory Mapping)：
儘管我們概念上將二維陣列視為一個網格，但電腦記憶體本質上是一維的。因此，二維陣列的元素需要被映射到連續的一維記憶體空間中。最常見的映射方式是**行主要順序 (row-major order)**：先儲存完第一行的所有元素，接著是第二行，依此類推。

對於一個 `matrix[R][C]` 的二維陣列，其中 $R$ 是行數，$C$ 是列數。
元素 `matrix[i][j]` 在一維記憶體中的**邏輯索引**可以計算為：
$$ \text{index} = i \times C + j $$
其中 $i$ 是行索引，$j$ 是列索引。

**推導範例：**
對於 `matrix[3][4]`，`matrix[1][2]` (第 2 行第 3 列) 的邏輯索引為：
$$ \text{index} = 1 \times 4 + 2 = 4 + 2 = 6 $$
這表示如果將整個二維陣列攤平為一個一維陣列，`matrix[1][2]` 將位於這個一維陣列的索引 `6` 的位置（從 0 開始計數）。

-----

### 3. 與相鄰概念的關聯

#### 與一維陣列的關聯：
*   **基礎：** 二維陣列是從一維陣列的概念延伸而來。你可以將一個二維陣列理解為一個「由多個一維陣列組成的陣列」。
*   **記憶體：** 兩者都強調資料在記憶體中的連續儲存，以提供高效的隨機存取。
*   **索引：** 一維陣列使用單一索引，而二維陣列使用兩個索引來定位元素。

#### 與矩陣 (Matrices) 的關聯：
*   **數學基礎：** 在數學中，矩陣是一個數的陣列，以行和列的形式排列。二維陣列是實作數學矩陣最自然的方式。
*   **運算：** 矩陣的加法、減法、乘法等運算可以直接透過二維陣列的元素級操作來實現。例如，兩個 $M \times N$ 矩陣 $A$ 和 $B$ 的加法 $C = A + B$ 可以透過 $C[i][j] = A[i][j] + B[i][j]$ 來實現。
*   **術語：** 許多描述二維陣列的術語，如「維度」、「轉置」等，都來自於矩陣理論。

#### 與結構 (Structs) / 物件 (Objects) 的關聯：
*   **同質性 vs. 異質性：** 二維陣列儲存的是**同質性**資料（所有元素型態相同），而結構或物件可以儲存**異質性**資料（不同型態的欄位或屬性）。
*   **複雜資料：** 如果你需要儲存的表格資料中，每個儲存格本身就是一個複雜的資料結構（例如，包含姓名、年齡、成績的學生資訊），那麼你可能會使用一個「二維結構陣列」或「物件陣列」，而不是簡單的二維基本型態陣列。例如：`Student students[10][5];`

#### 與鍊結串列 (Linked Lists) 的關聯：
*   **記憶體佈局：** 陣列（包括二維陣列）的元素在記憶體中是連續儲存的，而鍊結串列的節點可以分散在記憶體中，透過指標連結。
*   **存取效率：** 陣列提供 $O(1)$ 的隨機存取（直接透過索引），而鍊結串列則需要 $O(N)$ 的時間來遍歷到特定位置。
*   **彈性：** 鍊結串列在插入和刪除元素時效率較高 ($O(1)$)，而陣列在中間插入或刪除元素時可能需要移動大量元素 ($O(N)$)。二維陣列的大小在宣告時通常是固定的（靜態），而鍊結串列則可動態增長或縮小。

-----

### 4. 進階內容

#### 鋸齒陣列 (Jagged Arrays) / 不規則陣列：
在某些程式語言（如 C#、Java 的多維陣列，C/C++ 中使用指標的陣列）中，可以實現「鋸齒陣列」。這是一種每一行的長度可以不同的二維陣列。它本質上是一個「陣列的陣列」，但內部的一維陣列（行）可以有不同的長度。

**概念範例 (類似 C# 或 Java)：**
```
int[][] jaggedArray = new int[3][]; // 宣告一個有 3 行的鋸齒陣列

jaggedArray[0] = new int[5]; // 第一行有 5 個元素
jaggedArray[1] = new int[2]; // 第二行有 2 個元素
jaggedArray[2] = new int[4]; // 第三行有 4 個元素

// 初始化元素
jaggedArray[0][0] = 10;
jaggedArray[1][1] = 20;
// ...
```
鋸齒陣列在處理不規則形狀的資料時非常有用，例如儲存不同長度學生清單的班級陣列。

#### 多維陣列 (Multidimensional Arrays)：
二維陣列的概念可以推廣到更高維度，例如三維陣列 (three-dimensional arrays)。三維陣列可以想像成一個立體魔術方塊，每個元素需要三個索引來定位：`array[depth][row][column]`。
更高維度的陣列在處理更複雜的資料結構時會用到，例如在物理模擬或圖形學中表示三維空間。

#### 動態二維陣列 (Dynamic Two-Dimensional Arrays)：
靜態二維陣列的大小在編譯時期就已確定。然而，在許多應用中，我們可能需要在程式執行時才知道陣列的確切大小。這時就需要使用動態二維陣列。

**概念範例 (類似 C++ 使用指標)：**
```cpp
int rows, cols;
// 從使用者獲取 rows 和 cols
// ...

// 步驟 1: 宣告一個指向 int 陣列的指標陣列 (代表行)
int** dynamicMatrix = new int*[rows];

// 步驟 2: 為每一行分配記憶體 (代表列)
for (int i = 0; i < rows; i++) {
    dynamicMatrix[i] = new int[cols];
}

// 現在 dynamicMatrix 就可以像普通的二維陣列一樣使用：
dynamicMatrix[0][0] = 100;
dynamicMatrix[rows-1][cols-1] = 200;

// ... 使用陣列 ...

// 步驟 3: 釋放記憶體 (非常重要，防止記憶體洩漏)
for (int i = 0; i < rows; i++) {
    delete[] dynamicMatrix[i]; // 釋放每一行的記憶體
}
delete[] dynamicMatrix; // 釋放行的指標陣列
dynamicMatrix = nullptr; // 避免懸空指標
```
在 Python 等高階語言中，動態二維陣列通常透過「列表的列表」（list of lists）來實現，其記憶體管理由語言自動處理。

-----

### 5. 常見錯誤與澄清

#### 1. 越界存取 (Out-of-bounds Access)：
*   **錯誤：** 嘗試存取不存在的行或列索引。例如，一個 $3 \times 4$ 的陣列 `matrix[3][4]`，合法索引範圍是 `matrix[0..2][0..3]`。存取 `matrix[3][0]` 或 `matrix[0][4]` 都會導致錯誤。
*   **澄清：** 這是程式執行時常見的錯誤，可能導致程式崩潰或不可預測的行為（例如讀取到垃圾資料或覆寫了其他記憶體區域）。務必確保使用迴圈或直接存取時，索引值都在有效範圍內：`0 <= row_index < total_rows` 且 `0 <= col_index < total_columns`。

#### 2. 混淆行與列索引：
*   **錯誤：** 將 `array[row][column]` 誤寫為 `array[column][row]`。
*   **澄清：** 大多數程式語言的慣例是第一個索引代表行，第二個代表列。在設計演算法或遍歷時，務必保持一致性。如果交換了索引，可能會導致存取到錯誤的元素或在處理矩陣時得到錯誤的結果（例如，將矩陣轉置了）。

#### 3. 靜態與動態陣列的記憶體管理：
*   **錯誤：** 對於動態分配的二維陣列，忘記釋放所有分配的記憶體。
*   **澄清：** 如果使用 `new` (C++) 或 `malloc` (C) 動態分配記憶體，必須對每個 `new` 或 `malloc` 使用對應的 `delete` 或 `free`。對於二維陣列，這意味著要先釋放每一行的記憶體，然後再釋放儲存行指標的記憶體。忘記釋放會導致記憶體洩漏。

#### 4. 初始化問題：
*   **錯誤：** 宣告二維陣列後未初始化，直接使用其內容。
*   **澄清：** 未初始化的陣列元素會包含「垃圾值」（前一個程式遺留在該記憶體位置的任意值）。在實際使用前，應該對陣列進行適當的初始化，例如全部設為 0，或者填入有意義的初始值。

-----

### 6. 小練習（附詳解）

#### 小練習 1：計算二維陣列所有元素的總和

**題目：**
給定一個 $3 \times 3$ 的整數二維陣列 `int matrix[3][3]`，請撰寫程式計算並輸出該陣列中所有元素的總和。

**輸入範例：**
```
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**預期輸出：**
`陣列元素的總和為: 45`

**詳解：**

1.  **初始化總和變數：** 宣告一個整數變數 `sum` 並初始化為 `0`，用來累積所有元素的和。
2.  **外層迴圈遍歷行：** 使用一個 `for` 迴圈，從行索引 `0` 遍歷到 `總行數 - 1`。
3.  **內層迴圈遍歷列：** 在外層迴圈內部，再使用一個 `for` 迴圈，從列索引 `0` 遍歷到 `總列數 - 1`。
4.  **累加元素：** 在內層迴圈中，將當前遍歷到的 `matrix[i][j]` 元素加到 `sum` 變數中。
5.  **輸出結果：** 迴圈結束後，輸出 `sum` 的值。

**程式碼範例 (概念性)：**
```
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

int sum = 0;

for (int i = 0; i < 3; i++) { // 遍歷行
    for (int j = 0; j < 3; j++) { // 遍歷列
        sum = sum + matrix[i][j]; // 或 sum += matrix[i][j];
    }
}

print("陣列元素的總和為: " + sum); // 輸出 45
```

-----

#### 小練習 2：找出二維陣列中的最大值

**題目：**
給定一個 $4 \times 5$ 的整數二維陣列 `int data[4][5]`，請撰寫程式找出並輸出該陣列中的最大值。

**輸入範例：**
```
int data[4][5] = {
    {10, 25, 30, 15, 5},
    {40, 55, 60, 45, 35},
    {70, 85, 90, 75, 65},
    {20, 99, 50, 80, 100}
};
```

**預期輸出：**
`陣列中的最大值為: 100`

**詳解：**

1.  **初始化最大值變數：** 宣告一個整數變數 `maxValue`。將其初始化為陣列中的第一個元素 `data[0][0]`，或者初始化為一個足夠小的負數（如果陣列可能包含負數）。
2.  **外層迴圈遍歷行：** 使用一個 `for` 迴圈，從行索引 `0` 遍歷到 `總行數 - 1`。
3.  **內層迴圈遍歷列：** 在外層迴圈內部，再使用一個 `for` 迴圈，從列索引 `0` 遍歷到 `總列數 - 1`。
4.  **比較與更新：** 在內層迴圈中，將當前遍歷到的 `data[i][j]` 元素與 `maxValue` 進行比較。如果 `data[i][j]` 大於 `maxValue`，則更新 `maxValue` 為 `data[i][j]`。
5.  **輸出結果：** 迴圈結束後，輸出 `maxValue` 的值。

**程式碼範例 (概念性)：**
```
int data[4][5] = {
    {10, 25, 30, 15, 5},
    {40, 55, 60, 45, 35},
    {70, 85, 90, 75, 65},
    {20, 99, 50, 80, 100}
};

int maxValue = data[0][0]; // 初始化為第一個元素，或者 Integer.MIN_VALUE

for (int i = 0; i < 4; i++) { // 遍歷行
    for (int j = 0; j < 5; j++) { // 遍歷列
        if (data[i][j] > maxValue) {
            maxValue = data[i][j];
        }
    }
}

print("陣列中的最大值為: " + maxValue); // 輸出 100
```

-----

### 7. 延伸閱讀/參考

*   **資料結構與演算法教材：** 任何關於資料結構和演算法的教科書都會深入探討陣列。
*   **程式語言官方文件：** 查閱你正在使用的程式語言（C++, Java, Python, C# 等）關於陣列的官方文件，了解其具體的宣告、初始化和操作細節。
*   **線性代數：** 學習線性代數可以幫助你更好地理解矩陣運算，進而提升使用二維陣列解決數學問題的能力。
*   **計算幾何與影像處理：** 許多圖形學和影像處理的演算法都大量使用二維陣列來表示和操作圖像資料。