# 雙向與環狀鏈結串列

## 前言

在資料結構的世界中，鏈結串列（Linked List）是一種基礎且靈活的線性資料結構。它由一系列節點（Node）組成，每個節點包含資料（Data）和指向下一個節點的參考（Reference/Pointer）。單向鏈結串列（Singly Linked List）因其簡單性而被廣泛使用，但其只能單向遍歷的特性，以及在某些操作（如刪除特定節點前需找到其前一個節點）上的效率限制，促使了更進階的變體——雙向鏈結串列與環狀鏈結串列的誕生。

本教材將深入探討這兩種鏈結串列的結構、操作與應用，並比較它們與單向鏈結串列的異同，幫助讀者掌握其核心概念與實作技巧。

-----

## ### 1. 雙向鏈結串列 (Doubly Linked List)

雙向鏈結串列是單向鏈結串列的擴展，其主要特點是每個節點除了指向後一個節點的指針外，還額外包含一個指向前一個節點的指針。這使得我們可以從任一節點向前後兩個方向移動，極大地提升了操作的靈活性。

#### #### 1.1 核心概念與定義

*   **定義:** 雙向鏈結串列是一種由節點組成的序列，其中每個節點包含三個部分：
    1.  **資料 (Data):** 儲存實際的資訊。
    2.  **前一個節點指針 (Previous Pointer / `prev`):** 指向鏈結串列中前一個節點的參考。
    3.  **下一個節點指針 (Next Pointer / `next`):** 指向鏈結串列中後一個節點的參考。

*   **串列結構:**
    *   通常會有一個 `head` 指針指向串列的第一個節點。
    *   通常也會有一個 `tail` 指針指向串列的最後一個節點。
    *   `head` 節點的 `prev` 指針為 `NULL` (或空)。
    *   `tail` 節點的 `next` 指針為 `NULL` (或空)。

#### #### 1.2 典型例子與操作

以下以 Python 偽碼形式展示雙向鏈結串列的節點結構與基本操作。

```python
# 節點結構
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# 雙向鏈結串列結構
class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # 1. 插入節點
    #### 在串列前端插入
    def insert_at_beginning(self, data):
        new_node = Node(data)
        if self.head is None: # 串列為空
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    #### 在串列末端插入
    def insert_at_end(self, data):
        new_node = Node(data)
        if self.tail is None: # 串列為空
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    #### 在指定節點後方插入 (假設已知 existing_node)
    def insert_after_node(self, existing_node, data):
        if existing_node is None:
            print("指定節點不能為空。")
            return
        
        new_node = Node(data)
        new_node.next = existing_node.next
        new_node.prev = existing_node
        existing_node.next = new_node
        
        if new_node.next is not None: # 如果不是在末尾插入
            new_node.next.prev = new_node
        else: # 如果是在末尾插入，更新 tail
            self.tail = new_node

    # 2. 刪除節點
    def delete_node(self, node_to_delete):
        if node_to_delete is None:
            print("要刪除的節點不能為空。")
            return

        # 如果是 head 節點
        if node_to_delete == self.head:
            self.head = node_to_delete.next
            if self.head is not None:
                self.head.prev = None
            else: # 串列變成空的
                self.tail = None
            return
        
        # 如果是 tail 節點
        if node_to_delete == self.tail:
            self.tail = node_to_delete.prev
            if self.tail is not None:
                self.tail.next = None
            else: # 串列變成空的
                self.head = None
            return

        # 一般情況 (中間節點)
        if node_to_delete.prev is not None:
            node_to_delete.prev.next = node_to_delete.next
        if node_to_delete.next is not None:
            node_to_delete.next.prev = node_to_delete.prev

        # 釋放節點（Python 會自動垃圾回收，其他語言可能需要手動釋放）
        node_to_delete.next = None
        node_to_delete.prev = None

    # 3. 遍歷串列
    #### 從頭部向前遍歷
    def traverse_forward(self):
        current = self.head
        elements = []
        while current:
            elements.append(current.data)
            current = current.next
        print("向前遍歷:", " <-> ".join(map(str, elements)))

    #### 從尾部向後遍歷
    def traverse_backward(self):
        current = self.tail
        elements = []
        while current:
            elements.append(current.data)
            current = current.prev
        print("向後遍歷:", " <-> ".join(map(str, elements)))

# 範例使用
dll = DoublyLinkedList()
dll.insert_at_end(10) # 10
dll.insert_at_beginning(5) # 5 <-> 10
dll.insert_at_end(20) # 5 <-> 10 <-> 20
dll.traverse_forward() # 向前遍歷: 5 <-> 10 <-> 20
dll.traverse_backward() # 向後遍歷: 20 <-> 10 <-> 5

# 找到節點10來在它後面插入15
current_node = dll.head
while current_node and current_node.data != 10:
    current_node = current_node.next
if current_node:
    dll.insert_after_node(current_node, 15) # 5 <-> 10 <-> 15 <-> 20
dll.traverse_forward() # 向前遍歷: 5 <-> 10 <-> 15 <-> 20

# 刪除節點10
current_node = dll.head
while current_node and current_node.data != 10:
    current_node = current_node.next
if current_node:
    dll.delete_node(current_node) # 5 <-> 15 <-> 20
dll.traverse_forward() # 向前遍歷: 5 <-> 15 <-> 20
dll.traverse_backward() # 向後遍歷: 20 <-> 15 <-> 5
```

#### #### 1.3 與單向鏈結串列的關聯

*   **優點:**
    *   **雙向遍歷:** 可以從任意節點向前後兩個方向遍歷，這對於某些需要反向操作的演算法非常有用。
    *   **高效刪除:** 當給定一個要刪除的節點時，可以直接訪問其前一個和後一個節點，因此刪除操作的時間複雜度為 $O(1)$。在單向鏈結串列中，要刪除一個節點，必須先從頭部開始遍歷找到其前一個節點，時間複雜度為 $O(N)$。
    *   **高效插入（在指定節點前）：** 類似刪除，可以 $O(1)$ 時間在指定節點之前插入新節點。

*   **缺點:**
    *   **額外記憶體開銷:** 每個節點需要多儲存一個 `prev` 指針，導致每個節點的記憶體佔用增加。
    *   **操作複雜性增加:** 插入和刪除操作需要更新兩個指針（`prev` 和 `next`），而不是單向鏈結串列中的一個，這使得操作邏輯更為複雜，更容易出錯。

-----

## ### 2. 環狀鏈結串列 (Circular Linked List)

環狀鏈結串列是一種特殊的鏈結串列，它的最後一個節點的 `next` 指針不指向 `NULL`，而是指向串列的第一個節點。這形成了一個循環，使得串列沒有明確的起點和終點。

#### #### 2.1 核心概念與定義

*   **定義:** 環狀鏈結串列是一種鏈結串列，其中所有節點被連接成一個環。
    *   **單向環狀鏈結串列:** 最後一個節點的 `next` 指針指向第一個節點。
    *   **雙向環狀鏈結串列:** 最後一個節點的 `next` 指針指向第一個節點，且第一個節點的 `prev` 指針指向最後一個節點。

*   **串列結構:**
    *   通常只維護一個指針，指向**最後一個節點 (`tail`)**。透過 `tail.next` 即可訪問到第一個節點 (`head`)。
    *   從 `head` 或 `tail` 開始，可以無限遍歷整個串列。

#### #### 2.2 典型例子與操作

以下以 Python 偽碼形式展示單向環狀鏈結串列的節點結構與基本操作。

```python
# 節點結構（與單向鏈結串列相同）
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# 單向環狀鏈結串列結構
class CircularLinkedList:
    def __init__(self):
        self.tail = None # 通常指向最後一個節點

    # 1. 插入節點
    #### 在空串列中插入
    def _insert_into_empty(self, new_node):
        self.tail = new_node
        self.tail.next = self.tail # 自己指向自己

    #### 在串列前端插入
    def insert_at_beginning(self, data):
        new_node = Node(data)
        if self.tail is None: # 串列為空
            self._insert_into_empty(new_node)
        else:
            new_node.next = self.tail.next # 新節點指向原來的頭部
            self.tail.next = new_node # 尾部指向新節點，使其成為新的頭部

    #### 在串列末端插入
    def insert_at_end(self, data):
        new_node = Node(data)
        if self.tail is None: # 串列為空
            self._insert_into_empty(new_node)
        else:
            new_node.next = self.tail.next # 新節點指向原來的頭部
            self.tail.next = new_node # 原尾部指向新節點
            self.tail = new_node # 更新尾部為新節點

    # 2. 刪除節點 (假設刪除第一個出現的特定值)
    def delete_node_by_value(self, value):
        if self.tail is None:
            print("串列為空，無法刪除。")
            return

        # 找到要刪除的節點及其前一個節點
        current = self.tail.next # 從頭部開始
        prev = self.tail
        
        while True:
            if current.data == value:
                break
            prev = current
            current = current.next
            if current == self.tail.next: # 遍歷了一圈回到起點，表示沒找到
                print(f"找不到值為 {value} 的節點。")
                return

        # 處理刪除
        if current == self.tail.next: # 刪除的是頭部節點
            if self.tail.next == self.tail: # 只有一個節點
                self.tail = None
            else:
                self.tail.next = current.next
        elif current == self.tail: # 刪除的是尾部節點
            prev.next = current.next # prev.next 指向原頭部
            self.tail = prev # 更新尾部
        else: # 刪除的是中間節點
            prev.next = current.next
        
        # 清除被刪除節點的指針
        current.next = None

    # 3. 遍歷串列
    def traverse(self):
        if self.tail is None:
            print("串列為空。")
            return
        
        elements = []
        current = self.tail.next # 從頭部開始
        while True:
            elements.append(current.data)
            current = current.next
            if current == self.tail.next: # 回到起點，停止
                break
        print("環狀串列遍歷:", " -> ".join(map(str, elements)))

# 範例使用
cll = CircularLinkedList()
cll.insert_at_end(10) # 10 (tail points to 10, 10.next points to 10)
cll.insert_at_beginning(5) # 5 -> 10 (tail points to 10, 10.next points to 5)
cll.insert_at_end(20) # 5 -> 10 -> 20 (tail points to 20, 20.next points to 5)
cll.traverse() # 環狀串列遍歷: 5 -> 10 -> 20

cll.delete_node_by_value(10) # 5 -> 20
cll.traverse() # 環狀串列遍歷: 5 -> 20

cll.delete_node_by_value(5) # 20
cll.traverse() # 環狀串列遍歷: 20

cll.delete_node_by_value(20) # 串列為空
cll.traverse() # 串列為空。
```

#### #### 2.3 與單向/雙向鏈結串列的關聯

*   **優點:**
    *   **無限遍歷:** 可以從任何節點開始遍歷整個串列，而無需擔心到達 `NULL`。這對於需要循環處理的應用（如任務排程、遊戲中的輪流機制）非常有用。
    *   **高效訪問頭尾:** 如果只維護一個 `tail` 指針，可以 $O(1)$ 時間訪問到頭部（`tail.next`）和尾部（`tail`），這比單向鏈結串列需要遍歷 $O(N)$ 時間才能找到尾部要快。
    *   **簡化某些演算法:** 例如約瑟夫問題 (Josephus Problem) 可以很自然地用環狀鏈結串列來模擬。
    *   **無空指針檢查:** 在遍歷或移動時，無需檢查 `next` 指針是否為 `NULL`，因為它總是指向另一個節點。

*   **缺點:**
    *   **實現更複雜:** 相較於單向鏈結串列，環狀鏈結串列的插入和刪除邏輯會稍微複雜，需要特別處理只有一個節點或空串列的情況，且必須確保環的完整性。
    *   **潛在無限循環:** 如果遍歷邏輯不正確，很容易陷入無限循環。
    *   **無法直接判斷終點:** 需要額外判斷機制（如遍歷回到起點時停止）才能確定是否已遍歷整個串列。

#### #### 2.4 進階內容：雙向環狀鏈結串列

雙向環狀鏈結串列結合了雙向鏈結串列和環狀鏈結串列的特性。它的每個節點都有 `prev` 和 `next` 指針，並且 `head` 的 `prev` 指針指向 `tail`，`tail` 的 `next` 指針指向 `head`。

*   **核心概念:**
    *   `head.prev` ➔ `tail`
    *   `tail.next` ➔ `head`
*   **優點:**
    *   提供了雙向遍歷的靈活性，同時保持了環狀串列的無邊界特性。
    *   在任何位置的插入和刪除操作都可以高效完成，因為可以從任何點向前後兩個方向移動。
*   **應用:** 適合需要高度靈活性和循環結構的應用，例如最近最少使用 (LRU) 快取策略的實現。

-----

## ### 3. 常見錯誤與澄清

*   **指針更新不完整 (尤其在雙向鏈結串列):** 這是最常見的錯誤。在插入或刪除節點時，務必確保 `prev` 和 `next` 指針都正確地指向了新節點或被跳過的節點。忘記更新其中任何一個指針都可能導致鏈結斷裂或數據丟失。
    *   **澄清:** 想像將一個節點從鏈條中取出，需要將它兩邊的節點重新連接起來。對於雙向，就是重新連接兩側的 `next` 和 `prev` 各一個。
*   **環狀鏈結串列的遍歷終止條件:** 初學者常忘記在環狀串列中設置正確的遍歷終止條件，導致無限循環。
    *   **澄清:** 應該判斷當前節點是否再次回到**起點節點**時停止遍歷。
*   **邊界條件處理不當:**
    *   **空串列:** 在對空串列執行插入或刪除操作時，要特別處理 `head`/`tail` 指針的初始化。
    *   **單一節點串列:** 在只有一個節點的串列中插入或刪除，需要特殊邏輯來維護 `head`/`tail` 指針的正確性。對於環狀串列，單一節點的 `next` 指針應該指向自身。
*   **記憶體洩漏 (C/C++ 等手動管理記憶體的語言):** 刪除節點後忘記釋放其佔用的記憶體。
    *   **澄清:** 在 `delete_node` 操作後，確保被刪除的節點被系統回收。

-----

## ### 4. 小練習（附詳解）

#### #### 小練習 1: 雙向鏈結串列 - 在指定值之前插入節點

**題目:**
請為上述 `DoublyLinkedList` 類別添加一個方法 `insert_before_value(self, existing_value, new_data)`，該方法會在串列中找到第一個值為 `existing_value` 的節點，並在其前方插入一個包含 `new_data` 的新節點。如果 `existing_value` 不存在，則在串列末尾插入。

**步驟:**

1.  **處理空串列:** 如果串列為空，直接插入為唯一節點。
2.  **遍歷尋找目標節點:** 從 `head` 開始遍歷，直到找到 `existing_value` 或遍歷結束。
3.  **處理目標節點為 `head` 的情況:** 如果找到的目標節點是 `head`，則調用 `insert_at_beginning` 方法。
4.  **處理目標節點為中間或不存在的情況:**
    *   如果找到了目標節點（且不是 `head`），則在其 `prev` 節點後插入新節點。這涉及更新新節點、目標節點和其 `prev` 節點的 `prev` 和 `next` 指針。
    *   如果沒有找到目標節點，則在串列末尾插入。

**參考解答:**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert_at_beginning(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    def insert_at_end(self, data):
        new_node = Node(data)
        if self.tail is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        elements = []
        while current:
            elements.append(current.data)
            current = current.next
        print("向前遍歷:", " <-> ".join(map(str, elements)))

    # 新增方法
    def insert_before_value(self, existing_value, new_data):
        new_node = Node(new_data)
        
        if self.head is None: # 串列為空，直接插入
            self.head = new_node
            self.tail = new_node
            return

        current = self.head
        while current and current.data != existing_value:
            current = current.next

        if current is None: # 未找到 existing_value，在末尾插入
            self.insert_at_end(new_data)
        elif current == self.head: # 找到 existing_value 且是頭部
            self.insert_at_beginning(new_data)
        else: # 找到 existing_value 且在中間
            prev_node = current.prev
            
            new_node.next = current
            new_node.prev = prev_node
            
            prev_node.next = new_node
            current.prev = new_node

# 測試
print("--- 小練習 1 測試 ---")
dll_exercise = DoublyLinkedList()
dll_exercise.insert_at_end(10)
dll_exercise.insert_at_end(30)
dll_exercise.insert_before_value(30, 20) # 10 <-> 20 <-> 30
dll_exercise.traverse_forward()

dll_exercise.insert_before_value(10, 5) # 5 <-> 10 <-> 20 <-> 30
dll_exercise.traverse_forward()

dll_exercise.insert_before_value(40, 35) # 未找到40，在末尾插入35：5 <-> 10 <-> 20 <-> 30 <-> 35
dll_exercise.traverse_forward()

dll_exercise_empty = DoublyLinkedList()
dll_exercise_empty.insert_before_value(100, 1) # 空串列插入：1
dll_exercise_empty.traverse_forward()
```

-----

#### #### 小練習 2: 環狀鏈結串列 - 尋找並返回特定值節點

**題目:**
請為上述 `CircularLinkedList` 類別添加一個方法 `find_node_by_value(self, value)`，該方法在環狀串列中尋找第一個值為 `value` 的節點並返回它。如果沒有找到，則返回 `None`。

**步驟:**

1.  **處理空串列:** 如果串列為空，直接返回 `None`。
2.  **遍歷尋找:** 從 `tail.next` (即頭部) 開始遍歷。
3.  **終止條件:** 遍歷過程中，如果當前節點的資料與 `value` 匹配，則返回該節點。如果遍歷一圈回到 `tail.next` 仍未找到，則表示不存在，返回 `None`。

**參考解答:**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.tail = None

    def _insert_into_empty(self, new_node):
        self.tail = new_node
        self.tail.next = self.tail

    def insert_at_end(self, data):
        new_node = Node(data)
        if self.tail is None:
            self._insert_into_empty(new_node)
        else:
            new_node.next = self.tail.next
            self.tail.next = new_node
            self.tail = new_node

    def traverse(self):
        if self.tail is None:
            print("串列為空。")
            return
        
        elements = []
        current = self.tail.next
        while True:
            elements.append(current.data)
            current = current.next
            if current == self.tail.next:
                break
        print("環狀串列遍歷:", " -> ".join(map(str, elements)))

    # 新增方法
    def find_node_by_value(self, value):
        if self.tail is None: # 串列為空
            return None
        
        current = self.tail.next # 從頭部開始
        while True:
            if current.data == value:
                return current
            current = current.next
            if current == self.tail.next: # 遍歷一圈，回到起點
                break
        return None # 未找到

# 測試
print("\n--- 小練習 2 測試 ---")
cll_exercise = CircularLinkedList()
cll_exercise.insert_at_end(10)
cll_exercise.insert_at_end(20)
cll_exercise.insert_at_end(30)
cll_exercise.traverse()

node_20 = cll_exercise.find_node_by_value(20)
if node_20:
    print(f"找到節點: {node_20.data}") # 找到節點: 20
else:
    print("未找到節點 20")

node_40 = cll_exercise.find_node_by_value(40)
if node_40:
    print(f"找到節點: {node_40.data}")
else:
    print("未找到節點 40") # 未找到節點 40

cll_empty = CircularLinkedList()
node_empty = cll_empty.find_node_by_value(1)
if node_empty:
    print("找到節點 (空串列不應找到)")
else:
    print("空串列中未找到節點 (正確)") # 空串列中未找到節點 (正確)
```

-----

## ### 5. 延伸閱讀/參考

*   **資料結構與演算法經典教材:**
    *   《資料結構與演算法分析 (Data Structures and Algorithm Analysis)》- Mark Allen Weiss
    *   《演算法導論 (Introduction to Algorithms)》- Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
*   **線上資源:**
    *   **GeeksforGeeks:** 提供大量關於鏈結串列（包括雙向和環狀）的詳細解釋和程式碼實作範例。
        *   [Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list/)
        *   [Circular Linked List](https://www.geeksforgeeks.org/circular-linked-list/)
    *   **Wikipedia:** 提供概念性定義和理論背景。
        *   [雙向鏈表](https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8)
        *   [循環鏈表](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8)

透過深入理解雙向與環狀鏈結串列，您將能更好地選擇和設計適合特定應用場景的資料結構，提升程式碼的效率和可靠性。