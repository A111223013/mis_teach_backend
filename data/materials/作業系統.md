# 作業系統概論

作業系統 (Operating System, OS) 是電腦系統中最核心的軟體，它管理電腦硬體與軟體資源，並為電腦程式提供共用服務。沒有作業系統，電腦就只是一堆無用的硬體。本章節將深入探討作業系統的定義、核心功能、主要架構，以及它如何與應用程式互動。

-----

### 1. 核心概念：作業系統的定義與功能

#### 1.1 什麼是作業系統？

*   **定義/核心觀念：**
    作業系統是位於使用者應用程式與硬體之間的一層軟體，其主要職責是管理所有電腦資源（包括 CPU、記憶體、儲存裝置、I/O 裝置等），並為應用程式提供一個穩定且安全的執行環境。它作為硬體與軟體資源的中介，簡化了應用程式開發者與硬體設備互動的複雜性。

*   **例子：**
    我們日常生活中常見的作業系統包括：
    *   **個人電腦：** Microsoft Windows、Apple macOS、各種 Linux 發行版 (如 Ubuntu, Fedora)。
    *   **行動裝置：** Google Android、Apple iOS。
    *   **伺服器：** Linux (Red Hat, CentOS)、Windows Server、UNIX (Solaris, FreeBSD)。

*   **與相鄰概念的關聯：**
    作業系統可以被視為使用者與硬體之間的「橋樑」或「翻譯者」。使用者透過應用程式發出指令，應用程式再透過作業系統提供的介面（稱為「系統呼叫」）來請求硬體服務。如果沒有作業系統，應用程式將需要直接控制硬體，這不僅複雜且容易出錯。

-----

#### 1.2 作業系統的五大核心功能

作業系統透過管理資源來實現其核心職責，這些管理功能通常分為以下幾大類：

##### 1.2.1 處理器管理 (Processor Management)

*   **定義/核心觀念：**
    處理器管理，又稱 CPU 排程 (CPU Scheduling)，是指作業系統負責分配 CPU 的使用時間給各個正在執行的程式 (進程)。它的目標是最大化 CPU 利用率，同時確保系統的公平性、效率和響應速度。

*   **例子：**
    當你同時開啟網頁瀏覽器、音樂播放器和文件編輯器時，作業系統會迅速在這些程式之間切換 CPU 的使用權，讓你感覺它們似乎都在「同時」運行，這就是多工處理 (Multitasking) 的實現。常見的排程演算法包括先來先服務 (FCFS)、短作業優先 (SJF)、優先權排程 (Priority Scheduling) 和時間分割 (Round Robin)。

*   **與相鄰概念的關聯：**
    處理器管理與進程管理 (Process Management) 密不可分。作業系統將應用程式抽象為進程，然後對這些進程進行 CPU 時間的分配。它也與中斷處理相關，當中斷發生時，CPU 會暫停當前工作，轉而處理中斷請求，這也屬於處理器控制的一部分。

-----

##### 1.2.2 記憶體管理 (Memory Management)

*   **定義/核心觀念：**
    記憶體管理是作業系統負責追蹤記憶體使用情況、分配記憶體空間給進程、在進程完成後回收記憶體，並保護各進程的記憶體空間不被非法存取。其核心目標是有效利用有限的物理記憶體，並為進程提供一個看似連續且充足的記憶體空間。

*   **例子：**
    *   **虛擬記憶體 (Virtual Memory)：** 允許程式使用比實際物理記憶體更大的地址空間。作業系統將部分不常用資料暫時存放在硬碟上（交換空間/分頁檔案），當需要時再載入記憶體。這使得每個程式都可以擁有一個獨立、完整的虛擬地址空間。
    *   **分頁 (Paging)：** 記憶體管理的一種技術，將物理記憶體和虛擬記憶體都分割成固定大小的區塊（分頁），實現不連續的記憶體分配。

*   **與相鄰概念的關聯：**
    記憶體管理直接影響處理器管理的效率，因為 CPU 執行指令需要從記憶體中讀取。它也與檔案系統有部分關聯，例如檔案緩衝區 (buffer cache) 存放在記憶體中。記憶體保護則是系統安全的重要一環。

-----

##### 1.2.3 檔案管理 (File Management)

*   **定義/核心觀念：**
    檔案管理是作業系統負責組織、儲存、檢索、命名、保護和分享檔案與目錄的機制。它將儲存裝置（如硬碟、固態硬碟）的物理特性抽象化，為使用者提供一個邏輯上的檔案儲存視圖。

*   **例子：**
    *   **目錄結構：** 樹狀結構（如 `C:\Users\Documents` 或 `/home/user/documents`）。
    *   **檔案存取權限：** 例如，某個檔案只能由所有者讀寫，而其他人只能讀取。
    *   **檔案操作：** 建立、刪除、複製、移動、重新命名檔案等。

*   **與相鄰概念的關聯：**
    檔案管理依賴於 I/O 管理來讀寫儲存裝置。它也與記憶體管理協同工作，因為檔案內容在讀寫時需要載入到記憶體緩衝區。檔案存取權限是作業系統安全與保護功能的一部分。

-----

##### 1.2.4 輸入/輸出 (I/O) 管理

*   **定義/核心觀念：**
    I/O 管理是作業系統負責控制和協調電腦中的所有輸入/輸出設備（如鍵盤、滑鼠、顯示器、印表機、網路卡、硬碟等）。它提供了標準化的介面，使得應用程式可以不必了解設備的底層細節就能與之互動。

*   **例子：**
    *   **設備驅動程式 (Device Drivers)：** 作業系統通過驅動程式與特定硬體設備進行溝通。
    *   **緩衝區 (Buffering) 和快取 (Caching)：** 用來提高 I/O 操作的效率。
    *   **中斷處理 (Interrupt Handling)：** 當 I/O 設備完成操作或需要注意時，會發出中斷信號給 CPU。

*   **與相鄰概念的關聯：**
    I/O 管理與處理器管理緊密相關，因為 I/O 操作常常涉及 CPU 中斷。它也與記憶體管理有關，例如 I/O 緩衝區需要記憶體空間。檔案系統的大部分操作最終都會轉換為 I/O 操作。

-----

##### 1.2.5 安全與保護 (Security and Protection)

*   **定義/核心觀念：**
    安全與保護是指作業系統透過各種機制，保護系統資源（如 CPU、記憶體、檔案、I/O 設備）免受未授權的存取和惡意程式的破壞。保護主要是管理系統內部資源的存取權限，而安全則更廣泛地涵蓋了外部威脅（如惡意軟體、網路攻擊）。

*   **例子：**
    *   **使用者帳戶和權限管理：** 區分普通使用者、管理員等，並賦予不同的存取權限。
    *   **記憶體保護：** 確保一個進程不能讀寫另一個進程的記憶體空間。
    *   **檔案存取控制：** 讀、寫、執行等權限設定。
    *   **防火牆和惡意軟體掃描：** 抵禦外部網路攻擊和病毒。

*   **與相鄰概念的關聯：**
    安全與保護貫穿於所有其他的管理功能中。例如，記憶體管理確保了記憶體保護，檔案管理提供了檔案存取權限，處理器管理則負責特權指令的執行模式。

-----

### 2. 作業系統的架構類型

作業系統核心 (Kernel) 的設計方式對其性能、可靠性和擴展性有著顯著影響。主要有以下幾種架構類型：

#### 2.1 巨集核心 (Monolithic Kernel)

*   **定義/核心觀念：**
    巨集核心架構中，所有作業系統服務（如進程管理、記憶體管理、檔案系統、設備驅動程式等）都運行在單一的地址空間中，也就是核心空間 (Kernel Space)。這些服務之間可以直接通訊，無需跨越核心邊界。

*   **例子：**
    傳統的 UNIX 系統、以及 Linux 都是巨集核心的典型例子。它們將大部分作業系統功能都整合在單一的核心模組中。

*   **與相鄰概念的關聯：**
    *   **優點：** 服務之間的直接通訊使得執行效率高、性能好。開發初期較為簡單，因為所有功能都在同一個環境下開發。
    *   **缺點：** 由於所有服務都在核心空間，任何一個服務的錯誤都可能導致整個系統崩潰。系統龐大且複雜，難以維護和擴展。新增或移除功能需要重新編譯整個核心。

-----

#### 2.2 微核心 (Microkernel)

*   **定義/核心觀念：**
    微核心架構將大部分作業系統服務（如檔案系統、記憶體管理、設備驅動程式）從核心空間移到使用者空間 (User Space) 作為獨立的服務進程運行。核心本身只保留最基本的功能，例如進程間通訊 (IPC)、記憶體管理的基本機制以及底層的硬體處理。

*   **例子：**
    Mach (早期 macOS 的基礎)、Minix (Linux 的靈感來源之一)。

*   **與相鄰概念的關聯：**
    *   **優點：**
        *   **高可靠性：** 由於大部分服務在使用者空間運行，即使某個服務崩潰，也不會導致整個核心崩潰。
        *   **模組化和可擴展性：** 服務可以獨立開發、測試和部署。新增功能只需新增一個使用者空間的服務進程。
        *   **安全性：** 更小的核心攻擊面。
    *   **缺點：**
        *   **性能開銷：** 由於服務之間需要透過核心進行進程間通訊 (IPC)，會產生額外的上下文切換和訊息傳遞開銷，導致性能下降。
        *   **複雜性：** 設計和實現進程間通訊機制本身就非常複雜。

-----

#### 2.3 混合核心 (Hybrid Kernel)

*   **定義/核心觀念：**
    混合核心是介於巨集核心和微核心之間的一種架構，旨在結合兩者的優點。它會將一些被認為對性能至關重要的服務（如部分設備驅動程式、檔案系統）保留在核心空間，而將其他服務則放在使用者空間。

*   **例子：**
    Microsoft Windows NT 系列 (包括 Windows XP/7/10/11)、Apple macOS (基於 Mach 微核心，但在其之上增加了許多核心模組，使其行為更像巨集核心)。

*   **與相鄰概念的關聯：**
    *   **優點：** 試圖在性能和模組化/可靠性之間取得平衡。通常比純微核心性能更好，同時比純巨集核心更具模組化和一定的容錯能力。
    *   **缺點：** 設計上需要仔細權衡哪些服務應放在核心空間，哪些放在使用者空間，這可能增加設計的複雜性。

-----

### 3. 與相鄰概念的關聯：系統呼叫 (System Call) 與應用程式

應用程式無法直接存取硬體資源，它們必須透過作業系統來完成。這個互動的橋樑就是系統呼叫。

#### 3.1 系統呼叫 (System Call)

*   **定義/核心觀念：**
    系統呼叫是應用程式向作業系統核心請求服務的唯一標準化介面。當應用程式需要執行特權操作（如讀寫檔案、建立進程、分配記憶體等）時，它會發出一個系統呼叫。

*   **例子：**
    許多程式語言都有對應的函式庫來封裝系統呼叫：
    *   **檔案操作：** `open()`, `read()`, `write()`, `close()`。例如，C 語言中的 `fopen()` 函式內部會呼叫作業系統的 `open()` 系統呼叫。
    *   **進程控制：** `fork()` (建立新進程), `exec()` (執行新程式), `exit()` (終止進程)。
    *   **記憶體管理：** `brk()`, `mmap()` (記憶體映射)。
    *   **I/O 操作：** `ioctl()` (設備控制)。

*   **與相鄰概念的關聯：**
    系統呼叫是使用者模式程式與核心模式作業系統之間溝通的「閘道」。每次系統呼叫都會觸發一次使用者模式到核心模式的切換，這涉及到上下文切換的開銷。它是實現作業系統各項核心功能的關鍵機制。

-----

#### 3.2 執行模式 (Execution Modes)

*   **定義/核心觀念：**
    現代 CPU 通常支援兩種或多種執行模式，最常見的是：
    1.  **使用者模式 (User Mode)：** 應用程式在這種模式下運行。它只能存取被允許的記憶體區域，且不能執行特權指令（如直接操作 I/O 設備、修改 CPU 模式寄存器）。
    2.  **核心模式 (Kernel Mode / Supervisor Mode)：** 作業系統核心在這種模式下運行。它可以存取所有記憶體和硬體設備，並能執行所有指令，包括特權指令。

*   **推導：**
    CPU 內部有一個特殊的模式位元 (mode bit) 寄存器，用於指示當前 CPU 正在哪種模式下運行。
    *   當模式位元為 0 時，表示處於核心模式 (Kernel Mode)。
    *   當模式位元為 1 時，表示處於使用者模式 (User Mode)。
    當一個系統呼叫被發起時，會觸發一個軟體中斷（或稱陷阱/trap），CPU 會將模式位元從 1 設為 0，從而進入核心模式，並跳轉到作業系統的特定處理函式。在系統呼叫處理完成後，模式位元會被重新設回 1，CPU 返回使用者模式繼續執行應用程式。

*   **與相鄰概念的關聯：**
    執行模式是實現系統安全與保護的基礎。它確保了應用程式不能隨意破壞系統或存取敏感資源。系統呼叫是從使用者模式安全地轉換到核心模式的唯一合法途徑。

-----

### 4. 進階內容：進程 (Process) 與執行緒 (Thread) 簡介

為了更好地理解作業系統如何管理應用程式，我們需要了解進程與執行緒這兩個核心概念。

#### 4.1 進程 (Process)

*   **定義/核心觀念：**
    進程是執行中的程式實例。當你啟動一個應用程式時，作業系統就會為其建立一個或多個進程。每個進程都擁有自己獨立的虛擬地址空間、檔案描述符、寄存器狀態等資源。進程是資源分配的基本單位。

*   **例子：**
    *   你開啟的每一個 Word 文件應用程式實例，都是一個進程。
    *   你開啟的網頁瀏覽器，可能本身就是一個進程，或者其每個標籤頁都是獨立的進程（現代瀏覽器常見）。
    *   一個命令列指令，如 `ls -l`，執行時也會成為一個短暫的進程。

*   **與相鄰概念的關聯：**
    進程是作業系統進行資源管理（如記憶體分配、檔案存取權限）的基本單位。多個進程的並發執行是多工處理的核心。進程間通訊 (IPC) 是不同進程之間交換資訊的機制。

-----

#### 4.2 執行緒 (Thread)

*   **定義/核心觀念：**
    執行緒是進程內部的執行單元，它共享所屬進程的記憶體空間、檔案描述符等資源，但擁有自己獨立的執行堆疊 (stack)、程式計數器 (program counter) 和寄存器狀態。執行緒是 CPU 調度的基本單位。

*   **例子：**
    *   一個網頁瀏覽器進程可能有多個執行緒：一個執行緒負責頁面渲染，另一個執行緒負責網路下載，還有一個執行緒負責使用者介面互動。
    *   Word 應用程式中的拼寫檢查、儲存文件和使用者輸入可以在不同的執行緒中同時進行，而它們都屬於同一個 Word 進程。
    *   在遊戲中，一個執行緒負責渲染圖形，另一個執行緒負責處理物理引擎。

*   **與相鄰概念的關聯：**
    執行緒實現了進程內部的並行性。與進程相比，執行緒的建立和切換開銷更小，因為它們共享大部分資源。多執行緒程式設計是實現高效能、高響應性應用程式的常用方法。多個執行緒在同一進程內共享記憶體，這使得它們之間的資料共享比進程間通訊更高效，但也引入了同步和互斥的複雜性。

-----

### 5. 常見錯誤與澄清

*   **錯誤：作業系統就是電腦硬體。**
    *   **澄清：** 作業系統是一種軟體，它是管理硬體資源的程式集合。硬體是物理設備，作業系統是使這些設備協同工作、並能被使用者利用的「大腦」。它們是相輔相成的關係。

*   **錯誤：瀏覽器或應用程式就是作業系統。**
    *   **澄清：** 瀏覽器 (如 Chrome, Firefox) 和其他應用程式 (如 Word, Photoshop) 是在作業系統之上運行的「應用程式」。作業系統提供了一個平台和服務，讓這些應用程式能夠執行並存取硬體資源。應用程式需要作業系統才能運行。

*   **錯誤：進程和執行緒是相同的概念。**
    *   **澄清：** 進程是資源分配的基本單位，擁有獨立的記憶體空間和資源。執行緒是 CPU 調度的基本單位，是進程內部的執行流，共享進程的資源。可以將進程比喻為一個公司，而執行緒則是公司內的員工。每個公司 (進程) 都有自己的資產和辦公空間，而每個員工 (執行緒) 則在公司內部執行不同的任務。

-----

### 6. 小練習 (附詳解)

#### 練習一：辨識作業系統功能

**情境：** 當你雙擊一個應用程式圖示 (例如，啟動 Microsoft Word) 時，作業系統會經歷哪些核心功能才能成功啟動這個應用程式？請列出並簡要說明。

**步驟：**

1.  **判斷檔案管理相關動作。**
2.  **判斷記憶體管理相關動作。**
3.  **判斷處理器管理相關動作。**
4.  **判斷 I/O 管理相關動作。**
5.  **判斷安全與保護相關動作。**

**詳解：**

1.  **檔案管理：**
    *   使用者雙擊圖示，作業系統會使用檔案系統去尋找該應用程式的可執行檔案 (例如 `word.exe`) 的位置。
    *   它需要檢查使用者是否有執行該檔案的權限。

2.  **記憶體管理：**
    *   作業系統會為這個新啟動的 Word 應用程式 (一個新的進程) 分配一個獨立的虛擬地址空間。
    *   將 Word 可執行檔的代碼和資料從硬碟載入到進程的記憶體空間中。
    *   可能還會初始化堆疊 (stack) 和堆積 (heap) 區域。

3.  **處理器管理：**
    *   作業系統會為 Word 應用程式建立一個新的進程 (或多個進程和執行緒)。
    *   將這個新建立的進程或其主執行緒放入就緒佇列 (ready queue)，等待 CPU 的調度執行。
    *   當輪到 Word 進程執行時，CPU 會切換到 Word 進程的上下文，並開始執行其指令。

4.  **I/O 管理：**
    *   當 Word 啟動時，它可能需要讀取設定檔 (檔案 I/O)。
    *   初始化使用者介面時，它會向顯示器設備發送繪製指令 (輸出 I/O)。
    *   等待鍵盤和滑鼠的輸入 (輸入 I/O)。

5.  **安全與保護：**
    *   確認啟動應用程式的使用者具有足夠的權限。
    *   確保 Word 進程不能非法存取其他進程的記憶體空間。
    *   應用程式執行在使用者模式，不能直接操作特權硬體資源。

-----

#### 練習二：系統呼叫的角色

**情境：** 假設一個 C 程式執行了 `fp = fopen("data.txt", "r");` 這行程式碼，試解釋這個動作如何透過系統呼叫與作業系統互動。

**步驟：**

1.  **識別應用程式層級的請求。**
2.  **解釋如何進入核心模式。**
3.  **說明作業系統的處理。**
4.  **說明結果返回。**

**詳解：**

1.  **應用程式層級的請求：**
    *   `fopen("data.txt", "r")` 是 C 標準函式庫 (C Standard Library) 提供的一個函式。它是一個高級別的抽象，用於打開一個檔案以供讀取。
    *   這個函式本身並非系統呼叫，而是對一個或多個系統呼叫的封裝。

2.  **進入核心模式：**
    *   在 `fopen()` 函式的內部，它會最終呼叫作業系統提供的底層系統呼叫，例如 Linux/UNIX 系統中的 `open("data.txt", O_RDONLY)`。
    *   當 `open()` 系統呼叫被調用時，應用程式會觸發一個軟體中斷 (或陷阱)。
    *   CPU 偵測到這個中斷後，會將其執行模式從「使用者模式」切換到「核心模式」。同時，CPU 會將相關參數（如檔案名、打開模式）傳遞給作業系統。

3.  **作業系統的處理：**
    *   作業系統的核心接收到中斷後，會根據傳入的參數識別出這是 `open` 系統呼叫。
    *   **檔案管理：** 作業系統的檔案系統模組會開始工作。它會在磁碟的檔案目錄中尋找 `data.txt` 這個檔案。
    *   **安全與保護：** 檢查當前使用者是否有權限讀取這個檔案。
    *   **I/O 管理：** 如果檔案存在且權限允許，作業系統會準備好讀取檔案所需的內部結構 (例如，建立一個檔案描述符 File Descriptor)。這個檔案描述符是一個指向作業系統內部檔案表項的索引。
    *   **記憶體管理：** 可能會為檔案讀寫操作準備相關的緩衝區。

4.  **結果返回：**
    *   作業系統完成 `open` 操作後，會將檔案描述符 (一個整數值) 作為返回值。
    *   CPU 的執行模式會從「核心模式」切換回「使用者模式」。
    *   這個檔案描述符會層層返回，最終成為 `fopen()` 函式的返回值 (`fp` 指標)。
    *   應用程式現在可以使用這個 `fp` 指標來進行後續的 `fread()`、`fwrite()` 或 `fclose()` 等檔案操作，這些操作也會再次觸發系統呼叫與核心互動。

-----

### 7. 延伸閱讀/參考

*   **經典教材：**
    *   **Operating System Concepts (恐龍書)** by Abraham Silberschatz, Peter B. Galvin, Greg Gagne. (作業系統概念) - 這是一本全球大學廣泛使用的經典教材，內容詳盡且易於理解。
    *   **Modern Operating Systems** by Andrew S. Tanenbaum, Herbert Bos. (現代作業系統) - 另一本經典著作，以其對系統架構和設計理念的深入探討而聞名。

*   **線上資源：**
    *   **Linux Kernel Documentation:** 如果對 Linux 作業系統的核心運作機制感興趣，可以直接查閱 Linux 核心的官方文件和原始碼。
    *   **OSDev Wiki:** 一個專門為作業系統開發者提供資源和指南的社群維基。

*   **開源專案：**
    *   **Linux:** 作為最知名的開源作業系統，其原始碼是學習作業系統實作的絕佳材料。
    *   **FreeRTOS/RT-Thread:** 輕量級的即時作業系統 (RTOS)，適合學習小型嵌入式系統的作業系統原理。