# 1-3 資料模型

資料模型是資料庫設計的基石，它提供了一種抽象的語言和工具，用來描述資料的結構、資料之間的關係以及資料的限制。理解資料模型對於有效設計、實作和管理資料庫至關重要。

-----

### 1. 核心概念與定義

#### 什麼是資料模型？
資料模型 (Data Model) 是一組概念工具，用於描述資料、資料關係、資料語意以及資料限制。它提供了一種方式來抽象化地表示真實世界的資訊，並將其組織成適合在電腦系統中儲存和處理的結構。

**核心觀念：**
*   **抽象化 (Abstraction)：** 資料模型將現實世界的複雜性簡化，只保留與資料庫應用相關的關鍵資訊。
*   **溝通工具：** 它作為開發者、設計師和使用者之間溝通資料需求的共同語言。
*   **設計藍圖：** 資料模型是建立資料庫的藍圖，指導資料庫的實作過程。
*   **資料結構化：** 它定義了資料是如何組織和儲存的。

#### 資料模型的重要性
*   **清晰的理解：** 幫助設計者和使用者理解資料及其業務規則。
*   **減少錯誤：** 在設計階段發現並修正潛在的問題，減少開發後期和維護階段的錯誤。
*   **提高效率：** 有效的資料模型可以最佳化資料儲存、檢索和更新的效率。
*   **標準化：** 提供標準化的方式來描述資料，促進團隊協作和系統整合。

#### 資料模型的層次
資料模型通常分為三個抽象層次，這有助於在設計過程中逐步細化資料庫的結構：

1.  **概念模型 (Conceptual Data Model)**
    *   **定義：** 最高層次的抽象，描述資料的整體邏輯結構，獨立於任何特定的資料庫管理系統 (DBMS) 或實作細節。它專注於業務需求和實體之間的關係。
    *   **用途：** 主要用於與非技術使用者溝通，捕捉業務需求。
    *   **典型模型：** 實體關係模型 (Entity-Relationship Model, ER Model) 是最常用的概念模型。

2.  **邏輯模型 (Logical Data Model)**
    *   **定義：** 將概念模型轉換為特定資料模型類型（例如關聯式、物件導向、文件式等）的結構，但不涉及具體的 DBMS 產品或儲存細節。它定義了資料表、欄位、主鍵、外部鍵、約束等。
    *   **用途：** 供資料庫設計師使用，作為實體模型設計的基礎。
    *   **典型模型：** 關聯式模型 (Relational Model) 是最廣泛使用的邏輯模型。

3.  **實體模型 (Physical Data Model)**
    *   **定義：** 最詳細的抽象層次，描述資料庫在特定 DBMS 上如何物理實作。它包含了所有邏輯模型的資訊，並增加了儲存細節，例如資料型別、索引、分割區、儲存程序等。
    *   **用途：** 供資料庫管理員 (DBA) 和系統工程師使用，直接指導資料庫的建立和最佳化。
    *   **典型模型：** 特定 DBMS 的 DDL (Data Definition Language) 腳本。

-----

### 2. 典型例子與轉換/推導

我們將以一個大學選課系統為例，展示從概念模型到邏輯模型的轉換。

#### 概念模型：實體關係模型 (ER Model)
ER 模型使用實體 (Entities)、屬性 (Attributes) 和關係 (Relationships) 來描述真實世界。

*   **實體 (Entity)：** 現實世界中可區分的對象，例如「學生」、「課程」、「教師」。在 ER 圖中通常用**矩形**表示。
*   **屬性 (Attribute)：** 實體的特性，例如「學生」的學號、姓名；「課程」的課程代碼、課程名稱。在 ER 圖中通常用**橢圓形**表示，並連接到其所屬的實體。
*   **關係 (Relationship)：** 實體之間的關聯，例如「學生」選修「課程」。在 ER 圖中通常用**菱形**表示，並連接到相關的實體。
*   **基數 (Cardinality)：** 描述關係中一個實體實例與另一個實體實例的關聯數量，常用 (1:1, 1:N, M:N) 表示。

**例子：大學選課系統的 ER 模型**

情境描述：
*   學生 (Student) 有學號 (StudentID)、姓名 (Name)、出生日期 (DOB)。
*   課程 (Course) 有課程代碼 (CourseID)、課程名稱 (Title)、學分數 (Credits)。
*   教師 (Teacher) 有教師編號 (TeacherID)、姓名 (Name)、系所 (Department)。
*   學生可以選修多門課程，一門課程可以被多個學生選修。學生選修課程時會有成績 (Grade)。
*   一門課程由一位教師教授，一位教師可以教授多門課程。

**ER 圖表示：**

```mermaid
erDiagram
    Student ||--o{ Enrolls : "選修"
    Course ||--o{ Enrolls : "被選修"
    Teacher ||--o{ Teaches : "教授"
    Course ||--o{ Teaches : "被教授"

    Student {
        StudentID PK
        Name
        DOB
    }

    Course {
        CourseID PK
        Title
        Credits
    }

    Teacher {
        TeacherID PK
        Name
        Department
    }

    Enrolls {
        StudentID FK
        CourseID FK
        Grade
    }

    Teaches {
        TeacherID FK
        CourseID FK
    }
```
**說明：**
*   `Student`、`Course`、`Teacher` 是實體。
*   `StudentID`、`CourseID`、`TeacherID` 是主鍵 (PK)，用於唯一識別實體。
*   `Enrolls` 是 `Student` 與 `Course` 之間的 M:N 關係，包含 `Grade` 屬性。
*   `Teaches` 是 `Teacher` 與 `Course` 之間的 1:N 關係。

#### 邏輯模型：關聯式模型 (Relational Model)
關聯式模型將資料組織成二維表格 (或稱關係/Relation)。

*   **表格 (Table/Relation)：** 實體或關係的表現形式。
*   **列 (Row/Tuple)：** 表格中的一條記錄，代表一個實體實例。
*   **欄 (Column/Attribute)：** 表格中的一個欄位，代表實體的一個屬性。
*   **主鍵 (Primary Key, PK)：** 唯一識別表格中每一列的一組或一個欄位。
*   **外部鍵 (Foreign Key, FK)：** 連結兩個表格的欄位，它參照另一個表格的主鍵。

**從 ER 模型轉換到關聯式模型：**

轉換規則：
1.  **每個實體** 轉換成一個表格。實體的屬性成為表格的欄位，實體的主鍵成為表格的主鍵。
2.  **一對一 (1:1) 關係：**
    *   將其中一個實體的主鍵作為外部鍵加入到另一個實體的表格中。
    *   或者為關係建立一個單獨的表格，包含兩個實體的主鍵。
3.  **一對多 (1:N) 關係：**
    *   將「一」端實體的主鍵作為外部鍵加入到「多」端實體的表格中。
4.  **多對多 (M:N) 關係：**
    *   為 M:N 關係建立一個獨立的表格。這個表格通常包含參與關係的兩個實體的主鍵作為其自身的複合主鍵和外部鍵，以及關係自身的屬性（如果有的話）。

**將上述 ER 模型轉換為關聯式表格：**

1.  **Student 實體 $\rightarrow$ Student 表格**
    *   **Student (StudentID, Name, DOB)**
    *   主鍵：StudentID

2.  **Course 實體 $\rightarrow$ Course 表格**
    *   **Course (CourseID, Title, Credits)**
    *   主鍵：CourseID

3.  **Teacher 實體 $\rightarrow$ Teacher 表格**
    *   **Teacher (TeacherID, Name, Department)**
    *   主鍵：TeacherID

4.  **Enrolls (M:N 關係，有屬性 Grade) $\rightarrow$ Enrolls 表格**
    *   **Enrolls (StudentID, CourseID, Grade)**
    *   主鍵：(StudentID, CourseID) (複合主鍵)
    *   外部鍵：StudentID 參照 Student(StudentID)
    *   外部鍵：CourseID 參照 Course(CourseID)

5.  **Teaches (1:N 關係) $\rightarrow$ 處理到「多」端 Course 表格**
    *   因為一個 `Teacher` 可以教授多門 `Course`，但一門 `Course` 只能由一位 `Teacher` 教授。
    *   所以，將 `Teacher` 的主鍵 `TeacherID` 作為外部鍵加入到 `Course` 表格中。
    *   **Course (CourseID, Title, Credits, TeacherID)**
    *   主鍵：CourseID
    *   外部鍵：TeacherID 參照 Teacher(TeacherID)

**最終邏輯模型 (關聯式表格結構)：**

*   **Student (StudentID, Name, DOB)**
    *   PK: StudentID
*   **Course (CourseID, Title, Credits, TeacherID)**
    *   PK: CourseID
    *   FK: TeacherID REFERENCES Teacher(TeacherID)
*   **Teacher (TeacherID, Name, Department)**
    *   PK: TeacherID
*   **Enrolls (StudentID, CourseID, Grade)**
    *   PK: (StudentID, CourseID)
    *   FK: StudentID REFERENCES Student(StudentID)
    *   FK: CourseID REFERENCES Course(CourseID)

#### 實體模型 (Physical Data Model)
實體模型會進一步定義上述表格在特定 DBMS 中的具體實作細節。

例如，在 PostgreSQL 或 MySQL 中建立 `Student` 表格可能類似這樣：

```sql
CREATE TABLE Student (
    StudentID VARCHAR(10) PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    DOB DATE
);

CREATE TABLE Teacher (
    TeacherID VARCHAR(10) PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Department VARCHAR(50)
);

CREATE TABLE Course (
    CourseID VARCHAR(10) PRIMARY KEY,
    Title VARCHAR(255) NOT NULL,
    Credits INT NOT NULL,
    TeacherID VARCHAR(10),
    FOREIGN KEY (TeacherID) REFERENCES Teacher(TeacherID)
);

CREATE TABLE Enrolls (
    StudentID VARCHAR(10),
    CourseID VARCHAR(10),
    Grade DECIMAL(3,1), -- 例如 0.0 到 4.0
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Student(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Course(CourseID)
);
```
實體模型還可能包含索引 (INDEX)、儲存引擎 (ENGINE=InnoDB)、資料分割 (PARTITION BY) 等更底層的物理儲存和效能最佳化設定。

-----

### 3. 與相鄰概念的關聯

*   **資料抽象化 (Data Abstraction)：** 資料模型是實現資料抽象化的主要工具。概念模型提供高層次抽象，邏輯模型提供中層抽象，實體模型提供低層次的具體實作細節，這正是資料抽象化的三個層次。
*   **資料庫設計生命週期 (Database Design Life Cycle)：** 資料模型的建立是資料庫設計生命週期的核心步驟。它通常在需求分析之後進行，並在實作之前完成。概念模型是分析階段的輸出，邏輯模型和實體模型則是設計階段的輸出。
*   **資料庫管理系統 (DBMS)：** 每種 DBMS 都基於一種或多種邏輯資料模型。例如，傳統的關聯式資料庫（如 MySQL, PostgreSQL, Oracle）支援關聯式模型。NoSQL 資料庫則支援文件模型 (MongoDB)、鍵值模型 (Redis)、圖形模型 (Neo4j) 等。選擇適合的資料模型是選擇 DBMS 的重要考量。
*   **資料庫查詢語言 (Query Languages)：** 查詢語言的語法和語義直接反映了其所基於的資料模型。例如，結構化查詢語言 (SQL) 是專為關聯式模型設計的，其操作（SELECT, INSERT, UPDATE, DELETE）都是針對表格、列和欄的。

-----

### 4. 進階內容：其他資料模型類型

除了關聯式模型，還有多種其他資料模型，每種都有其適用場景：

*   **階層式模型 (Hierarchical Model)：** 資料以樹狀結構組織，有父子關係。早期 IBM IMS 系統使用。
*   **網路模型 (Network Model)：** 擴展了階層式模型，允許一個節點有多個父節點，形成一個圖形結構。
*   **物件導向模型 (Object-Oriented Model)：** 將現實世界實體抽象為物件，具有屬性（資料）和方法（行為），並支援繼承、多型等特性。
*   **NoSQL 資料模型 (NoSQL Data Models)：** 隨著大數據和分散式系統的興起，出現了多種非關聯式模型，以應對特定需求：
    *   **文件模型 (Document Model)：** 資料儲存為半結構化的文件（如 JSON 或 XML），例如 MongoDB。
    *   **鍵值模型 (Key-Value Model)：** 最簡單的模型，資料以鍵值對的形式儲存，例如 Redis。
    *   **圖形模型 (Graph Model)：** 用節點和邊來表示實體和它們之間的關係，適合處理複雜的關聯網路，例如 Neo4j。
    *   **欄式模型 (Column-Family Model)：** 資料按列族組織，適合寬表和稀疏資料，例如 Cassandra。

-----

### 5. 常見錯誤與澄清

1.  **概念模型與邏輯模型混淆：**
    *   **錯誤：** 在 ER 圖中直接繪製外鍵，或將特定資料型別寫入 ER 圖。
    *   **澄清：** 概念模型 (ER 圖) 應盡可能與實作細節脫鉤，專注於實體、屬性、關係和基數。外部鍵和具體資料型別屬於邏輯模型和實體模型的範疇。

2.  **ER 圖的粒度問題：**
    *   **錯誤：** ER 圖過於詳細（例如包含每個欄位的精確長度）或過於粗略（例如所有關係都標示為 M:N）。
    *   **澄清：** ER 圖的目標是捕捉核心業務實體和它們的關係，應保持適度的抽象層次。過於詳細會使其難以理解，過於粗略則失去指導意義。

3.  **多對多關係的轉換遺漏：**
    *   **錯誤：** 將 M:N 關係簡單地在一個表格中添加一個外部鍵。
    *   **澄清：** M:N 關係必須轉換為一個獨立的「關聯表格」，該表格通常由參與實體的主鍵組成複合主鍵。直接添加外部鍵無法正確表達多對多關係的語義。

4.  **未考慮關係的屬性：**
    *   **錯誤：** 忽略關係本身的屬性（例如學生選課的「成績」）。
    *   **澄清：** 如果關係具有屬性，則在將其轉換為邏輯模型時，這些屬性必須包含在關聯表格中。

-----

### 6. 小練習（附詳解）

#### 小練習 1：繪製概念模型 (ER 圖)

**情境描述：**
某公司需要一個簡單的員工管理系統。
*   公司有多個部門 (Department)。每個部門有唯一的部門編號 (DeptID)、部門名稱 (Name) 和地點 (Location)。
*   每個員工 (Employee) 有唯一的員工編號 (EmpID)、姓名 (Name)、電子郵件 (Email) 和職位 (Position)。
*   每位員工必須隸屬於一個部門，一個部門可以有多位員工。
*   每個專案 (Project) 有唯一的專案編號 (ProjID)、專案名稱 (Name) 和預算 (Budget)。
*   多位員工可以參與多個專案。員工參與專案時，會記錄其投入的小時數 (HoursWorked)。

**請繪製其 ER 圖。**

---

**詳解：小練習 1**

1.  **識別實體：**
    *   Department (部門)
    *   Employee (員工)
    *   Project (專案)

2.  **識別屬性與主鍵：**
    *   Department: `DeptID` (PK), `Name`, `Location`
    *   Employee: `EmpID` (PK), `Name`, `Email`, `Position`
    *   Project: `ProjID` (PK), `Name`, `Budget`

3.  **識別關係與基數：**
    *   **員工隸屬於部門：** `Employee` 與 `Department` 之間。
        *   一個員工隸屬於一個部門 (1)
        *   一個部門有多位員工 (N)
        *   關係為 **1:N**，從 `Department` 到 `Employee`。我們稱之為 `Works_In` (隸屬於)。
    *   **員工參與專案：** `Employee` 與 `Project` 之間。
        *   多位員工可以參與多個專案 (M)
        *   多個專案可以有多位員工參與 (N)
        *   關係為 **M:N**。我們稱之為 `Participates_In` (參與)。
        *   此關係有屬性：`HoursWorked`。

4.  **繪製 ER 圖：**

```mermaid
erDiagram
    Department ||--o{ Employee : "Works_In"
    Employee ||--o{ Participates_In : "參與"
    Project ||--o{ Participates_In : "被參與"

    Department {
        DeptID PK
        Name
        Location
    }

    Employee {
        EmpID PK
        Name
        Email
        Position
    }

    Project {
        ProjID PK
        Name
        Budget
    }

    Participates_In {
        EmpID FK
        ProjID FK
        HoursWorked
    }
```

---

#### 小練習 2：從 ER 圖轉換到邏輯模型 (關聯式表格)

**請將小練習 1 中繪製的 ER 圖轉換為關聯式表格結構，並標示主鍵 (PK) 和外部鍵 (FK)。**

---

**詳解：小練習 2**

根據 ER 圖轉換規則：

1.  **Department 實體 $\rightarrow$ Department 表格**
    *   **Department (DeptID, Name, Location)**
    *   PK: DeptID

2.  **Employee 實體 $\rightarrow$ Employee 表格**
    *   **Employee (EmpID, Name, Email, Position)**
    *   PK: EmpID

3.  **Project 實體 $\rightarrow$ Project 表格**
    *   **Project (ProjID, Name, Budget)**
    *   PK: ProjID

4.  **Works_In (1:N 關係) $\rightarrow$ 處理到「多」端 Employee 表格**
    *   將 `Department` 的主鍵 `DeptID` 作為外部鍵加入到 `Employee` 表格中。
    *   **Employee (EmpID, Name, Email, Position, DeptID)**
    *   PK: EmpID
    *   FK: DeptID REFERENCES Department(DeptID)

5.  **Participates_In (M:N 關係，有屬性 HoursWorked) $\rightarrow$ Participates_In 表格**
    *   **Participates_In (EmpID, ProjID, HoursWorked)**
    *   PK: (EmpID, ProjID) (複合主鍵)
    *   FK: EmpID REFERENCES Employee(EmpID)
    *   FK: ProjID REFERENCES Project(ProjID)

**最終邏輯模型 (關聯式表格結構)：**

*   **Department (DeptID, Name, Location)**
    *   PK: DeptID
*   **Employee (EmpID, Name, Email, Position, DeptID)**
    *   PK: EmpID
    *   FK: DeptID REFERENCES Department(DeptID)
*   **Project (ProjID, Name, Budget)**
    *   PK: ProjID
*   **Participates_In (EmpID, ProjID, HoursWorked)**
    *   PK: (EmpID, ProjID)
    *   FK: EmpID REFERENCES Employee(EmpID)
    *   FK: ProjID REFERENCES Project(ProjID)

-----

### 7. 延伸閱讀/參考

*   **資料庫系統概念 (Database System Concepts)** by Abraham Silberschatz, Henry F. Korth, S. Sudarshan
    *   經典教材，深入介紹資料模型、關聯式理論和資料庫設計。
*   **資料庫系統導論 (An Introduction to Database Systems)** by C.J. Date
    *   另一本經典書籍，對於關聯式模型的原理有詳細且嚴謹的闡述。
*   **資料庫設計實務 (Database Design for Mere Mortals)** by Michael J. Hernandez
    *   更側重實用性和設計方法，適合初學者理解資料庫設計流程。
*   **W3Schools SQL Tutorial:** [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)
    *   提供關聯式資料庫和 SQL 的基礎知識和實作範例。