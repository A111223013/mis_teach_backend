# 堆疊 (Stack)：後進先出的資料結構

堆疊（Stack）是電腦科學中最基本且應用廣泛的抽象資料型態（Abstract Data Type, ADT）之一。它的主要特性是「後進先出」（Last-In, First-Out, LIFO），就像一疊盤子或一疊書，最後放上去的項目會是第一個被取走的。理解堆疊的原理及其操作，對於學習資料結構與演算法至關重要。

-----

#### 1. 核心概念與定義

### 1.1 什麼是堆疊？

堆疊是一種**線性**的資料結構，其所有操作都限制在其中一端進行，我們稱之為「頂部」（Top）。它的核心原則是「**後進先出 (LIFO)**」，意指最後一個被加入堆疊的元素，將會是第一個被移除的元素。

想像一下你疊了一堆盤子：
*   當你放上新盤子時，它總是放在最上面。
*   當你需要取用盤子時，你總是從最上面的盤子開始拿。
*   你不可能從中間或底部取出盤子，否則整疊盤子可能會垮掉。

這種操作模式正是堆疊的精髓。

### 1.2 堆疊的抽象資料型態 (ADT)

作為一個抽象資料型態，堆疊定義了一組操作介面，而不關心其底層的實作細節。以下是堆疊最常用的基本操作：

*   **`Push(element)`**: 將一個元素加入堆疊的頂部。如果堆疊已滿（在固定大小的實作中），則可能發生「堆疊溢位 (Stack Overflow)」。
*   **`Pop()`**: 從堆疊的頂部移除並回傳一個元素。如果堆疊為空，則可能發生「堆疊不足 (Stack Underflow)」。
*   **`Peek()` / `Top()`**: 回傳堆疊頂部的元素，但**不**將其移除。如果堆疊為空，則可能拋出錯誤。
*   **`IsEmpty()`**: 檢查堆疊是否為空。回傳 `True` 或 `False`。
*   **`Size()`**: 回傳堆疊中元素的數量。

-----

#### 2. 典型例子與實作方法

### 2.1 現實世界中的例子

堆疊的概念在我們的日常生活中隨處可見，也在電腦系統中扮演著關鍵角色：

1.  **一疊盤子/書本**: 如同前述，這是理解 LIFO 最直觀的例子。
2.  **瀏覽器的「返回」按鈕**: 當你訪問一系列網頁時，每次點擊「返回」都會回到上一個頁面。最後訪問的頁面會最先從歷史記錄中「彈出」。
3.  **文字編輯器的「復原 (Undo)」功能**: 你所做的最後一個操作，會是第一個被復原的操作。
4.  **函式呼叫堆疊 (Call Stack)**: 程式在執行時，每當呼叫一個函式，該函式相關的資訊（如區域變數、返回位址）會被壓入呼叫堆疊。當函式執行完畢，其資訊會從堆疊中彈出，程式返回到呼叫它的地方。

### 2.2 堆疊的實作方法

堆疊可以透過多種底層資料結構來實作，最常見的兩種是**陣列**和**鏈結串列**。

#### 2.2.1 陣列實作 (Array-based Stack)

使用陣列來實作堆疊時，我們通常會維護一個指向堆疊頂部（或下一個空位）的索引變數。

*   **優點**: 存取速度快 (O(1))，因為陣列支援隨機存取。
*   **缺點**: 如果使用固定大小的陣列，則堆疊的大小是有限的，可能會導致堆疊溢位。若要支援動態大小，則可能涉及陣列擴容，這會帶來額外的時間成本。

**概念示意圖:**

```
[  ] <- Top (索引指向下一個要 Push 的位置)
[ E ]
[ D ]
[ C ]
[ B ]
[ A ] <- Bottom
```

*   `Push(F)`: 將 `F` 放入 `Top` 指向的位置，`Top` 遞增。
*   `Pop()`: 回傳 `Top-1` 位置的元素，`Top` 遞減。

**時間複雜度：**
*   `Push()`: $O(1)$ (平均情況，若涉及擴容則為 $O(N)$)
*   `Pop()`: $O(1)$
*   `Peek()`: $O(1)$
*   `IsEmpty()`: $O(1)$
*   `Size()`: $O(1)$

#### 2.2.2 鏈結串列實作 (Linked List-based Stack)

使用鏈結串列來實作堆疊時，通常將鏈結串列的頭部作為堆疊的頂部。

*   **優點**: 堆疊的大小只受限於系統記憶體，彈性大，不會有堆疊溢位的問題（除非記憶體耗盡）。
*   **缺點**: 每個元素都需要額外的記憶體來儲存指標。

**概念示意圖:**

```
Top -> [ E ] -> [ D ] -> [ C ] -> [ B ] -> [ A ] -> NULL
```

*   `Push(F)`: 建立一個新節點 `F`，將其 `next` 指向目前的 `Top`，然後更新 `Top` 為 `F`。
*   `Pop()`: 儲存 `Top` 指向的節點資料，將 `Top` 更新為 `Top->next`，並釋放原先的 `Top` 節點。

**時間複雜度：**
*   `Push()`: $O(1)$
*   `Pop()`: $O(1)$
*   `Peek()`: $O(1)$
*   `IsEmpty()`: $O(1)$
*   `Size()`: $O(N)$ (若要記錄大小，則為 $O(1)$)

-----

#### 3. 與相鄰概念的關聯

### 3.1 佇列 (Queue)

佇列是與堆疊最常被一起比較和學習的資料結構。它們都屬於線性資料結構，但操作原則完全不同：

*   **堆疊 (Stack)**: **後進先出 (LIFO)**
*   **佇列 (Queue)**: **先進先出 (FIFO, First-In, First-Out)**

想像一下銀行排隊：第一個排隊的人會是第一個被服務的人。佇列的插入操作發生在「尾部 (Rear/Tail)」，移除操作發生在「頭部 (Front)」。

### 3.2 陣列與鏈結串列

堆疊本身是一個抽象概念，它的底層實作仰賴於更基礎的資料結構，例如陣列和鏈結串列。理解這些基礎資料結構的特性（如記憶體分配、隨機存取與循序存取、插入/刪除效率），有助於我們選擇最適合特定應用場景的堆疊實作方式。

### 3.3 遞迴 (Recursion)

遞迴是一種函式呼叫自身的程式設計技巧。每次遞迴呼叫時，系統都會在「呼叫堆疊 (Call Stack)」上為新的函式呼叫建立一個新的「堆疊框 (Stack Frame)」，其中包含函式的參數、區域變數和返回位址。當遞迴達到基本情況並開始返回時，堆疊框會依序彈出，體現了 LIFO 的特性。

### 3.4 樹與圖的遍歷 (Tree and Graph Traversal)

在樹和圖的資料結構中，**深度優先搜尋 (DFS, Depth-First Search)** 演算法可以透過堆疊來迭代實作。DFS 的核心思想是盡可能深地探索節點，當達到盡頭時才回溯。堆疊的 LIFO 特性恰好能儲存待探索的路徑，幫助演算法進行回溯。

-----

#### 4. 進階應用

堆疊在演算法和系統設計中有著廣泛的應用，以下列舉幾個常見的進階應用：

### 4.1 運算式求值與轉換

*   **中綴表示式到後綴表示式 (Infix to Postfix Conversion)**: 堆疊可以用來將人習慣使用的中綴表示式（例如 `A + B * C`）轉換為後綴表示式（例如 `A B C * +`），後者更易於電腦求值。
*   **後綴表示式求值 (Postfix Evaluation)**: 對於後綴表示式，可以使用堆疊來高效地計算其結果。遇到數字壓入堆疊，遇到運算符則從堆疊彈出兩個操作數進行運算，然後將結果壓回堆疊。

### 4.2 括號匹配檢查

檢查一個字串中的括號（例如 `()`、`[]`、`{}`）是否正確匹配和嵌套，是堆疊的經典應用。當遇到左括號時壓入堆疊，遇到右括號時檢查堆疊頂部是否為對應的左括號，若是則彈出，否則表示不匹配。最後，如果堆疊為空，則表示所有括號都匹配。

### 4.3 解決迷宮問題 (Maze Solving) 與回溯法 (Backtracking)

在迷宮問題或其他需要嘗試不同路徑並在死路時回溯的場景中，堆疊可以用來儲存當前的路徑或待探索的狀態。當遇到死路時，可以從堆疊中彈出上一個狀態，嘗試其他路徑。這正是回溯演算法的核心思想。

-----

#### 5. 常見錯誤與澄清

### 5.1 堆疊不足 (Stack Underflow)

*   **錯誤**: 嘗試從一個空的堆疊中執行 `Pop()` 或 `Peek()` 操作。
*   **澄清**: 在執行 `Pop()` 或 `Peek()` 之前，總是應該先呼叫 `IsEmpty()` 方法來檢查堆疊是否為空。若堆疊為空，則應該拋出錯誤或返回特定值（例如 `null`），而不是嘗試存取不存在的元素。

### 5.2 堆疊溢位 (Stack Overflow)

*   **錯誤**: 嘗試將元素 `Push()` 到一個已經滿了的固定大小堆疊中。
*   **澄清**: 這通常發生在基於陣列的固定大小堆疊實作中。在 `Push()` 之前，應檢查堆疊是否已達到其最大容量。如果使用鏈結串列實作，除非系統記憶體耗盡，否則一般不會發生此類溢位。程式中的函式呼叫堆疊溢位則通常是由無限遞迴引起。

### 5.3 將堆疊與佇列混淆

*   **錯誤**: 錯誤地認為堆疊是先進先出的。
*   **澄清**: 再次強調，**堆疊是 LIFO (後進先出)**，**佇列是 FIFO (先進先出)**。這是兩者最根本的區別，也是面試和實際應用中最常被考察的點。

### 5.4 錯誤的頂部指標更新

*   **錯誤**: 在 `Push()` 或 `Pop()` 操作後，沒有正確更新指向堆疊頂部的指標或索引。
*   **澄清**: 這是實作堆疊時最常見的邏輯錯誤。確保 `Push` 後頂部指標前進，`Pop` 後頂部指標後退。對於陣列實作，要小心處理索引的邊界條件（0 或 `size-1`）。對於鏈結串列實作，要確保 `head` 或 `top` 指標的正確指向。

-----

#### 6. 小練習 (附詳解)

### 小練習一：基礎堆疊操作

假設我們有一個空的整數堆疊 `S`。請寫出以下操作序列執行後，堆疊 `S` 的最終狀態以及每個 `Pop` 或 `Peek` 操作的結果。

**操作序列：**
1.  `Push(10)`
2.  `Push(20)`
3.  `Peek()`
4.  `Push(30)`
5.  `Pop()`
6.  `Push(40)`
7.  `IsEmpty()`
8.  `Pop()`
9.  `Pop()`
10. `Peek()`
11. `Pop()`
12. `IsEmpty()`

#### 詳解一

讓我們逐步追蹤堆疊的狀態：

1.  `Push(10)`:
    *   堆疊 `S`: `[10]` (10 在底部，10 也是頂部)
2.  `Push(20)`:
    *   堆疊 `S`: `[10, 20]` (10 底部, 20 頂部)
3.  `Peek()`:
    *   **結果**: `20`
    *   堆疊 `S`: `[10, 20]` (無變化)
4.  `Push(30)`:
    *   堆疊 `S`: `[10, 20, 30]` (10 底部, 30 頂部)
5.  `Pop()`:
    *   **結果**: `30` (30 被移除)
    *   堆疊 `S`: `[10, 20]` (10 底部, 20 頂部)
6.  `Push(40)`:
    *   堆疊 `S`: `[10, 20, 40]` (10 底部, 40 頂部)
7.  `IsEmpty()`:
    *   **結果**: `False` (堆疊不為空)
    *   堆疊 `S`: `[10, 20, 40]` (無變化)
8.  `Pop()`:
    *   **結果**: `40` (40 被移除)
    *   堆疊 `S`: `[10, 20]` (10 底部, 20 頂部)
9.  `Pop()`:
    *   **結果**: `20` (20 被移除)
    *   堆疊 `S`: `[10]` (10 底部, 10 頂部)
10. `Peek()`:
    *   **結果**: `10`
    *   堆疊 `S`: `[10]` (無變化)
11. `Pop()`:
    *   **結果**: `10` (10 被移除)
    *   堆疊 `S`: `[]` (堆疊為空)
12. `IsEmpty()`:
    *   **結果**: `True` (堆疊為空)
    *   堆疊 `S`: `[]` (無變化)

**最終堆疊 S 的狀態**: 為空 `[]`。

---

### 小練習二：括號匹配檢查

請使用堆疊，判斷給定字串中的括號是否平衡（即每個左括號都有對應的右括號，且順序正確）。只考慮 `()`、`[]`、`{}` 三種括號。

**範例輸入：**
1.  `"([]) {}"`
2.  `"([)]"`
3.  `"((()))"`
4.  `"{[()]}"`
5.  `"{["`
6.  `"(()"`

#### 詳解二

**解決思路：**

1.  初始化一個空的堆疊。
2.  遍歷輸入字串中的每個字元。
    *   如果字元是**左括號**（`(`、`[`、`{`），則將其壓入堆疊。
    *   如果字元是**右括號**（`)`、`]`、`}`）：
        *   檢查堆疊是否為空。如果為空，表示沒有對應的左括號，字串不平衡。
        *   從堆疊中彈出頂部元素。
        *   檢查彈出的左括號是否與當前的右括號匹配（例如，彈出的是 `(`，當前字元是 `)`）。如果不匹配，字串不平衡。
3.  遍歷完所有字元後，檢查堆疊是否為空。
    *   如果堆疊為空，表示所有括號都已成功匹配，字串平衡。
    *   如果堆疊不為空，表示還有未匹配的左括號，字串不平衡。

**程式碼示範（概念性）：**

```python
def is_balanced(s):
    stack = []
    # 定義左右括號的匹配關係
    mapping = {")": "(", "]": "[", "}": "{"} 

    for char in s:
        if char in mapping.values(): # 如果是左括號
            stack.append(char)
        elif char in mapping.keys(): # 如果是右括號
            if not stack: # 堆疊為空，沒有對應的左括號
                return False
            top_element = stack.pop()
            if mapping[char] != top_element: # 不匹配
                return False
    
    return not stack # 遍歷完畢，堆疊為空則平衡

# 測試
print(f"\"([] {{}}\" is balanced: {is_balanced(\"([] {})\")}")   # True
print(f"\"([)]\" is balanced: {is_balanced(\"([)]\")}")       # False
print(f"\"((()))\" is balanced: {is_balanced(\"((()))\")}")   # True
print(f"\"{{[()]}}\" is balanced: {is_balanced(\"{{[()]}}\")}") # True
print(f"\"{{\" is balanced: {is_balanced(\"{[\")}")         # False (堆疊不為空)
print(f"\"(()\" is balanced: {is_balanced(\"(()\")}")         # False (堆疊不為空)
print(f"\"\" is balanced: {is_balanced(\"\")}")             # True (空字串也算平衡)
```

**範例輸入的結果分析：**

1.  `"([] {})"`:
    *   `(` -> `stack: [`
    *   `[` -> `stack: [[`
    *   `]` -> 彈出 `[`, 匹配。`stack: [`
    *   `)` -> 彈出 `(`, 匹配。`stack: []`
    *   `{` -> `stack: [{`
    *   `}` -> 彈出 `{`, 匹配。`stack: []`
    *   遍歷結束，堆疊為空。**結果：True**

2.  `"([)]"`:
    *   `(` -> `stack: [`
    *   `[` -> `stack: [[`
    *   `)` -> 彈出 `[`, 不匹配 `(`. **結果：False**

3.  `"((()))"`: **結果：True** (所有都匹配)

4.  `"{[()]}"`: **結果：True** (所有都匹配)

5.  `"{["`:
    *   `{` -> `stack: [{`
    *   `[` -> `stack: [{, [`
    *   遍歷結束，堆疊非空。**結果：False**

6.  `"(()"`:
    *   `(` -> `stack: [`
    *   `(` -> `stack: [(, (`
    *   `)` -> 彈出 `(`, 匹配。`stack: [`
    *   遍歷結束，堆疊非空。**結果：False**

-----

#### 7. 延伸閱讀

*   **資料結構與演算法經典教材**: 任何一本關於資料結構的教科書都會有關於堆疊的詳細章節。例如：
    *   *Introduction to Algorithms* by Cormen, Leiserson, Rivest, and Stein (CLRS)
    *   *Data Structures and Algorithms in Java/C++/Python* by Robert Lafore / Goodrich, Tamassia, Goldwasser
*   **線上教學資源**:
    *   GeeksforGeeks: [Stack Data Structure](https://www.geeksforgeeks.org/stack-data-structure/)
    *   維基百科: [堆疊 (抽象資料類型)](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B))
*   **函式呼叫堆疊 (Call Stack) 深入理解**: 探索作業系統如何管理程式執行流程的機制，對於理解堆疊的實際應用非常有幫助。