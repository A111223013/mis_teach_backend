# Chapter 5 儲存管理

儲存管理是作業系統的核心功能之一，其主要目標是有效地利用主記憶體和輔助儲存裝置，並為運行中的程序提供所需的儲存空間。一個良好的儲存管理策略不僅能提升系統效能，還能確保多個程序能安全、獨立地執行。

-----

### 5.1 儲存管理概論

#### 核心概念/定義
儲存管理是作業系統負責分配、追蹤、管理主記憶體（RAM）和輔助儲存裝置（如硬碟、SSD）的過程。其主要目標包括：
*   **多工支援：** 允許多個程序共享有限的主記憶體資源，並在它們之間切換執行。
*   **記憶體保護：** 確保一個程序的記憶體空間不會被其他程序非法存取，從而防止錯誤和安全漏洞。
*   **記憶體抽象化：** 為程序提供一個比實際記憶體更大的、連續的邏輯位址空間，隱藏底層實體記憶體的複雜性。
*   **效率最佳化：** 透過各種策略提高記憶體使用率，減少存取時間。
*   **記憶體共享：** 允許不同程序共享部分記憶體，以實現程序間的通訊或共用函式庫。

#### 與相鄰概念的關聯
*   **與 CPU 排程的關聯：** 儲存管理確保多個程序能在記憶體中共存，為 CPU 排程器提供可執行的程序列表。當程序切換時，記憶體管理單元（MMU）可能需要更新上下文。
*   **與檔案系統的關聯：** 輔助儲存裝置的管理直接影響檔案系統的效能和可靠性。檔案系統是儲存裝置的邏輯視圖，而儲存管理負責底層實體空間的分配和管理。
*   **與程序管理的關聯：** 每個程序都需要記憶體空間來存放程式碼、資料和堆疊。記憶體管理是程序生命週期中不可或缺的一部分。

-----

### 5.2 記憶體階層 (Memory Hierarchy)

#### 核心概念/定義
記憶體階層是指將不同速度、成本和容量的儲存裝置組織成一個層次結構。目標是透過結合不同層次的優勢，提供高存取效能和足夠的儲存容量。典型的階層包括：
1.  **暫存器 (Registers)：** 位於 CPU 內部，速度最快，容量最小，成本最高。
2.  **快取記憶體 (Cache Memory)：** 位於 CPU 和主記憶體之間，速度非常快，容量較小，成本高。通常有多級（L1, L2, L3）。
3.  **主記憶體 (Main Memory/RAM)：** 電腦主要的工作記憶體，速度較快，容量適中，成本適中。資料在 CPU 執行前會載入此處。
4.  **輔助儲存裝置 (Secondary Storage)：** 如硬碟 (HDD)、固態硬碟 (SSD)，速度較慢，容量最大，成本最低。用於永久儲存程式和資料。

#### 典型例子與推導
| 記憶體層次    | 存取時間（約） | 容量（約）     | 成本/位元 |
| :------------ | :------------- | :------------- | :-------- |
| 暫存器        | 幾奈秒         | 幾百位元組     | 最高      |
| 快取記憶體    | 幾奈秒到幾十奈秒 | 幾 KB 到幾 MB  | 次高      |
| 主記憶體（RAM） | 幾十奈秒到幾百奈秒 | 幾 GB 到幾百 GB | 適中      |
| SSD           | 幾十微秒到幾百微秒 | 幾百 GB 到幾 TB | 較低      |
| HDD           | 幾毫秒到幾十毫秒 | 幾 TB 到幾十 TB | 最低      |

從上到下，速度逐漸變慢，容量逐漸變大，單位成本逐漸降低。作業系統的記憶體管理主要關注主記憶體和輔助儲存裝置之間的互動。

#### 與相鄰概念的關聯
*   **快取管理：** 作業系統通常不直接管理 CPU 快取，而是由硬體自動管理。然而，OS 會透過演算法（如分頁）來優化快取命中率。
*   **虛擬記憶體：** 透過將輔助儲存裝置作為主記憶體的延伸，實現了虛擬記憶體，允許程序使用比實際 RAM 更大的位址空間。

-----

### 5.3 邏輯位址與實體位址 (Logical vs. Physical Address)

#### 核心概念/定義
在多工環境中，為了實現記憶體保護和靈活的記憶體分配，作業系統引入了邏輯位址與實體位址的概念。
*   **邏輯位址 (Logical Address)：** 由 CPU 產生，是程序所看到的位址。每個程序都認為自己獨佔整個位址空間，這個空間是從 0 開始的。
*   **實體位址 (Physical Address)：** 實際記憶體單元在記憶體匯流排上的位址。這是記憶體控制器會看到的位址。

**位址綁定 (Address Binding)：** 將邏輯位址轉換為實體位址的過程。它可以在以下三個階段進行：
1.  **編譯時 (Compile Time)：** 如果程序在編譯時就知道它將被載入到記憶體的哪個固定位置，編譯器可以直接產生實體位址。這種方式不靈活，很少使用。
2.  **載入時 (Load Time)：** 如果程序在編譯時不知道它會被載入到哪裡，但在載入時確定了其在記憶體中的位置，則載入器 (loader) 會在載入時完成位址綁定。
3.  **執行時 (Execution Time)：** 程序在執行過程中才進行位址綁定。這是最靈活的方式，允許程序在記憶體中移動，也是現代作業系統普遍採用的方式，需要硬體支援（如記憶體管理單元 MMU）。

#### 典型例子與推導
最簡單的執行時位址綁定機制是使用兩個暫存器：
*   **基底暫存器 (Base Register)：** 儲存一個程序在記憶體中的起始實體位址。
*   **限制暫存器 (Limit Register)：** 儲存該程序的邏輯位址空間大小。

當 CPU 產生一個邏輯位址 $L$ 時，硬體會執行以下檢查和轉換：
1.  **範圍檢查：** 檢查 $0 \le L < \text{Limit Register}$。如果 $L$ 超出範圍，表示程序試圖存取其允許範圍外的記憶體，將觸發錯誤（如段錯誤）。
2.  **位址轉換：** 如果通過範圍檢查，則實體位址 $P = L + \text{Base Register}$。

**範例：**
假設某程序的基底暫存器值為 10000，限制暫存器值為 5000。
*   CPU 發出邏輯位址 1000：
    *   $0 \le 1000 < 5000$ (通過檢查)
    *   實體位址 $P = 1000 + 10000 = 11000$
*   CPU 發出邏輯位址 6000：
    *   $0 \le 6000 < 5000$ (不通過檢查) -> 觸發記憶體保護錯誤

#### 與相鄰概念的關聯
邏輯位址與實體位址的分離是實現虛擬記憶體、分頁和分段等記憶體管理技術的基石。它使得每個程序都能擁有獨立的、從 0 開始的位址空間，簡化了程式設計，同時由作業系統負責將這些邏輯位址映射到實際的實體記憶體上，實現記憶體保護和多工。

-----

### 5.4 連續式記憶體配置 (Contiguous Memory Allocation)

#### 核心概念/定義
連續式記憶體配置是指為每個程序分配一個單一的、連續的記憶體區塊。這是早期作業系統和某些嵌入式系統中常見的記憶體管理方式。主要有兩種策略：

1.  **固定分區 (Fixed Partitioning)：**
    *   作業系統將主記憶體劃分為多個固定大小的分區。
    *   每個分區只能載入一個程序。
    *   分區大小可以在系統啟動時設定。
    *   **優點：** 實現簡單。
    *   **缺點：**
        *   **內部碎片 (Internal Fragmentation)：** 如果程序小於分區大小，未使用的記憶體空間會被浪費。
        *   程序大小受分區限制。
        *   能同時執行的程序數量受分區數量限制。

2.  **可變分區 (Variable Partitioning)：**
    *   作業系統根據程序的實際大小動態分配記憶體區塊。
    *   當程序載入時，系統會尋找一個足夠大的連續可用空間。
    *   當程序結束時，其佔用的空間會被釋放，並可能與相鄰的可用空間合併。
    *   **優點：** 沒有內部碎片（幾乎），記憶體利用率更高。
    *   **缺點：**
        *   **外部碎片 (External Fragmentation)：** 雖然每個分配給程序的區塊大小是合適的，但隨著程序載入和退出，記憶體中會散佈許多小的、不連續的可用空間，這些空間加起來可能很大，但由於不連續，無法滿足大程序的記憶體需求。

#### 典型例子與推導
對於可變分區配置，有幾種常用的記憶體分配策略來尋找合適的可用空間 (hole)：

*   **首次適配 (First-fit)：**
    *   從可用空間列表的開頭開始尋找，找到第一個足夠大的空閒區塊就分配。
    *   **優點：** 速度快。
    *   **缺點：** 可能在記憶體開頭留下很多小的空閒區塊，導致後續查找效率降低。

*   **最佳適配 (Best-fit)：**
    *   遍歷整個可用空間列表，找到大小最接近程序需求的空閒區塊。
    *   **優點：** 最小化內部碎片（剩餘空間最小）。
    *   **缺點：** 搜尋時間較長（需要遍歷），並可能產生很多非常小的空閒區塊，加劇外部碎片。

*   **最差適配 (Worst-fit)：**
    *   遍歷整個可用空間列表，找到最大的空閒區塊進行分配。
    *   **優點：** 剩餘的空閒區塊仍然足夠大，可能可以容納其他較小的程序。
    *   **缺點：** 搜尋時間較長，且可能將最大的可用區塊分割成兩塊中等大小的區塊，導致大程序之後難以找到足夠大的連續空間。

**範例：記憶體分配策略**
假設有以下空閒記憶體區塊（hole）：10KB, 20KB, 4KB, 18KB。
現在請求一個 12KB 的程序。

*   **First-fit：** 會選擇 20KB 的區塊，分配 12KB，剩餘 8KB。
*   **Best-fit：** 會選擇 18KB 的區塊，分配 12KB，剩餘 6KB。
*   **Worst-fit：** 會選擇 20KB 的區塊，分配 12KB，剩餘 8KB。

如果現在請求一個 3KB 的程序：
*   **First-fit：** 會選擇第一個空閒區塊 10KB，剩餘 7KB。
*   **Best-fit：** 會選擇 4KB 的區塊，剩餘 1KB。
*   **Worst-fit：** 會選擇 20KB 的區塊（假設它還存在且是最大的），剩餘 17KB。

#### 與相鄰概念的關聯
連續式記憶體配置的缺點，尤其是外部碎片問題，催生了非連續式記憶體配置的概念，如分頁和分段，這些技術旨在更有效地管理記憶體，減少碎片的影響。

#### 常見錯誤與澄清
*   **內部碎片 vs. 外部碎片：**
    *   **內部碎片：** 發生在已分配給程序的記憶體區塊內部，但未被程序實際使用的部分。例如，固定分區中，程序小於分區大小。
    *   **外部碎片：** 發生在未分配的記憶體空間中，表現為許多小的、不連續的空閒區塊散佈在整個記憶體中，雖然總和足夠大，但無法滿足需要連續大空間的程序。

解決外部碎片的方法包括**壓縮 (Compaction)**，即移動所有已分配的記憶體區塊，使其連在一起，並將所有空閒區塊合併成一個大的連續區塊。然而，壓縮需要耗費大量的 CPU 時間和系統資源，且在執行時難以實現。

-----

### 5.5 分頁 (Paging)

#### 核心概念/定義
分頁是一種非連續式記憶體配置方案，它將程序的邏輯位址空間和實體記憶體空間都劃分為固定大小的區塊。
*   **頁 (Page)：** 邏輯位址空間的固定大小區塊。由 CPU 產生邏輯位址時會將其拆分為頁號 (Page Number) 和頁偏移量 (Page Offset)。
*   **頁框 (Frame)：** 實體記憶體空間的固定大小區塊。其大小與頁的大小相同。
*   **頁表 (Page Table)：** 每個程序都有一個頁表，用於將邏輯頁號映射到實體頁框號。頁表通常儲存在主記憶體中。

分頁的主要優點是解決了外部碎片問題，因為任何一個空閒的頁框都可以用來載入任何一個頁。

#### 典型例子與推導
**邏輯位址到實體位址的轉換：**
當 CPU 產生一個邏輯位址 (Logical Address) $L$ 時，記憶體管理單元 (MMU) 將其分解為兩個部分：
1.  **頁號 (Page Number, $p$)：** 用於索引頁表。
2.  **頁偏移量 (Page Offset, $d$)：** 指定頁內部的位址。

假設頁大小為 $2^n$ 位元組，則邏輯位址的低 $n$ 位是頁偏移量 $d$，剩餘的高位是頁號 $p$。

$L = (p, d)$

頁表的每個條目包含對應頁號的實體頁框號 (Frame Number, $f$)。
頁表查詢後，得到頁框號 $f$。
實體位址 (Physical Address) $A$ 的計算如下：
$A = (f \times \text{Page Size}) + d$

或者，更直觀地，實體位址是由頁框號和頁偏移量拼接而成的：
$A = (f, d)$

**範例：位址轉換**
假設：
*   邏輯位址空間大小為 16KB。
*   實體記憶體大小為 32KB。
*   頁大小為 4KB。

1.  **頁大小分析：** $4 \text{KB} = 4 \times 1024 \text{ Bytes} = 2^{12} \text{ Bytes}$。
    因此，頁偏移量 $d$ 需要 12 位元。
2.  **邏輯位址空間分析：** 16KB 邏輯位址空間有 $16 \text{KB} / 4 \text{KB} = 4$ 個頁。
    頁號 $p$ 需要 2 位元（從 $00_2$ 到 $11_2$）。
    邏輯位址共需要 $2 + 12 = 14$ 位元。
3.  **實體記憶體空間分析：** 32KB 實體記憶體有 $32 \text{KB} / 4 \text{KB} = 8$ 個頁框。
    頁框號 $f$ 需要 3 位元（從 $000_2$ 到 $111_2$）。
    實體位址共需要 $3 + 12 = 15$ 位元。

**頁表示例 (程序 A 的頁表)：**

| 頁號 (p) | 頁框號 (f) |
| :------- | :--------- |
| 0        | 5          |
| 1        | 3          |
| 2        | 1          |
| 3        | 7          |

現在，CPU 產生邏輯位址 `0x1A40` (十進位 6720)。

1.  **分解邏輯位址：**
    *   `0x1A40` (十進位 6720)。頁大小 4KB。
    *   頁號 $p = \lfloor 6720 / 4096 \rfloor = 1$
    *   頁偏移量 $d = 6720 \pmod{4096} = 2624$
    *   或者用二進位：`0x1A40 = 0001 1010 0100 0000` (14位元)
        *   頁號 (高 2 位)：`00` (如果頁號是從0開始編號) 或是 `01` 如果是高2位作為頁號，那麼 `01` 是 1。
        *   頁偏移量 (低 12 位)：`1010 0100 0000` ($0xA40 = 2624$ 十進位)。
        所以，$p=1, d=2624$。
2.  **頁表查詢：** 從頁表中查詢頁號 1 對應的頁框號 $f = 3$。
3.  **計算實體位址：**
    實體位址 $A = (3 \times 4096) + 2624 = 12288 + 2624 = 14912$
    或 $A = \text{0x3A40}$ (將頁框號 3 和偏移量 0xA40 拼接)。

**轉譯後備緩衝區 (Translation Lookaside Buffer, TLB)：**
由於每次記憶體存取都需要兩次記憶體存取（一次是頁表，一次是實際資料），這會降低效能。TLB 是一個小型、高速的硬體快取，用於儲存最近使用的頁表條目。
*   當 CPU 產生邏輯位址時，MMU 會首先檢查 TLB。
*   如果頁號在 TLB 中找到（TLB 命中），則直接從 TLB 獲取頁框號，快速生成實體位址。
*   如果未找到（TLB 未命中），則需要存取主記憶體中的頁表，找到頁框號後，將該條目加入 TLB 以備將來使用，然後再進行資料存取。

#### 與相鄰概念的關聯
*   **虛擬記憶體的基礎：** 分頁是實現虛擬記憶體的關鍵技術，它允許程序使用比實體記憶體更大的邏輯位址空間。
*   **內部碎片：** 分頁雖然解決了外部碎片，但由於程序通常不會正好是頁大小的整數倍，因此最後一個頁可能會產生內部碎片。

-----

### 5.6 分段 (Segmentation)

#### 核心概念/定義
分段是另一種非連續式記憶體配置方案，它將程序的邏輯位址空間劃分為多個邏輯單位，稱為**段 (Segments)**。每個段代表程序的一個獨立邏輯單元，例如：程式碼段、資料段、堆疊段、函式庫等。每個段可以有不同的大小。

*   **段 (Segment)：** 邏輯位址空間中大小可變的邏輯單元。
*   **段表 (Segment Table)：** 每個程序有一個段表，每個條目包含該段的基底位址 (Base Address) 和長度/限制 (Limit)。

分段更符合使用者對程式結構的理解，因為它將程式組織成有意義的邏輯實體。

#### 典型例子與推導
**邏輯位址到實體位址的轉換：**
CPU 產生一個邏輯位址 $(s, d)$：
1.  **段號 (Segment Number, $s$)：** 用於索引段表。
2.  **偏移量 (Offset, $d$)：** 指定段內部的位址。

MMU 透過段號 $s$ 查閱段表，找到對應段的基底位址 `base` 和限制 `limit`。
1.  **範圍檢查：** 檢查 $0 \le d < \text{limit}$。如果偏移量超出段的限制，則觸發錯誤。
2.  **位址轉換：** 如果通過範圍檢查，則實體位址 $A = \text{base} + d$。

**範例：位址轉換**
假設某程序有以下段表：

| 段號 (s) | 基底位址 (Base) | 限制 (Limit) |
| :------- | :-------------- | :----------- |
| 0        | 1000            | 500          |
| 1        | 6000            | 2000         |
| 2        | 3000            | 800          |

現在，CPU 產生邏輯位址 $(1, 700)$。
1.  **段表查詢：** 段號 $s=1$。對應基底位址 `base = 6000`，限制 `limit = 2000`。
2.  **範圍檢查：** 偏移量 $d=700$。檢查 $0 \le 700 < 2000$ (通過檢查)。
3.  **計算實體位址：** 實體位址 $A = 6000 + 700 = 6700$。

如果 CPU 產生邏輯位址 $(2, 900)$。
1.  **段表查詢：** 段號 $s=2$。對應基底位址 `base = 3000`，限制 `limit = 800`。
2.  **範圍檢查：** 偏移量 $d=900$。檢查 $0 \le 900 < 800$ (不通過檢查)。 -> 觸發記憶體保護錯誤（段越界）。

#### 與相鄰概念的關聯
*   **與分頁的比較：**
    *   **分頁：** 記憶體劃分為固定大小的區塊（頁/頁框），對使用者透明，主要解決外部碎片，有內部碎片。由硬體自動管理。
    *   **分段：** 記憶體劃分為邏輯單位（段），大小可變，對使用者可見，更符合程式結構。可能產生外部碎片。
*   **分頁與分段的組合：** 有些系統會同時使用分頁和分段，例如，將每個段再進行分頁。這樣既能從邏輯上組織程式（分段），又能消除外部碎片並利用虛擬記憶體技術（分頁）。

-----

### 5.7 虛擬記憶體 (Virtual Memory)

#### 核心概念/定義
虛擬記憶體是一種記憶體管理技術，它允許程序使用一個比實際主記憶體（RAM）更大的邏輯位址空間。其核心思想是，不是將整個程序一次性載入主記憶體，而是只載入程序中目前正在使用或可能很快會使用的部分。未使用的部分則儲存在輔助儲存裝置（如硬碟）上。

*   **需求分頁 (Demand Paging)：** 虛擬記憶體最常見的實現方式。只有當程序實際需要某個頁面時，才將其從輔助儲存裝置載入到主記憶體。
*   **頁錯誤 (Page Fault)：** 當 CPU 試圖存取一個位於虛擬位址空間，但尚未載入主記憶體的頁面時，會發生頁錯誤。這是由硬體觸發的中斷，作業系統會介入處理。

#### 典型例子與推導
**需求分頁的工作流程：**
1.  CPU 產生一個邏輯位址。
2.  MMU 將邏輯位址轉換為實體位址，並檢查頁表。
3.  頁表條目中包含一個「有效-無效位元 (valid-invalid bit)」：
    *   如果有效位元為 `v` (valid)，表示頁面已在主記憶體中，MMU 正常進行位址轉換。
    *   如果有效位元為 `i` (invalid)，表示頁面不在主記憶體中，MMU 觸發一個頁錯誤 (Page Fault)。
4.  **頁錯誤處理程序：**
    a.  作業系統保存 CPU 狀態。
    b.  確定是合法的記憶體存取（即頁面在磁碟上，而不是非法存取）。
    c.  在輔助儲存裝置上找到所需的頁面。
    d.  在主記憶體中找到一個空閒的頁框。
    e.  將磁碟上的頁面讀取到找到的頁框中。
    f.  更新頁表條目（將有效位元設為 `v`，並填入新的頁框號）。
    g.  重新啟動因頁錯誤而中斷的指令。

**頁替換演算法 (Page Replacement Algorithms)：**
當主記憶體中沒有空閒頁框來載入新頁時，作業系統必須選擇一個現有的頁面從主記憶體中「換出 (swap out)」到輔助儲存裝置，為新頁騰出空間。選擇哪個頁面換出由頁替換演算法決定。

假設主記憶體有 $N$ 個頁框。
以下是常見的頁替換演算法，以頁參考串 `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1` 為例，頁框數為 3。

1.  **先進先出 (FIFO, First-In, First-Out)：**
    *   換出最早進入主記憶體的頁面。
    *   **優點：** 實現簡單。
    *   **缺點：** 可能換出經常使用的頁面，導致「Belady 異常」（增加頁框數量反而增加頁錯誤）。

    | 參考串 | 頁框 1 | 頁框 2 | 頁框 3 | 頁錯誤 | 說明                                          |
    | :----- | :----- | :----- | :----- | :----- | :-------------------------------------------- |
    | 7      | 7      |        |        | Y      | 載入 7                                        |
    | 0      | 7      | 0      |        | Y      | 載入 0                                        |
    | 1      | 7      | 0      | 1      | Y      | 載入 1                                        |
    | 2      | 2      | 0      | 1      | Y      | 7 最早進入，換出 7，載入 2                    |
    | 0      | 2      | 0      | 1      | N      | 0 已在記憶體中                                |
    | 3      | 2      | 3      | 1      | Y      | 0 最早進入（但最近被存取），換出 0，載入 3    |
    | ...    | ...    | ...    | ...    | ...    |                                               |
    **總頁錯誤數：** (計算後)

2.  **最近最少使用 (LRU, Least Recently Used)：**
    *   換出在過去最長時間內沒有被使用過的頁面。
    *   **優點：** 趨近於最佳演算法，且不會發生 Belady 異常。
    *   **缺點：** 實現複雜，需要硬體支援（如時間戳記或計數器）或軟體維護一個堆疊來追蹤頁面的使用時間。

    | 參考串 | 頁框 1 | 頁框 2 | 頁框 3 | 頁錯誤 | 說明                                          |
    | :----- | :----- | :----- | :----- | :----- | :-------------------------------------------- |
    | 7      | 7      |        |        | Y      | 載入 7                                        |
    | 0      | 7      | 0      |        | Y      | 載入 0                                        |
    | 1      | 7      | 0      | 1      | Y      | 載入 1                                        |
    | 2      | 2      | 0      | 1      | Y      | 7 最久未用，換出 7，載入 2                    |
    | 0      | 2      | 0      | 1      | N      | 0 已在記憶體中，變為最近使用                  |
    | 3      | 2      | 0      | 3      | Y      | 1 最久未用，換出 1，載入 3                    |
    | ...    | ...    | ...    | ...    | ...    |                                               |
    **總頁錯誤數：** (計算後)

3.  **最佳頁替換 (OPT, Optimal Page Replacement)：**
    *   換出在未來最長時間內不會被使用的頁面。
    *   **優點：** 理論上頁錯誤最少，是最佳演算法。
    *   **缺點：** 無法實現，因為需要預知未來的頁參考序列。作為基準用於比較其他演算法。

    | 參考串 | 頁框 1 | 頁框 2 | 頁框 3 | 頁錯誤 | 說明                                          |
    | :----- | :----- | :----- | :----- | :----- | :-------------------------------------------- |
    | 7      | 7      |        |        | Y      | 載入 7                                        |
    | 0      | 7      | 0      |        | Y      | 載入 0                                        |
    | 1      | 7      | 0      | 1      | Y      | 載入 1                                        |
    | 2      | 2      | 0      | 1      | Y      | 未來 7 最久不會被用到，換出 7，載入 2         |
    | 0      | 2      | 0      | 1      | N      | 0 已在記憶體中                                |
    | 3      | 2      | 0      | 3      | Y      | 未來 1 最久不會被用到，換出 1，載入 3         |
    | ...    | ...    | ...    | ...    | ...    |                                               |
    **總頁錯誤數：** (計算後)

**抖動 (Thrashing)：**
當一個程序的頁錯誤率非常高，導致系統花費大部分時間在頁面換入換出，而幾乎沒有時間執行實際計算時，就發生了抖動。這通常是因為程序沒有足夠的頁框來容納其「工作集 (Working Set)」（程序在一段時間內最常存取的頁面集合）。
**解決方案：**
*   提供更多頁框（如果可能）。
*   降低多工度（暫停或終止一些程序）。
*   實施頁面置換策略時考慮工作集模型。

#### 與相鄰概念的關聯
*   **分頁的延伸：** 虛擬記憶體是建立在分頁機制之上的。
*   **輔助儲存裝置管理：** 虛擬記憶體依賴於輔助儲存裝置來存放未載入主記憶體的頁面。頁面換入換出涉及輔助儲存裝置的讀寫。

-----

### 5.8 輔助儲存裝置管理 (Secondary Storage Management)

#### 核心概念/定義
輔助儲存裝置（如硬碟 HDD, 固態硬碟 SSD）用於永久儲存大量資料和程序。輔助儲存裝置管理涉及對這些設備的物理和邏輯層面進行管理，以提高存取效能、可靠性和儲存效率。

**磁碟結構 (Disk Structure)：**
*   **磁盤 (Platter)：** 磁碟機內部的圓形盤片，雙面塗有磁性材料。
*   **磁頭 (Head)：** 讀寫磁盤資料的元件。
*   **磁軌 (Track)：** 磁盤上同心圓的環形區域。
*   **磁區 (Sector)：** 磁軌上最小的物理儲存單位，通常為 512 位元組。
*   **磁柱 (Cylinder)：** 所有磁盤上位於相同半徑的磁軌組成的垂直集合。

**存取時間：**
磁碟存取時間主要由三個部分組成：
1.  **尋道時間 (Seek Time)：** 磁頭移動到正確磁軌所需的時間。
2.  **旋轉延遲 (Rotational Latency)：** 等待目標磁區旋轉到磁頭下方所需的時間。
3.  **傳輸時間 (Transfer Time)：** 實際讀取或寫入資料所需的時間。

#### 典型例子與推導
**磁碟排程演算法 (Disk Scheduling Algorithms)：**
由於尋道時間是磁碟存取中最耗時的部分，磁碟排程演算法的目標是最小化磁頭移動距離，從而提高磁碟I/O的總體吞吐量。

假設磁頭當前位於 53 號磁柱，有以下磁柱請求佇列：98, 183, 37, 122, 14, 124, 65, 67。磁柱範圍為 0 到 199。

1.  **先來先服務 (FCFS, First-Come, First-Served)：**
    *   按照請求到達的順序服務。
    *   **優點：** 公平，實現簡單。
    *   **缺點：** 可能導致較長的尋道時間。
    *   **磁頭移動：** `53 -> 98 -> 183 -> 37 -> 122 -> 14 -> 124 -> 65 -> 67`
    *   **總移動距離：** $|98-53| + |183-98| + |37-183| + |122-37| + |14-122| + |124-14| + |65-124| + |67-65|$
        $= 45 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = 640$ 磁柱。

2.  **最短尋道時間優先 (SSTF, Shortest-Seek-Time First)：**
    *   選擇離當前磁頭位置最近的請求進行服務。
    *   **優點：** 尋道時間最短，吞吐量最高。
    *   **缺點：** 可能導致「飢餓 (starvation)」，遠離磁頭的請求可能永遠得不到服務。
    *   **磁頭移動：** `53 -> 65 -> 67 -> 37 -> 14 -> 98 -> 122 -> 124 -> 183`
    *   **總移動距離：** $|65-53| + |67-65| + |37-67| + |14-37| + |98-14| + |122-98| + |124-122| + |183-124|$
        $= 12 + 2 + 30 + 23 + 84 + 24 + 2 + 59 = 236$ 磁柱。

3.  **SCAN (電梯演算法)：**
    *   磁頭沿一個方向移動，服務沿途的所有請求，到達磁碟末端後反向移動，再次服務沿途請求。
    *   假設磁頭向右移動。
    *   **磁頭移動：** `53 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183 -> 199 (末端) -> 37 -> 14`
    *   **總移動距離：** $|199-53| + |199-14| = 146 + 185 = 331$ 磁柱。

4.  **C-SCAN (循環 SCAN)：**
    *   磁頭沿一個方向移動，服務沿途所有請求。到達一端後，立即跳轉到另一端（不服務跳轉路徑上的請求），然後再次沿相同方向移動。
    *   假設磁頭向右移動。
    *   **磁頭移動：** `53 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183 -> 199 (末端) -> 0 (跳轉) -> 14 -> 37`
    *   **總移動距離：** $|199-53| + |199-0| + |37-0| = 146 + 199 + 37 = 382$ 磁柱。

5.  **LOOK / C-LOOK：** 類似 SCAN / C-SCAN，但磁頭到達最遠的請求後立即反向，而不需要移動到磁碟的物理末端。

**RAID (Redundant Array of Independent Disks)：**
RAID 是一種將多個實體硬碟組合起來，在作業系統中呈現為一個或多個邏輯硬碟的技術。目標是提高資料的可靠性、可用性和/或I/O效能。
*   **RAID 0 (條帶化 Striping)：** 將資料分散儲存在多個磁碟上，提高讀寫速度，但沒有冗餘，任意一個磁碟失效都會導致資料丟失。
*   **RAID 1 (鏡像 Mirroring)：** 將資料完全複製到兩組磁碟上，提供高可靠性，但儲存利用率為 50%。
*   **RAID 5 (帶有分佈式同位元的條帶化)：** 條帶化數據和同位元訊息分佈在所有磁碟上。提供冗餘和較好的讀寫性能，可以容忍一個磁碟失效。

#### 與相鄰概念的關聯
*   **檔案系統：** 輔助儲存裝置管理為檔案系統提供了底層的物理塊儲存。檔案系統負責將這些塊組織成檔案和目錄。
*   **虛擬記憶體：** 輔助儲存裝置被用作虛擬記憶體的後備儲存 (backing store)，用於頁面換入換出。

-----

### 5.9 常見錯誤與澄清

1.  **內部碎片 vs. 外部碎片：**
    *   **內部碎片：** 是指**已分配**給程序的記憶體區塊中，未被程序實際使用的部分。例如，分頁中，一個4KB的頁面可能只被程序使用了3KB，那麼1KB就是內部碎片。其特點是空間在已分配的單元內部。
    *   **外部碎片：** 是指**未分配**的記憶體空間中，由於不連續而無法被利用的部分。例如，連續式記憶體配置中，許多小的空閒區塊散佈在整個記憶體中，它們的總和可能很大，但因為不連續，無法滿足大程序的記憶體需求。

2.  **分頁 vs. 分段：**
    *   **分頁：**
        *   **單位：** 固定大小的頁 (Page)。
        *   **視角：** 機器視角，對使用者透明。
        *   **解決問題：** 外部碎片。
        *   **產生問題：** 內部碎片。
        *   **位址空間：** 一維的邏輯位址空間。
    *   **分段：**
        *   **單位：** 邏輯單元（如程式碼、資料、堆疊），大小可變的段 (Segment)。
        *   **視角：** 使用者視角，符合程式結構。
        *   **解決問題：** 有利於共享和保護。
        *   **產生問題：** 外部碎片。
        *   **位址空間：** 二維的邏輯位址空間 (段號, 偏移量)。

3.  **邏輯位址 vs. 實體位址：**
    *   **邏輯位址：** CPU 產生，是程序所看到的位址，從 0 開始，連續且抽象。
    *   **實體位址：** 實際記憶體晶片上的位址，由記憶體管理單元 (MMU) 將邏輯位址轉換而來。
    兩者之間的分離是實現記憶體保護和虛擬記憶體的關鍵。

4.  **TLB vs. Page Table：**
    *   **頁表 (Page Table)：** 儲存完整的頁號到頁框號的映射關係。通常存放在主記憶體中。訪問頁表需要一次主記憶體存取。
    *   **轉譯後備緩衝區 (TLB)：** 頁表的一個小型、高速硬體快取。它只儲存**最近使用**的頁表條目。旨在加速位址轉換過程。TLB 命中可以避免一次主記憶體存取。

-----

### 5.10 小練習（附詳解）

#### 小練習 1：分頁位址轉換

假設一個系統使用分頁機制：
*   頁大小為 2KB。
*   邏輯位址空間為 64KB。
*   某程序的頁表如下：

| 頁號 | 頁框號 |
| :--- | :----- |
| 0    | 5      |
| 1    | 2      |
| 2    | 8      |
| 3    | 1      |
| 4    | 6      |
| 5    | 3      |
| 6    | (無效) |
| 7    | 4      |

請計算以下邏輯位址對應的實體位址：
1.  邏輯位址 10240
2.  邏輯位址 13312
3.  邏輯位址 14000

---

#### 詳解 1：

**步驟 1：確定頁大小的位元數**
頁大小為 2KB。
$2 \text{KB} = 2 \times 1024 \text{ Bytes} = 2^{11} \text{ Bytes}$。
所以，頁偏移量 $d$ 需要 11 位元。

**步驟 2：確定邏輯位址中頁號的位元數**
邏輯位址空間為 64KB。
總共的頁數為 $64 \text{KB} / 2 \text{KB} = 32$ 頁。
頁號 $p$ 需要 $\log_2(32) = 5$ 位元。
所以，邏輯位址由高 5 位的頁號和低 11 位的頁偏移量組成。

**計算：**

1.  **邏輯位址 10240**
    a.  **計算頁號 $p$：** $p = \lfloor 10240 / 2048 \rfloor = \lfloor 5 \rfloor = 5$
    b.  **計算頁偏移量 $d$：** $d = 10240 \pmod{2048} = 0$
    c.  **查詢頁表：** 頁號 5 對應的頁框號為 3。
    d.  **計算實體位址：** 實體位址 $A = (\text{頁框號} \times \text{頁大小}) + \text{頁偏移量}$
        $A = (3 \times 2048) + 0 = 6144 + 0 = 6144$

2.  **邏輯位址 13312**
    a.  **計算頁號 $p$：** $p = \lfloor 13312 / 2048 \rfloor = \lfloor 6.5 \rfloor = 6$
    b.  **計算頁偏移量 $d$：** $d = 13312 \pmod{2048} = 1024$
    c.  **查詢頁表：** 頁號 6 對應的頁框號為 (無效)。
    d.  **結果：** 觸發頁錯誤 (Page Fault)，表示該頁不在主記憶體中或為非法存取。

3.  **邏輯位址 14000**
    a.  **計算頁號 $p$：** $p = \lfloor 14000 / 2048 \rfloor = \lfloor 6.83 \rfloor = 6$
    b.  **計算頁偏移量 $d$：** $d = 14000 \pmod{2048} = 1808$
    c.  **查詢頁表：** 頁號 6 對應的頁框號為 (無效)。
    d.  **結果：** 觸發頁錯誤 (Page Fault)。

---

#### 小練習 2：頁替換演算法 (LRU)

假設主記憶體有 3 個頁框。請使用 **LRU (最近最少使用)** 頁替換演算法，計算以下頁參考串的頁錯誤次數。
頁參考串：`1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`

---

#### 詳解 2：

**頁框數：3**
**頁參考串：`1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`**

我們將使用一個表格來追蹤頁框狀態和頁錯誤。LRU 演算法的關鍵是識別**過去最久未使用**的頁面。

| 參考頁 | 頁框 1 | 頁框 2 | 頁框 3 | 頁錯誤 | LRU 頁（待替換） |
| :----- | :----- | :----- | :----- | :----- | :--------------- |
| **1**  | 1      |        |        | Y      |                  |
| **2**  | 1      | 2      |        | Y      |                  |
| **3**  | 1      | 2      | 3      | Y      |                  |
| **4**  | 4      | 2      | 3      | Y      | 1 (最久未使用)   |
| **1**  | 4      | 1      | 3      | Y      | 2 (最久未使用)   |
| **2**  | 4      | 1      | 2      | Y      | 3 (最久未使用)   |
| **5**  | 5      | 1      | 2      | Y      | 4 (最久未使用)   |
| **1**  | 5      | 1      | 2      | N      |                  |
| **2**  | 5      | 1      | 2      | N      |                  |
| **3**  | 5      | 3      | 2      | Y      | 1 (最久未使用)   |
| **4**  | 5      | 4      | 2      | Y      | 3 (最久未使用)   |
| **5**  | 5      | 4      | 2      | N      |                  |

**總頁錯誤次數：9**

**詳細解釋：**
1.  **1, 2, 3：** 首次載入，三個頁框依序填滿，各產生 1 次頁錯誤。
2.  **4：** 頁框已滿。1 是最久未使用的（在 1, 2, 3 之後就沒用過）。替換 1，載入 4。`[4, 2, 3]`。頁錯誤。
3.  **1：** 頁框已滿。2 是最久未使用的（在 4 進入前最後一次用到）。替換 2，載入 1。`[4, 1, 3]`。頁錯誤。
4.  **2：** 頁框已滿。3 是最久未使用的。替換 3，載入 2。`[4, 1, 2]`。頁錯誤。
5.  **5：** 頁框已滿。4 是最久未使用的。替換 4，載入 5。`[5, 1, 2]`。頁錯誤。
6.  **1：** 已在頁框中。無頁錯誤。
7.  **2：** 已在頁框中。無頁錯誤。
8.  **3：** 頁框已滿。1 是最久未使用的（在 5 進入後，1 被使用過，但 1 的位置在中間，2最近用過，5也最近用過，所以1是相對最久未用）。替換 1，載入 3。`[5, 3, 2]`。頁錯誤。
9.  **4：** 頁框已滿。2 是最久未使用的（在 3 進入後，2被使用過，但5也最近用過，3剛進入，所以2是相對最久未用）。替換 2，載入 4。`[5, 3, 4]`。頁錯誤。
10. **5：** 已在頁框中。無頁錯誤。

因此，總頁錯誤次數為 9。

-----

### 5.11 延伸閱讀/參考

*   **Operating System Concepts** by Abraham Silberschatz, Peter B. Galvin, Greg Gagne
    *   經典作業系統教材，提供深入的理論和實踐細節。
*   **Modern Operating Systems** by Andrew S. Tanenbaum, Herbert Bos
    *   以清晰易懂的方式介紹作業系統概念，包含大量範例。
*   **Operating Systems: Internals and Design Principles** by William Stallings
    *   強調作業系統的內部運作機制和設計原理。
*   **關於虛擬記憶體和分頁的線上教程**
    *   例如 GeeksforGeeks, TutorialsPoint 等網站，通常有圖解和範例幫助理解。
*   **Linux 核心原始碼中記憶體管理部分**
    *   對於進階學習者，研究實際作業系統（如 Linux）的記憶體管理實現是一個很好的方式。