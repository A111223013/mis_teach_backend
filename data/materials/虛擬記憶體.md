# 虛擬記憶體

## ### 1. 核心概念與定義

虛擬記憶體（Virtual Memory）是作業系統的一項記憶體管理技術，它透過將電腦的硬碟空間作為額外的隨機存取記憶體（RAM）來擴展程式可用的記憶體容量，並提供記憶體保護與多工處理的能力。它為每個程式提供一個連續、獨立的「虛擬位址空間」，讓程式感覺擁有比實際物理記憶體更大的記憶體空間。

-----

#### 1.1 虛擬位址空間與物理位址空間

*   **定義：**
    *   **虛擬位址空間 (Virtual Address Space, VAS)**：程式執行時所看到的記憶體空間，由虛擬位址 (Virtual Address, VA) 組成。每個行程（Process）都有自己獨立的虛擬位址空間，通常從 0 開始到最大位址。
    *   **物理位址空間 (Physical Address Space, PAS)**：實際存在於電腦隨機存取記憶體 (RAM) 中的記憶體空間，由物理位址 (Physical Address, PA) 組成。這是 CPU 真正用來讀取或寫入資料的位址。

*   **核心觀念：**
    虛擬記憶體的根本思想是「解耦」(decoupling)。它將程式使用的邏輯位址（虛擬位址）與記憶體硬體使用的實際位址（物理位址）分開。這層抽象化使得程式員不需要知道記憶體如何實際管理，也使得作業系統能更靈活地管理記憶體資源。

*   **例子：**
    假設一台電腦有 4GB 的物理記憶體，但兩個程式（A 和 B）各自需要 3GB 的記憶體。如果沒有虛擬記憶體，這兩個程式無法同時運行。有了虛擬記憶體，程式 A 和 B 各自認為自己擁有 3GB 的虛擬位址空間，作業系統會將它們的虛擬記憶體頁面按需映射到物理記憶體中，並將暫時不用的頁面存儲到磁碟上。

*   **與相鄰概念的關聯：**
    虛擬位址空間是程式的「視角」，物理位址空間是硬體的「現實」。MMU（記憶體管理單元）負責在兩者之間進行翻譯。

-----

#### 1.2 頁面（Page）與頁框（Frame）

*   **定義：**
    *   **頁面 (Page)**：虛擬記憶體空間被劃分成固定大小的區塊，每個區塊稱為一個頁面。
    *   **頁框 (Page Frame 或 Frame)**：物理記憶體空間被劃分成與頁面相同大小的區塊，每個區塊稱為一個頁框。

*   **核心觀念：**
    虛擬記憶體的最常見實現方式是「分頁（Paging）」。頁面和頁框是分頁機制的最小管理單位。程式的虛擬頁面會被按需載入到物理記憶體中的某個空閒頁框。

*   **例子：**
    如果頁面大小是 4KB（4096 位元組），那麼一個 32 位元（4GB）的虛擬位址空間將包含 $2^{32} / 2^{12} = 2^{20}$ 個頁面，即 1 百萬個頁面。同樣，如果物理記憶體是 4GB，它也包含 1 百萬個頁框。

*   **與相鄰概念的關聯：**
    頁面和頁框是進行「虛擬到物理位址翻譯」的基本單元。頁表就是用來記錄虛擬頁面與物理頁框之間對應關係的資料結構。

-----

#### 1.3 頁表（Page Table）

*   **定義：**
    頁表是一個由作業系統維護的資料結構，用於儲存虛擬頁面與物理頁框之間的映射關係。每個行程都有自己獨立的頁表。

*   **核心觀念：**
    當 CPU 產生一個虛擬位址時，MMU 會查詢頁表來找到對應的物理位址。頁表的每個條目（Page Table Entry, PTE）通常包含：
    *   **頁框號碼 (Page Frame Number, PFN)**：指示該虛擬頁面在物理記憶體中對應的頁框號碼。
    *   **有效位元 (Valid Bit)**：指示該頁面是否目前在物理記憶體中。若為 0，表示不在，會觸發頁面錯誤。
    *   **修改位元/髒位元 (Dirty Bit)**：指示該頁面自上次載入物理記憶體後是否被修改過。用於頁面置換時判斷是否需要寫回磁碟。
    *   **存取位元 (Accessed Bit)**：指示該頁面最近是否被存取過。用於頁面置換演算法。
    *   **保護位元 (Protection Bits)**：指示該頁面的存取權限（讀、寫、執行等）。

*   **例子：**
    | 虛擬頁號 | 有效位元 | 頁框號碼 | 權限位元 |
    | :------: | :------: | :------: | :------: |
    |    0     |    1     |    5     |   RWX    |
    |    1     |    1     |    8     |    R     |
    |    2     |    0     |    -     |   RWX    |
    |    3     |    1     |    2     |    RW    |
    當 CPU 嘗試存取虛擬頁面 2 時，發現其有效位元為 0，便會觸發頁面錯誤。

*   **與相鄰概念的關聯：**
    頁表是 MMU 進行位址翻譯的關鍵依據，也是實現記憶體保護的基礎。它的存在會引入額外的記憶體存取開銷，這促使了 TLB 的誕生。

-----

#### 1.4 記憶體管理單元（MMU）

*   **定義：**
    記憶體管理單元 (Memory Management Unit, MMU) 是 CPU 內部或鄰近 CPU 的硬體元件，負責將 CPU 產生的虛擬位址即時翻譯成物理位址。

*   **核心觀念：**
    MMU 是虛擬記憶體機制的硬體核心。每次記憶體存取都必須經過 MMU 的翻譯。這個過程對應用程式是透明的。

*   **例子：**
    當程式執行指令 `MOV EAX, [0x12345678]` 時，CPU 會產生虛擬位址 `0x12345678`。MMU 會截獲這個位址，根據當前行程的頁表將其翻譯成一個物理位址，然後才將這個物理位址發送給記憶體控制器去存取 RAM。

*   **與相鄰概念的關聯：**
    MMU 讀取頁表，並利用 TLB 加速翻譯過程。頁面錯誤也是由 MMU 檢測到的。

-----

#### 1.5 頁面錯誤（Page Fault）

*   **定義：**
    頁面錯誤（Page Fault）是一種中斷（Trap），發生在程式嘗試存取一個虛擬頁面，而該頁面目前不在物理記憶體中時。

*   **核心觀念：**
    頁面錯誤是虛擬記憶體實現「需求分頁 (Demand Paging)」的關鍵機制，它並非程式錯誤，而是作業系統正常運作的一部分。當發生頁面錯誤時，作業系統會執行以下步驟：
    1.  中斷程式執行，將控制權交給頁面錯誤處理器。
    2.  檢查該虛擬位址是否合法（例如，是否在程式的有效位址範圍內）。
    3.  從磁碟中找到包含所需資料的頁面。
    4.  在物理記憶體中找到一個空閒頁框。如果沒有空閒頁框，則需要執行頁面置換演算法選出一個頁面來犧牲。
    5.  將磁碟上的頁面內容載入到選定的物理頁框中。
    6.  更新頁表，將新載入頁面的頁表條目中的有效位元設為 1，並指向新的頁框號碼。
    7.  重新執行導致頁面錯誤的指令。

*   **例子：**
    一個程式開始執行時，只有少數頁面被載入物理記憶體。當程式執行到某個需要尚未載入的程式碼或資料的位址時，就會觸發頁面錯誤。作業系統會從硬碟中載入該頁面，程式才能繼續執行。

*   **與相鄰概念的關聯：**
    頁面錯誤是需求分頁的直接結果，它的處理過程會觸發頁面置換演算法。

-----

## ### 2. 典型例子與轉換/推導

#### 2.1 虛擬位址到物理位址的翻譯

虛擬位址 (VA) 到物理位址 (PA) 的翻譯是虛擬記憶體最核心的運作機制。它將一個由 CPU 產生的邏輯位址轉換為 RAM 中實際的物理位址。

*   **推導過程：**
    1.  **解析虛擬位址 (VA)**：
        虛擬位址被 MMU 分割成兩部分：
        *   **虛擬頁號 (Virtual Page Number, VPN)**：用於在頁表中查找對應的頁表條目。
        *   **頁內偏移量 (Page Offset)**：在頁面內的位址，翻譯時保持不變。
        若頁面大小為 $2^P$ 位元組，則頁內偏移量佔 $P$ 位元，虛擬頁號佔剩餘位元。
        `VA = [ VPN | Page Offset ]`
        其中，`VPN = VA / PageSize` (整數除法) 或 `VA >> P`
        `Page Offset = VA % PageSize` (模運算) 或 `VA & (PageSize - 1)`

    2.  **查詢頁表**：
        MMU 使用 VPN 作為索引，去查找當前行程的頁表，以獲得對應的頁表條目 (PTE)。頁表基底位址儲存在一個專用的 CPU 暫存器（例如 `CR3` 在 x86 上）。

    3.  **檢查有效性與權限**：
        *   **有效位元 (Valid Bit)**：如果 PTE 中的有效位元為 0，表示該頁面不在物理記憶體中，會觸發**頁面錯誤 (Page Fault)**。作業系統接管處理，將頁面從磁碟載入。
        *   **保護位元 (Protection Bits)**：MMU 還會檢查存取權限（讀/寫/執行）。如果當前操作不符合權限，會觸發**保護錯誤 (Protection Fault)**。

    4.  **構造物理位址 (PA)**：
        如果 PTE 有效且權限檢查通過，MMU 從 PTE 中提取**物理頁框號 (Physical Frame Number, PFN)**。
        物理位址由 PFN 和原始的 Page Offset 組合而成：
        `PA = [ PFN | Page Offset ]`
        其中，`PA = (PFN * PageSize) + Page Offset` 或 `(PFN << P) | Page Offset`

*   **例子：**
    假設系統設定如下：
    *   虛擬位址空間大小：32 位元 ($2^{32}$ 位元組 = 4GB)
    *   物理記憶體大小：1GB
    *   頁面大小：4KB ($2^{12}$ 位元組)

    1.  **計算位元長度：**
        *   頁面偏移量：由於頁面大小是 $2^{12}$ 位元組，所以頁面偏移量需要 12 位元。
        *   虛擬頁號：虛擬位址總共 32 位元，所以虛擬頁號需要 $32 - 12 = 20$ 位元。
        *   物理頁框號：物理記憶體 1GB = $2^{30}$ 位元組。頁框大小 4KB = $2^{12}$ 位元組。
            所以物理頁框總數為 $2^{30} / 2^{12} = 2^{18}$ 個。
            物理頁框號需要 18 位元。

    2.  **翻譯一個虛擬位址 (VA)：**
        假設有一個虛擬位址 `0x00A0B0C4`。
        *   **步驟 1：解析虛擬位址**
            `VA = 0x00A0B0C4`
            *   頁面偏移量 (Page Offset)：取 VA 的低 12 位元。
                `0x00A0B0C4 & 0xFFF = 0x0C4`
            *   虛擬頁號 (VPN)：取 VA 的高 20 位元。
                `0x00A0B0C4 >> 12 = 0x0A0B0`

        *   **步驟 2：查詢頁表**
            假設當前行程的頁表包含以下條目（簡化，實際是多級頁表或更複雜結構）：
            | 虛擬頁號 (VPN) | 物理頁框號 (PFN) | 有效位元 |
            | :-------------: | :--------------: | :------: |
            |    `0x0A0B0`    |     `0x12345`    |    1     |
            MMU 根據 VPN `0x0A0B0` 查找到對應的 PTE，獲得 PFN `0x12345` 和有效位元 `1`。

        *   **步驟 3：構造物理位址**
            由於有效位元為 1，且假設權限允許，MMU 將 PFN 和 Page Offset 組合。
            `PA = (PFN << 12) | Page Offset`
            `PA = (0x12345 << 12) | 0x0C4`
            `PA = 0x12345000 + 0x0C4`
            `PA = 0x123450C4`
            這個 `0x123450C4` 就是資料在物理記憶體中的實際位置。

-----

#### 2.2 多層頁表（Multi-level Page Tables）

*   **定義：**
    為了減少頁表佔用的記憶體空間，特別是對於稀疏（sparse）的虛擬位址空間，作業系統會使用多層頁表結構。它將一個巨大的頁表拆分成多個層級，只有被實際使用的虛擬位址範圍才需要創建相應的下級頁表。

*   **推導過程：**
    多層頁表的思想是將虛擬頁號 (VPN) 進一步拆分成多個層級的索引。例如，對於一個兩層頁表：
    `VA = [ Page Directory Index (PDI) | Page Table Index (PTI) | Page Offset ]`

    翻譯過程：
    1.  從 CPU 的頁表基底暫存器（如 CR3）獲取第一級頁表（頁目錄）的物理位址。
    2.  使用 PDI 作為索引，在頁目錄中查找，得到第二級頁表（實際頁表）的物理位址。
    3.  使用 PTI 作為索引，在第二級頁表中查找，得到最終的物理頁框號 (PFN)。
    4.  結合 PFN 和 Page Offset 構成最終的物理位址。

*   **例子：**
    假設 32 位元虛擬位址，4KB 頁面大小。
    *   頁面偏移量：12 位元 (2^12 = 4KB)
    *   虛擬頁號 (VPN)：32 - 12 = 20 位元

    如果使用單層頁表，需要 $2^{20}$ 個頁表條目。每個條目 4 位元組，頁表大小為 $2^{20} \times 4$ 位元組 = 4MB。對於每個行程，如果頁表都在物理記憶體中，這是很大的開銷。

    使用兩層頁表：
    將 20 位的 VPN 拆分為兩個 10 位的索引：
    `VA = [ 10-bit PDI | 10-bit PTI | 12-bit Page Offset ]`

    *   **第一級頁表 (Page Directory)**：$2^{10}$ 個條目。每個條目指向一個第二級頁表。
    *   **第二級頁表 (Page Table)**：$2^{10}$ 個條目。每個條目指向一個物理頁框。

    如果一個行程只使用了其虛擬位址空間的一小部分，例如只用了第一個 4MB 的空間（即只有第一個 Page Directory Index 被使用），那麼只需要一個 Page Directory 和一個第二級 Page Table。這樣，頁表佔用的空間就從 4MB 減少到 $2^{10} \times 4 \text{ Bytes} + 2^{10} \times 4 \text{ Bytes} = 4\text{KB} + 4\text{KB} = 8\text{KB}$。

*   **與相鄰概念的關聯：**
    多層頁表是單層頁表的優化，旨在減少頁表本身的記憶體消耗，特別適用於稀疏的位址空間。它的缺點是翻譯一個位址需要多次記憶體存取來查詢多個頁表層級，增加了延遲。TLB 的存在可以緩解這一問題。

-----

## ### 3. 與相鄰概念的關聯

#### 3.1 與快取記憶體 (Cache Memory) 的關聯：TLB

*   **TLB (Translation Lookaside Buffer)**
    *   **定義：** TLB 是一個專門的、小型且高速的硬體快取記憶體，用於儲存近期使用過的虛擬位址到物理位址的翻譯結果（頁表條目）。
    *   **關聯：** 虛擬位址翻譯需要查詢頁表，而頁表通常存儲在主記憶體中。每次記憶體存取都需要至少兩次主記憶體存取（一次查頁表，一次取資料），這會嚴重降低效能。TLB 的作用就是加速這個翻譯過程。當 CPU 產生一個虛擬位址時，MMU 會首先檢查 TLB。
        *   **TLB Hit (命中)**：如果翻譯結果在 TLB 中找到，則直接使用，無需存取主記憶體中的頁表。這是最快的路徑。
        *   **TLB Miss (未命中)**：如果翻譯結果不在 TLB 中，MMU 會執行一次正常的頁表走訪（Page Table Walk）去主記憶體中查詢頁表，找到翻譯結果後，更新 TLB 以備下次使用。
    *   **CPU 快取：** CPU 的資料快取和指令快取通常使用物理位址進行索引和標籤。因此，在進行快取查找之前，虛擬位址必須先經過 MMU 翻譯成物理位址。

-----

#### 3.2 與記憶體分頁 (Paging) 的關聯

*   **分頁 (Paging)**
    *   **關聯：** 虛擬記憶體是一個抽象的概念，而分頁是實現虛擬記憶體最常見且最主要的一種記憶體管理技術。虛擬記憶體透過將虛擬位址空間和物理位址空間都劃分為固定大小的「頁面」和「頁框」，並使用「頁表」進行映射，來實現其核心功能。可以說，分頁是虛擬記憶體的骨幹。

-----

#### 3.3 與記憶體分段 (Segmentation) 的關聯

*   **分段 (Segmentation)**
    *   **定義：** 分段是另一種記憶體管理技術，它將程式的記憶體劃分成邏輯上相關的、可變大小的區塊，稱為「段」（Segment）。每個段可以是程式碼、資料堆疊、堆積等。
    *   **關聯：** 分頁和分段都可以用來實現記憶體保護和多工處理。
        *   **純分頁**：簡潔、固定大小，但邏輯結構不明顯。
        *   **純分段**：保留程式的邏輯結構，但可變大小段的碎片化問題較難處理。
        *   **分段與分頁結合 (Segmented Paging)**：有些系統（如早期的 x86 架構）會結合兩者。首先將程式碼、資料等劃分為邏輯段，然後每個段內部再進行分頁。這樣既保留了邏輯結構，又利用了分頁處理碎片化的優勢。

-----

#### 3.4 與行程管理 (Process Management) 的關聯

*   **行程 (Process)**
    *   **關聯：** 虛擬記憶體為每個行程提供了獨立、隔離的虛擬位址空間。
        *   **隔離性：** 每個行程有自己的頁表，確保一個行程無法未經授權地存取另一個行程的記憶體。這提供了強大的記憶體保護。
        *   **上下文切換 (Context Switching)：** 當作業系統在不同行程之間切換時，它需要載入新行程的頁表基底位址到 CPU 的頁表暫存器（例如 `CR3`），這樣 MMU 才能使用正確的頁表來翻譯位址。
        *   **記憶體共享：** 不同的行程可以透過將它們各自虛擬位址空間中的不同虛擬頁面映射到相同的物理頁框，來共享程式碼（如共享函式庫）或資料。

-----

#### 3.5 與置換演算法 (Page Replacement Algorithms) 的關聯

*   **置換演算法 (Page Replacement Algorithms)**
    *   **關聯：** 當發生頁面錯誤且物理記憶體中沒有可用的空閒頁框時，作業系統必須選擇一個現有的頁面從物理記憶體中移除（可能寫回磁碟）以騰出空間。這就是頁面置換的場景。虛擬記憶體的效果和性能很大程度上取決於所採用的頁面置換演算法，例如：
        *   先進先出 (FIFO)
        *   最近最少使用 (LRU)
        *   最佳演算法 (Optimal)
        *   第二次機會演算法 (Second-Chance) 等。

-----

## ### 4. 進階內容

#### 4.1 寫入時複製 (Copy-on-Write, CoW)

*   **定義：** 寫入時複製 (Copy-on-Write, CoW) 是一種優化技術，常用於行程創建（如 `fork()` 系統呼叫）時。當父行程複製一個子行程時，它們一開始會共享所有記憶體頁面，而不是立即複製所有內容。這些共享頁面會被標記為只讀。只有當父行程或子行程中的任何一個嘗試「寫入」這些共享頁面時，作業系統才會實際複製該頁面，並將各自的頁表條目更新為指向新的獨立副本。

*   **核心觀念：** CoW 延遲了複製操作，直到真正需要寫入時才進行。如果子行程只讀取共享頁面或立即呼叫 `exec()` 載入新的程式，那麼複製操作永遠不會發生，大大節省了記憶體和 CPU 時間。

*   **例子：**
    1.  父行程呼叫 `fork()` 創建子行程。
    2.  作業系統為子行程創建一個新的頁表，但其中的頁表條目都指向父行程的物理頁框。這些頁面在兩者的頁表中都被標記為「只讀」。
    3.  如果父行程嘗試寫入某個共享頁面：
        a.  MMU 發現該頁面是只讀，觸發一個保護錯誤（一種特殊的頁面錯誤）。
        b.  作業系統複製該頁面到一個新的物理頁框。
        c.  更新父行程的頁表條目，使其指向新的頁框，並將其標記為「可寫」。
        d.  重新執行寫入操作。
    4.  如果子行程嘗試寫入某個共享頁面，步驟類似。

-----

#### 4.2 記憶體保護 (Memory Protection)

*   **定義：** 記憶體保護是作業系統的一項功能，旨在防止一個程式或行程存取其被分配之外的記憶體區域，從而保護系統的穩定性和其他程式的資料。

*   **核心觀念：** 虛擬記憶體透過頁表實現了強大的記憶體保護。每個頁表條目都包含保護位元（例如，讀/寫/執行權限）。
    *   **隔離性：** 每個行程有自己獨立的虛擬位址空間和頁表。除非明確共享，否則一個行程無法透過其頁表存取另一個行程的記憶體。
    *   **權限控制：** MMU 在每次存取記憶體時都會檢查頁表條目中的保護位元。如果程式嘗試執行的操作與頁面權限不符（例如，寫入一個只讀頁面，或執行一個非執行頁面），MMU 會觸發保護錯誤（Page Protection Fault），作業系統會終止該程式。
    *   **使用者/核心模式：** 頁表條目還可以包含特權級別位元，區分使用者模式和核心模式的存取權限，確保使用者程式無法直接存取核心記憶體。

-----

#### 4.3 需求分頁 (Demand Paging)

*   **定義：** 需求分頁是一種虛擬記憶體實現策略，它只在程式實際需要一個頁面時才將其從輔助儲存（硬碟）載入到物理記憶體中。程式啟動時，並不是所有的頁面都會被載入。

*   **核心觀念：**
    *   **延遲載入 (Lazy Loading)：** 頁面只在「需求」發生時（即第一次存取時）才載入。這與「預先載入 (Prefetching)」相反。
    *   **效率提升：** 大多數程式只會使用其虛擬位址空間的一小部分。需求分頁避免了載入那些從未被使用的頁面，從而減少了物理記憶體的需求，縮短了程式啟動時間，並允許更多的程式同時運行。
    *   **頁面錯誤的基礎：** 需求分頁的運作依賴於頁面錯誤機制。當程式存取一個不在物理記憶體中的頁面時，會觸發頁面錯誤，作業系統隨後將該頁面從磁碟載入。

*   **例子：**
    一個大型應用程式可能包含許多功能模組。當應用程式啟動時，只有主介面和核心邏輯的頁面會被載入。當使用者點擊一個不常用的功能按鈕時，該功能的程式碼和資料頁面才會被按需載入。

-----

## ### 5. 常見錯誤與澄清

#### 5.1 虛擬記憶體就是分頁嗎？

*   **常見錯誤：** 許多人會將「虛擬記憶體」與「分頁」劃上等號。
*   **澄清：** 虛擬記憶體是一個概念或技術框架，它提供了一系列抽象和功能，如更大的位址空間、記憶體保護和多工支持。分頁 (Paging) 是實現虛擬記憶體最流行、最廣泛使用的機制。換句話說，分頁是虛擬記憶體的一種**具體實現方式**，但虛擬記憶體還有其他的實現方式，例如早期的分段 (Segmentation) 也可以提供類似的功能。可以這麼理解：虛擬記憶體是目標，分頁是達成目標的手段。

-----

#### 5.2 頁面錯誤是程式錯誤嗎？

*   **常見錯誤：** 當看到「Page Fault」這個詞時，許多新手會誤以為這是程式的錯誤或系統崩潰的跡象。
*   **澄清：** 在大多數情況下，頁面錯誤是一種正常的作業系統機制，是實現需求分頁的必要環節。它表示程式嘗試存取的資料或指令不在物理記憶體中，而是在硬碟的交換區 (Swap Space) 或檔案系統中。作業系統會介入處理，將所需的頁面載入物理記憶體，然後讓程式繼續執行。只有當頁面錯誤是由非法位址存取（如存取不屬於該行程的位址）引起時，它才代表程式錯誤（通常會導致程式終止）。

-----

#### 5.3 TLB 與 CPU 快取是同一個東西嗎？

*   **常見錯誤：** 由於 TLB 也是一種快取，它有時會與 CPU 的資料/指令快取混淆。
*   **澄清：** TLB (Translation Lookaside Buffer) 和 CPU 的資料/指令快取是兩種不同目的的快取。
    *   **TLB：** 專門用於快取「虛擬位址到物理位址的翻譯結果」（頁表條目）。它的目的是加速位址翻譯過程。
    *   **CPU 快取 (L1/L2/L3 Cache)：** 用於快取「實際資料或指令」。它的目的是減少 CPU 存取主記憶體的次數。
    雖然它們都是快取，且都由硬體實現，但它們快取的內容和在記憶體存取路徑中的位置不同。一個虛擬位址在被翻譯成物理位址後，才會用這個物理位址去 CPU 快取中尋找資料。

-----

#### 5.4 「交換」(Swapping) 與「分頁」(Paging) 有何區別？

*   **常見錯誤：** 有時「交換」和「分頁」會被混用。
*   **澄清：**
    *   **交換 (Swapping)**：通常指將**整個行程**從物理記憶體中移到硬碟上的交換區（Swap Space），然後再將其從硬碟移回物理記憶體。這是一種較粗粒度的記憶體管理技術，主要用於將不再活躍的行程移出記憶體以騰出空間。
    *   **分頁 (Paging)**：虛擬記憶體的核心實現機制。它以固定大小的**頁面**為單位，將程式的虛擬位址空間劃分，並按需將單個頁面在物理記憶體和硬碟之間移動。這是更細粒度的管理方式，也是虛擬記憶體技術的基礎。
    虛擬記憶體主要是利用分頁機制，按需載入和置換頁面，而不是將整個行程換進換出。

-----

## ### 6. 小練習 (附詳解)

### 小練習 1：虛擬位址翻譯與頁表

**題目：**
假設一個 32 位元系統使用虛擬記憶體，頁面大小為 8KB。當前行程的頁表（部分）如下：

| 虛擬頁號 (VPN) | 物理頁框號 (PFN) | 有效位元 | 權限 |
| :------------: | :--------------: | :------: | :--: |
|      0x00      |      0x10        |    1     | RW   |
|      0x01      |      0x25        |    1     | R    |
|      0x02      |      0x00        |    0     | RW   |
|      0x03      |      0x30        |    1     | RWX  |
|      0x04      |      0x11        |    1     | R    |

請回答以下問題：
1.  頁內偏移量需要多少位元？
2.  虛擬頁號需要多少位元？
3.  請將虛擬位址 `0x00014567` 翻譯成物理位址。
4.  如果程式嘗試寫入虛擬位址 `0x00041234`，會發生什麼？

---

**詳解：**

1.  **頁內偏移量需要多少位元？**
    *   頁面大小為 8KB。
    *   $8KB = 8 \times 1024$ 位元組 $= 2^3 \times 2^{10}$ 位元組 $= 2^{13}$ 位元組。
    *   因此，頁內偏移量需要 **13 位元**。

2.  **虛擬頁號需要多少位元？**
    *   系統使用 32 位元虛擬位址。
    *   虛擬頁號位元 = 總位址位元 - 頁內偏移量位元 = $32 - 13 = 19$ 位元。
    *   因此，虛擬頁號需要 **19 位元**。

3.  **請將虛擬位址 `0x00014567` 翻譯成物理位址。**

    *   **步驟 1：解析虛擬位址**
        *   虛擬位址 `VA = 0x00014567`。
        *   頁面偏移量：取 VA 的低 13 位元。
            `Page Offset = 0x00014567 & (2^{13} - 1)`
            `2^{13} - 1 = 0x1FFF` (在 16 進制中)。
            `Page Offset = 0x00014567 & 0x1FFF = 0x0567`。
        *   虛擬頁號：取 VA 的高 19 位元。
            `VPN = 0x00014567 >> 13`
            `0x00014567` (二進制是 `0000 0000 0000 0001 0100 0101 0110 0111`)
            右移 13 位後，`VPN = 0x00002` (因為 `0x00014567` 是 `0000000000010100010101100111`，右移 13 位是 `00000000000000000010`，即十進制的 2，十六進制的 0x02)。

    *   **步驟 2：查詢頁表**
        *   根據 VPN `0x02`，查頁表。
        *   頁表顯示 VPN `0x02` 的有效位元為 `0`。

    *   **步驟 3：處理結果**
        *   由於有效位元為 `0`，這會觸發一個**頁面錯誤 (Page Fault)**。作業系統會介入，將虛擬頁面 0x02 從磁碟載入到一個物理頁框中。
        *   因此，無法直接翻譯為物理位址，而是會發生頁面錯誤。

4.  **如果程式嘗試寫入虛擬位址 `0x00041234`，會發生什麼？**

    *   **步驟 1：解析虛擬位址**
        *   虛擬位址 `VA = 0x00041234`。
        *   頁面偏移量：
            `Page Offset = 0x00041234 & 0x1FFF = 0x1234`。
        *   虛擬頁號：
            `VPN = 0x00041234 >> 13`
            `0x00041234` (二進制是 `0000 0000 0000 0100 0001 0010 0011 0100`)
            右移 13 位後，`VPN = 0x00004` (即十進制的 4，十六進制的 0x04)。

    *   **步驟 2：查詢頁表**
        *   根據 VPN `0x04`，查頁表。
        *   頁表顯示 VPN `0x04` 的有效位元為 `1`，物理頁框號為 `0x11`，權限為 `R` (只讀)。

    *   **步驟 3：處理結果**
        *   頁面有效，但程式嘗試「寫入」一個權限為「只讀 (R)」的頁面。
        *   這會觸發一個**保護錯誤 (Protection Fault)**。作業系統將會終止該程式。

---

### 小練習 2：頁表大小計算

**題目：**
一個系統使用 64 位元虛擬位址和 4KB 的頁面大小。假設頁表條目 (PTE) 的大小為 8 位元組。
1.  如果使用單層頁表，頁表會有多大？
2.  考慮到頁表本身也需要佔用物理記憶體，且頁表也按頁面大小來管理。如果一個行程只使用了其虛擬位址空間的最前端 4MB 區域，請問在單層頁表和多層頁表（假設每級頁表條目都為 8 位元組，且盡可能減少層數，但每級頁表本身不能超過 4KB 頁面大小）兩種情況下，最少需要多少個物理頁框來存放其頁表？

---

**詳解：**

1.  **如果使用單層頁表，頁表會有多大？**
    *   **步驟 1：計算頁面偏移量位元數**
        *   頁面大小為 4KB = $2^{12}$ 位元組。
        *   頁面偏移量需要 12 位元。
    *   **步驟 2：計算虛擬頁號位元數**
        *   虛擬位址為 64 位元。
        *   虛擬頁號 (VPN) 位元數 = $64 - 12 = 52$ 位元。
    *   **步驟 3：計算虛擬頁面總數**
        *   虛擬頁面總數 = $2^{52}$ 個。
    *   **步驟 4：計算單層頁表大小**
        *   頁表條目 (PTE) 大小為 8 位元組。
        *   單層頁表大小 = 虛擬頁面總數 $\times$ PTE 大小
            $= 2^{52} \times 8 \text{ Bytes}$
            $= 2^{52} \times 2^3 \text{ Bytes}$
            $= 2^{55} \text{ Bytes}$
            這是一個極其龐大的數字，大約 $3.6 \times 10^{16}$ 位元組，即 **36 PB (Petabytes)**。
            顯然，單層頁表對於 64 位元系統是不可行的。

2.  **單層頁表和多層頁表在只使用 4MB 區域時，最少需要多少個物理頁框來存放其頁表？**

    *   **前提計算：**
        *   頁面大小：4KB ($2^{12}$ Bytes)
        *   每個 PTE 大小：8 Bytes
        *   每個頁面（作為頁表）可以容納的 PTE 數量 = 頁面大小 / PTE 大小 = $4096 / 8 = 512$ 個 PTE。
        *   這意味著每一級頁表中的索引不能超過 512，即索引位元數為 $\log_2(512) = 9$ 位元。

    *   **方案一：單層頁表**
        *   如問題 1 所述，單層頁表需要 $2^{52}$ 個條目。即使只使用開頭的 4MB 虛擬空間，頁表仍然需要這麼大，因為虛擬頁號是 52 位元，每個頁表條目都必須存在。因此，單層頁表在邏輯上仍然需要 $2^{55}$ Bytes 的空間，需要 $2^{55} / 2^{12} = 2^{43}$ 個物理頁框。這並不會因為程式只使用 4MB 而減少。這再次證明單層頁表對於 64 位元系統不可行。

    *   **方案二：多層頁表**
        *   **步驟 1：規劃頁表層級**
            虛擬頁號有 52 位元。每級頁表索引最大為 9 位元。
            所需層數 = $\lceil 52 / 9 \rceil = 6$ 層。
            我們將 52 位元的 VPN 劃分為 6 個索引：
            $52 = 9 + 9 + 9 + 9 + 9 + 7$ (最後一級索引是 7 位元)
            `VA = [ IDX_5 | IDX_4 | IDX_3 | IDX_2 | IDX_1 | IDX_0 | Page Offset ]`
            (7位) (9位) (9位) (9位) (9位) (9位) (12位)
        *   **步驟 2：計算 4MB 虛擬空間所需的頁面數量**
            *   4MB = $4 \times 1024 \times 1024$ 位元組 $= 2^2 \times 2^{10} \times 2^{10}$ 位元組 $= 2^{22}$ 位元組。
            *   頁面大小 4KB = $2^{12}$ 位元組。
            *   4MB 空間所需的虛擬頁面數量 = $2^{22} / 2^{12} = 2^{10} = 1024$ 個頁面。
            *   這些頁面將被載入到物理記憶體中，需要 1024 個物理頁框來存放資料本身。

        *   **步驟 3：計算存放頁表所需的物理頁框數量**
            我們只需要映射開頭的 4MB 虛擬空間。這意味著：
            *   只有 `IDX_0` 的所有 1024 個可能值會被用到。
            *   `IDX_1` 的第一個值會被用到（因為 `IDX_0` 有 $2^{10}$ 個值，超過了 $2^9$ 的範圍）。
            *   `IDX_2`, `IDX_3`, `IDX_4`, `IDX_5` 的第一個值會被用到。

            更準確地說，我們需要：
            1.  一個根頁表（例如 Page Global Directory 或 Level 5 Page Table）。它將指向下一級頁表。因為只使用 4MB 區域，所以只需要一個條目有效。 `1 個物理頁框`
            2.  下一級頁表（Level 4 Page Table）。同樣只需要一個條目有效。 `1 個物理頁框`
            3.  Level 3 Page Table。 `1 個物理頁框`
            4.  Level 2 Page Table。 `1 個物理頁框`
            5.  Level 1 Page Table。 `1 個物理頁框`
            6.  Level 0 Page Table（最低級的頁表）。由於 4MB 區域包含 1024 個頁面，而每個 Level 0 Page Table 可以映射 512 個頁面（即 9 位索引）。因此，映射 1024 個頁面需要 $1024 / 512 = 2$ 個 Level 0 Page Table。 `2 個物理頁框`

            總共存放頁表所需的物理頁框數量 = 1 (Level 5) + 1 (Level 4) + 1 (Level 3) + 1 (Level 2) + 1 (Level 1) + 2 (Level 0) = **7 個物理頁框**。

            *(注意：這 7 個頁框只用於存放頁表結構本身，不包含程式實際的 4MB 資料所佔用的 1024 個頁框。題目是問「存放其頁表」所需的頁框。)

---

## ### 7. 延伸閱讀/參考

*   **Operating Systems: Three Easy Pieces (OS: TEP)**
    *   作者：Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau
    *   章節：Virtual Memory (尤其是 Paging 章節)，提供非常直觀且易懂的解釋。
    *   網址：[https://pages.cs.wisc.edu/~remzi/OSTEP/](https://pages.cs.wisc.edu/~remzi/OSTEP/) (線上免費提供)

*   **Operating System Concepts (恐龍書)**
    *   作者：Abraham Silberschatz, Peter B. Galvin, Greg Gagne
    *   章節：第八章 (Memory-Management Strategies) 和 第九章 (Virtual-Memory Management)。
    *   描述詳細，涵蓋了虛擬記憶體的各種概念、演算法和實作細節。

*   **Modern Operating Systems**
    *   作者：Andrew S. Tanenbaum, Herbert Bos
    *   章節：第三章 (Memory Management)。
    *   以系統架構的視角深入探討了記憶體管理，包含虛擬記憶體的設計理念和實踐。

*   **Computer Organization and Design: The Hardware/Software Interface (大黑書)**
    *   作者：David A. Patterson, John L. Hennessy
    *   章節：與記憶體階層和虛擬記憶體相關的部分。
    *   從硬體角度解釋了虛擬記憶體如何與 CPU 和 MMU 協同工作。