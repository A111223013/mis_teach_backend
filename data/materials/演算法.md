## 演算法

### 核心概念與定義

#### 什麼是演算法？

演算法（Algorithm）是一系列清晰、明確、有限且有效的指令集合，用於解決特定問題或執行特定任務。它像是一份食譜，詳細描述了從輸入（材料）到輸出（菜餚）的每一個步驟。

*   **定義/核心觀念**：
    *   演算法是解決問題的「方法」或「步驟」。
    *   它不依賴於任何特定的程式語言，是一種抽象的邏輯描述。
    *   其目標是將輸入轉化為預期的輸出。

#### 演算法的五個基本特性

一個合格的演算法必須具備以下五個關鍵特性：

1.  **輸入 (Input)**：演算法必須有零個或多個外部輸入。
2.  **輸出 (Output)**：演算法必須產生一個或多個輸出。
3.  **明確性 (Definiteness)**：演算法的每一步都必須清晰、無歧義，且不能有多種解釋。
4.  **有限性 (Finiteness)**：演算法必須在有限的步驟後終止，不能無限循環。
5.  **有效性 (Effectiveness)**：演算法的每一步都必須是可執行的，且能在有限的時間內完成。

#### 為什麼需要演算法？

*   **解決問題**：它是將抽象問題轉化為具體、可執行解決方案的橋樑。
*   **效率最佳化**：不同的演算法可以以不同的效率解決相同的問題，選擇或設計更高效的演算法可以節省計算資源（時間和空間）。
*   **自動化**：演算法是實現自動化處理和決策的基礎。
*   **理解與分析**：透過分析演算法，我們可以更好地理解問題的本質，並評估解決方案的優劣。

#### 演算法的組成要素

一個演算法通常由以下基本結構組成：

1.  **順序結構 (Sequence Structure)**：指令按照線性順序執行。
2.  **選擇結構 (Selection Structure)**：根據條件判斷，執行不同的指令分支（例如：`if-else`）。
3.  **循環結構 (Loop Structure)**：重複執行某段指令，直到滿足特定條件為止（例如：`for`, `while`）。

-----

### 典型例子與推導

我們將透過兩個基礎範例來理解演算法的運作。

#### 範例一：氣泡排序演算法 (Bubble Sort)

*   **定義/核心觀念**：氣泡排序是一種簡單的排序演算法。它重複地走訪過要排序的數列，一次比較兩個元素，如果它們的順序錯誤就把它們交換過來。走訪數列的工作是重複進行的，直到沒有再需要交換，也就是說該數列已經排序完成。

*   **例子與推導**：
    假設我們有一個未排序的數字列表：`[5, 1, 4, 2, 8]`，目標是將其按升序排列。

    **步驟推導：**

    1.  **第一趟 (Pass 1):**
        *   比較 5 和 1：5 > 1，交換 $\rightarrow$ `[1, 5, 4, 2, 8]`
        *   比較 5 和 4：5 > 4，交換 $\rightarrow$ `[1, 4, 5, 2, 8]`
        *   比較 5 和 2：5 > 2，交換 $\rightarrow$ `[1, 4, 2, 5, 8]`
        *   比較 5 和 8：5 < 8，不交換 $\rightarrow$ `[1, 4, 2, 5, 8]`
        *   此時，最大的數字 8 已經「浮」到最右邊。

    2.  **第二趟 (Pass 2):** (這次只需處理前四個元素：`[1, 4, 2, 5]`)
        *   比較 1 和 4：1 < 4，不交換 $\rightarrow$ `[1, 4, 2, 5, 8]`
        *   比較 4 和 2：4 > 2，交換 $\rightarrow$ `[1, 2, 4, 5, 8]`
        *   比較 4 和 5：4 < 5，不交換 $\rightarrow$ `[1, 2, 4, 5, 8]`
        *   此時，次大的數字 5 也已經到位。

    3.  **第三趟 (Pass 3):** (只需處理前三個元素：`[1, 2, 4]`)
        *   比較 1 和 2：1 < 2，不交換 $\rightarrow$ `[1, 2, 4, 5, 8]`
        *   比較 2 和 4：2 < 4，不交換 $\rightarrow$ `[1, 2, 4, 5, 8]`
        *   此時，第三大的數字 4 也已經到位。

    4.  **第四趟 (Pass 4):** (只需處理前兩個元素：`[1, 2]`)
        *   比較 1 和 2：1 < 2，不交換 $\rightarrow$ `[1, 2, 4, 5, 8]`

    至此，數列已完全排序：`[1, 2, 4, 5, 8]`。

*   **與相鄰概念的關聯**：
    *   **排序演算法家族**：氣泡排序是眾多排序演算法（如選擇排序、插入排序、快速排序、合併排序等）中最基本的一種。它直觀易懂，但效率相對較低。
    *   **時間複雜度**：氣泡排序在最壞和平均情況下的時間複雜度為 $O(n^2)$，其中 $n$ 是元素的數量。這意味著隨著元素數量的增加，執行時間將呈平方級增長。

#### 範例二：二分搜尋演算法 (Binary Search)

*   **定義/核心觀念**：二分搜尋是一種高效的搜尋演算法，用於在**已排序**的列表中查找特定元素的位置。它的核心思想是「分而治之」，每次將搜尋區間縮小一半。

*   **例子與推導**：
    假設我們有一個已排序的數字列表：`[1, 4, 7, 10, 13, 16, 19]`，我們要查找數字 `13`。

    **步驟推導：**

    1.  **初始化**：
        *   `low = 0` (列表的起始索引)
        *   `high = 6` (列表的結束索引)
        *   `target = 13`

    2.  **第一次迭代**：
        *   計算中間索引 `mid = (low + high) / 2 = (0 + 6) / 2 = 3`
        *   `list[mid]` 即 `list[3]` 是 `10`。
        *   因為 `10 < 13`，所以目標在中間值的右側。
        *   更新 `low = mid + 1 = 3 + 1 = 4`。
        *   當前搜尋區間為 `[13, 16, 19]` (索引 4 到 6)。

    3.  **第二次迭代**：
        *   `low = 4`, `high = 6`
        *   計算中間索引 `mid = (low + high) / 2 = (4 + 6) / 2 = 5`
        *   `list[mid]` 即 `list[5]` 是 `16`。
        *   因為 `16 > 13`，所以目標在中間值的左側。
        *   更新 `high = mid - 1 = 5 - 1 = 4`。
        *   當前搜尋區間為 `[13]` (索引 4 到 4)。

    4.  **第三次迭代**：
        *   `low = 4`, `high = 4`
        *   計算中間索引 `mid = (low + high) / 2 = (4 + 4) / 2 = 4`
        *   `list[mid]` 即 `list[4]` 是 `13`。
        *   因為 `13 == 13`，找到目標！返回索引 `4`。

*   **與相鄰概念的關聯**：
    *   **線性搜尋**：二分搜尋與線性搜尋（逐一比對）形成對比。線性搜尋不要求列表排序，但效率較低，時間複雜度為 $O(n)$。
    *   **分治法 (Divide and Conquer)**：二分搜尋是分治法思想的經典應用，將大問題分解為更小的子問題來解決。
    *   **時間複雜度**：二分搜尋在最壞和平均情況下的時間複雜度為 $O(\log n)$。這表示隨著元素數量的增加，執行時間以對數級增長，效率非常高。

-----

### 與相鄰概念的關聯

#### 演算法與資料結構

*   **定義/核心觀念**：
    *   **資料結構 (Data Structure)** 是儲存、組織和管理資料的方式。例如：陣列、鏈結串列、樹、圖、雜湊表等。
    *   **演算法** 是處理資料的方法或步驟。
*   **關聯**：
    *   演算法和資料結構是密不可分的。演算法的效率往往取決於資料的組織方式。
    *   **資料結構為演算法提供基礎**：正確的資料結構可以使演算法的實現更簡單、效率更高。例如，二分搜尋必須在排序的陣列或列表上執行；圖演算法需要圖資料結構。
    *   **演算法操作資料結構**：演算法的每一步都可能涉及到對資料結構的操作（新增、刪除、查詢、更新）。
    *   可以說，**資料結構是容器，演算法是操作容器內容的工具**。

#### 演算法與程式設計

*   **定義/核心觀念**：
    *   **程式設計 (Programming)** 是使用特定程式語言將演算法實現為機器可執行的指令集合的過程。
*   **關聯**：
    *   **演算法是程式設計的「靈魂」**：一個好的演算法是高效程式的基礎。在編寫程式碼之前，需要先設計出解決問題的演算法。
    *   **程式設計是演算法的「實作」**：演算法是抽象的步驟，程式設計將這些抽象步驟轉換為具體的、特定語言的程式碼。
    *   學習演算法有助於開發者寫出邏輯清晰、高效且易於維護的程式碼。

#### 演算法與計算複雜度

*   **定義/核心觀念**：
    *   **計算複雜度 (Computational Complexity)** 是衡量演算法執行所需資源（主要是時間和空間）的理論工具。
    *   **時間複雜度 (Time Complexity)**：衡量演算法執行所需的「基本操作」次數，通常以輸入規模 $n$ 的函數表示。
    *   **空間複雜度 (Space Complexity)**：衡量演算法執行所需的「記憶體空間」大小，也以輸入規模 $n$ 的函數表示。

*   **關聯**：
    *   **衡量演算法效率的標準**：計算複雜度提供了一種客觀的方式來比較不同演算法在解決相同問題時的效率。
    *   **預測性能**：透過複雜度分析，我們可以在實際執行前預測演算法在處理大規模數據時的表現。
    *   **選擇最佳演算法**：理解複雜度有助於根據實際需求（例如，時間要求嚴格還是空間要求嚴格）選擇最適合的演算法。

-----

### 進階內容：演算法分析與大 O 符號

#### 大 O 符號 (Big O Notation)

*   **定義/核心觀念**：大 O 符號是一種數學表示法，用於描述演算法在最壞情況下，其執行時間或所需空間與輸入數據量 $n$ 之間的關係（即漸近上界）。它忽略了常數因子和低階項，只關注增長趨勢。

*   **常見的時間複雜度級別**：

    1.  **$O(1)$ - 常數時間 (Constant Time)**：
        *   無論輸入數據量多大，執行時間始終保持不變。
        *   範例：存取陣列中的任意元素、雜湊表的插入/查詢（平均情況）。

    2.  **$O(\log n)$ - 對數時間 (Logarithmic Time)**：
        *   執行時間隨輸入數據量的增加而以對數速度增長。通常發生在每次操作都能將問題規模減半的情況。
        *   範例：二分搜尋。

    3.  **$O(n)$ - 線性時間 (Linear Time)**：
        *   執行時間與輸入數據量成正比。
        *   範例：遍歷陣列、線性搜尋。

    4.  **$O(n \log n)$ - 線性對數時間 (Linearithmic Time)**：
        *   比線性時間慢，但比平方時間快。
        *   範例：高效排序演算法如合併排序、快速排序（平均情況）。

    5.  **$O(n^2)$ - 平方時間 (Quadratic Time)**：
        *   執行時間與輸入數據量的平方成正比。通常發生在嵌套循環中。
        *   範例：氣泡排序、選擇排序、插入排序。

    6.  **$O(2^n)$ - 指數時間 (Exponential Time)**：
        *   執行時間隨輸入數據量呈指數級增長，非常低效。通常用於解決一些需要暴力遍歷所有可能解的問題。
        *   範例：旅行推銷員問題的暴力解法。

*   **推導原則**：
    *   **只保留最高次項**：$O(2n^2 + 3n + 5)$ 簡化為 $O(n^2)$。
    *   **忽略常數係數**：$O(5n^2)$ 簡化為 $O(n^2)$。
    *   **多個獨立部分取最大值**：如果演算法包含兩個獨立部分，一個是 $O(n)$，另一個是 $O(n^2)$，則總體複雜度是 $O(n^2)$。
    *   **嵌套循環相乘**：如果一個循環內部嵌套另一個循環，則複雜度相乘。

-----

### 常見錯誤與澄清

#### 誤區一：演算法只是程式碼

*   **澄清**：演算法是**解決問題的邏輯步驟和方法**，它是抽象的，不依賴於任何特定的程式語言。程式碼是演算法的**具體實現**。你可以用流程圖、偽程式碼或自然語言來描述演算法，然後再用 Python, Java, C++ 等語言來編寫程式碼實現它。

#### 誤區二：演算法一定很快

*   **澄清**：演算法的效率高低差異巨大。一個設計不佳的演算法，即使在最快的電腦上運行，處理大量數據時也可能需要天文數字般的時間。演算法分析（如大 O 符號）正是用來評估其效率，讓我們能夠選擇或設計出「足夠快」的演算法。 $O(n \log n)$ 通常被認為是高效的，而 $O(2^n)$ 則通常是不可接受的。

#### 誤區三：演算法只用於電腦科學

*   **澄清**：演算法的概念遠不止於電腦科學。日常生活中的許多活動都可以看作是演算法，例如烹飪食譜、組裝家具的說明書、甚至是如何繫鞋帶的步驟。它們都包含明確的指令、輸入、輸出和有限的步驟。電腦科學只是將這些步驟自動化執行的一個應用領域。

-----

### 小練習（附詳解）

#### 小練習一：尋找陣列中的最大值

**問題**：設計一個演算法來尋找給定非空整數陣列中的最大值。請描述其步驟，並分析其時間複雜度。

**步驟描述**：

1.  **初始化**：
    *   定義一個變數 `max_value`，並將其初始值設為陣列的第一個元素。
2.  **遍歷**：
    *   從陣列的第二個元素開始，依序遍歷陣列中的每一個元素。
3.  **比較與更新**：
    *   對於當前遍歷到的元素 `current_element`：
        *   如果 `current_element` 大於 `max_value`，則將 `max_value` 更新為 `current_element`。
4.  **回傳結果**：
    *   當所有元素都遍歷完成後，`max_value` 中儲存的就是陣列中的最大值。

**時間複雜度分析**：

1.  初始化步驟是常數時間操作 $O(1)$。
2.  遍歷陣列的步驟會從第二個元素開始，直到最後一個元素，總共進行 $n-1$ 次比較。
3.  每次比較和可能的更新都是常數時間操作 $O(1)$。
4.  因此，總體而言，演算法的執行時間與陣列的長度 $n$ 成正比。

**結論**：此演算法的時間複雜度為 $O(n)$ (線性時間)。

#### 小練習二：氣泡排序的單趟操作

**問題**：給定一個未排序的數字列表 `[7, 2, 8, 1, 5]`，請模擬氣泡排序的第一趟操作，並寫出操作後的列表狀態。

**詳解**：

1.  **初始列表**：`[7, 2, 8, 1, 5]`
2.  **第一次比較**：
    *   比較 `7` 和 `2`。因為 `7 > 2`，交換兩者。
    *   列表變為：`[2, 7, 8, 1, 5]`
3.  **第二次比較**：
    *   比較 `7` 和 `8`。因為 `7 < 8`，不交換。
    *   列表保持：`[2, 7, 8, 1, 5]`
4.  **第三次比較**：
    *   比較 `8` 和 `1`。因為 `8 > 1`，交換兩者。
    *   列表變為：`[2, 7, 1, 8, 5]`
5.  **第四次比較**：
    *   比較 `8` 和 `5`。因為 `8 > 5`，交換兩者。
    *   列表變為：`[2, 7, 1, 5, 8]`

**結果**：氣泡排序第一趟操作後的列表狀態為 `[2, 7, 1, 5, 8]`。最大的元素 `8` 已經被「氣泡」到最右邊（末尾）。

-----

### 延伸閱讀/參考

*   **經典教材**：
    *   《演算法導論》（Introduction to Algorithms），通常被稱為「CLRS」（作者首字母縮寫），是演算法領域的權威教材。內容全面且深入，適合進階學習。
    *   《資料結構與演算法分析》(Data Structures and Algorithm Analysis in C++/Java/Python)，Mark Allen Weiss 著，適合初學者入門，結合程式語言實作。
*   **線上課程與平台**：
    *   LeetCode, HackerRank, Codeforces 等線上程式設計競賽平台，提供大量演算法題目練習。
    *   Coursera, edX 上的演算法課程（例如 Stanford 的演算法課程、MIT 的演算法課程）。
    *   Khan Academy 的演算法基礎課程。
*   **網站與部落格**：
    *   GeeksforGeeks：提供豐富的演算法和資料結構教學文章、程式碼範例。
    *   維基百科：演算法相關條目有清晰的定義和基本介紹。