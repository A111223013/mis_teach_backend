# Chapter 5 樹狀結構

-----

## 1. 核心概念與定義

### 什麼是樹？

樹 (Tree) 是一種抽象資料類型 (Abstract Data Type, ADT)，由節點 (Nodes) 和連接這些節點的邊 (Edges) 組成。它是一種非線性資料結構，用於模擬具有階層關係的數據。

#### 核心觀念
從圖論 (Graph Theory) 的角度來看，樹是一種特殊的圖：
*   **連通的 (Connected)**：任意兩個節點之間都存在一條路徑。
*   **無循環的 (Acyclic)**：不包含任何循環（從某個節點出發，沿著邊可以回到原節點的路徑）。
*   通常有一個特殊的節點被指定為「根」(Root)。

這些特性使得樹非常適合表示階層關係，例如檔案系統、組織架構或數學表達式。

#### 典型例子
*   **檔案系統**：目錄 (資料夾) 包含檔案和子目錄，形成一個樹狀結構。根目錄是樹的根節點。
*   **組織架構**：公司總裁是根節點，下屬部門經理是子節點，依此類推。
*   **網頁的 DOM (Document Object Model)**：HTML 元素構成一個樹狀結構。

#### 與相鄰概念的關聯
*   **圖 (Graph)**：樹是圖的一種子集。所有的樹都是圖，但並非所有的圖都是樹。樹是「無向無環連通圖」或「有向無環圖 (DAG)」的一種特例。

### 樹的基本術語

理解樹的結構，需要掌握一系列專有名詞：

#### 核心觀念
*   **節點 (Node)**：樹的基本組成單位，用來儲存數據。
*   **根節點 (Root Node)**：樹中唯一的、沒有父節點的節點。一棵樹只有一個根節點。
*   **邊 (Edge)**：連接兩個節點的連結，表示它們之間的關係。
*   **父節點 (Parent Node)**：如果節點 A 到節點 B 有一條邊，且 A 在 B 的上一層，則 A 是 B 的父節點。
*   **子節點 (Child Node)**：如果節點 A 是節點 B 的父節點，則 B 是 A 的子節點。
*   **兄弟節點 (Sibling Nodes)**：具有相同父節點的節點。
*   **葉節點 (Leaf Node / Terminal Node)**：沒有任何子節點的節點。
*   **內部節點 (Internal Node / Non-leaf Node)**：至少有一個子節點的節點。
*   **祖先 (Ancestor)**：從根節點到某個節點路徑上的所有節點（不包含該節點本身）。
*   **後代 (Descendant)**：某個節點的子節點、子節點的子節點，依此類推。
*   **子樹 (Subtree)**：以樹中任意節點為根，及其所有後代節點所組成的樹。
*   **度 (Degree)**：
    *   **節點的度 (Degree of a Node)**：該節點擁有的子節點數量（對於有向樹）。
    *   **樹的度 (Degree of a Tree)**：樹中所有節點度的最大值。
*   **深度 (Depth)**：
    *   **節點的深度 (Depth of a Node)**：從根節點到該節點的路徑長度（邊的數量）。根節點的深度定義為 0。
    *   **樹的深度 (Depth of a Tree)**：等同於樹的高度。
*   **高度 (Height)**：
    *   **節點的高度 (Height of a Node)**：從該節點到其最遠葉節點的路徑長度。葉節點的高度定義為 0。
    *   **樹的高度 (Height of a Tree)**：根節點的高度。
*   **層次 (Level)**：從根節點向下，每一層的節點集合。根節點在第 0 層，其子節點在第 1 層，依此類推。

#### 典型例子

考慮以下樹狀結構：
```
       A
      /|\
     B C D
    /|   |
   E F   G
```
*   **根節點**：A
*   **葉節點**：E, F, G, C (C沒有子節點)
*   **內部節點**：A, B, D
*   **父節點**：A 是 B, C, D 的父節點；B 是 E, F 的父節點；D 是 G 的父節點。
*   **子節點**：B, C, D 是 A 的子節點；E, F 是 B 的子節點；G 是 D 的子節點。
*   **兄弟節點**：(B, C, D) 是一組兄弟節點；(E, F) 是一組兄弟節點。
*   **節點 B 的度**：2 (有 E 和 F 兩個子節點)
*   **節點 C 的深度**：1
*   **節點 F 的深度**：2
*   **節點 G 的高度**：0 (葉節點)
*   **節點 B 的高度**：1 (最遠葉節點是 E 或 F，路徑長度為 1)
*   **節點 A (根) 的高度**：2 (最遠葉節點是 E, F, G，路徑長度為 2)
*   **樹的高度**：2

-----

### 樹的分類

樹可以根據其結構和約束條件進行多種分類。

#### 核心觀念

*   **自由樹 (Free Tree) vs. 有根樹 (Rooted Tree)**
    *   **自由樹**：任何節點都可以被視為根，沒有明確指定的根節點，因此沒有階層概念（父子、深度）。它通常指無向連通無環圖。
    *   **有根樹**：有一個明確指定的根節點，所有其他節點都是其後代。這是我們通常討論的「樹」。

*   **有序樹 (Ordered Tree) vs. 無序樹 (Unordered Tree)**
    *   **有序樹**：子節點的順序很重要。例如，如果節點 `A` 有子節點 `B` 和 `C`，則 `(B, C)` 和 `(C, B)` 被視為不同的樹。二元樹就是一種有序樹。
    *   **無序樹**：子節點的順序不重要。

*   **N 元樹 (N-ary Tree)**
    *   每個節點最多有 N 個子節點。二元樹 (Binary Tree) 是 N=2 的特例。

*   **二元樹 (Binary Tree)**：最常見且最重要的樹類型之一。
    *   **定義**：每個節點最多有兩個子節點，分別稱為左子節點 (Left Child) 和右子節點 (Right Child)。左、右子節點的順序是固定的，因此二元樹是有序樹。
    *   **性質**：
        *   在深度為 $d$ 的二元樹中，最多有 $2^d$ 個節點。
        *   高度為 $h$ 的二元樹，最多有 $2^{h+1}-1$ 個節點。
        *   對於有 $N$ 個節點的二元樹，其最小高度為 $\lfloor \log_2 N \rfloor$，最大高度為 $N-1$。

#### 二元樹的特殊類型

*   **滿二元樹 (Full Binary Tree / Proper Binary Tree)**
    *   每個內部節點都恰好有兩個子節點。
    *   或者說，除了葉節點外，所有節點都有兩個子節點。

*   **完全二元樹 (Complete Binary Tree)**
    *   除了最底層外，所有層都是完全填滿的。
    *   最底層的節點都盡可能地靠左排列。
    *   一個深度為 $d$ 的完全二元樹，前 $d-1$ 層是滿的，第 $d$ 層從左到右依次排列。
    *   這種樹可以用陣列有效表示，因為其節點索引具有規律性。

*   **完美二元樹 (Perfect Binary Tree)**
    *   所有內部節點都有兩個子節點，並且所有葉節點都在同一層。
    *   完美二元樹同時也是滿二元樹和完全二元樹。
    *   一個高度為 $h$ 的完美二元樹有 $2^{h+1}-1$ 個節點。

*   **傾斜樹 (Skewed Tree)**
    *   所有節點都只有一個子節點，且都偏向左邊（左傾斜樹）或右邊（右傾斜樹）。
    *   在這種情況下，二元樹退化成了鏈結串列。

#### 典型例子

**二元樹類型示意圖：**

1.  **一般二元樹**
    ```
          A
         / \
        B   C
       /     \
      D       E
    ```

2.  **滿二元樹** (每個內部節點都有兩個子節點)
    ```
          A
         / \
        B   C
       / \
      D   E
    ```
    (C 是葉節點，所以可以沒有子節點。如果 A, B, C 都是內部節點，則 A, B 必須有兩個子節點。此例中 C 是葉節點，符合定義)
    另一種更清晰的滿二元樹例子：
    ```
          A
         / \
        B   C
       / \ / \
      D  E F  G
    ```

3.  **完全二元樹** (從上到下，從左到右填滿)
    ```
          A
         / \
        B   C
       / \ /
      D  E F
    ```
    (F 必須是 C 的左子節點，而不能是 C 的右子節點，因為要靠左填滿)

4.  **完美二元樹** (所有層都填滿，所有葉節點在同一層)
    ```
          A
         / \
        B   C
       / \ / \
      D  E F  G
    ```

5.  **右傾斜樹**
    ```
          A
           \
            B
             \
              C
    ```

#### 與相鄰概念的關聯
*   **堆積 (Heap)**：堆積是一種特殊的完全二元樹，它額外滿足堆積性質（父節點的值總是大於或小於其所有子節點的值）。
*   **二元搜尋樹 (Binary Search Tree, BST)**：一種特殊的二元樹，其中每個節點的值都大於其左子樹中所有節點的值，且小於其右子樹中所有節點的值。這使得搜尋、插入和刪除操作非常高效。

-----

## 2. 典型例子與轉換/推導

### 樹的表示法 (General Tree Representation)

由於一般 N 元樹的子節點數量不固定，有幾種常見的表示方法。

#### 核心觀念

1.  **父節點陣列表示法 (Parent Array Representation)**
    *   使用一個陣列來儲存每個節點的父節點的索引。
    *   根節點的父節點索引通常設為 -1 或其他特殊值。
    *   **優點**：查找父節點效率高。
    *   **缺點**：查找子節點需要遍歷整個陣列。

2.  **子節點列表表示法 (Children List Representation / Adjacency List)**
    *   每個節點都有一個指標指向其子節點列表（例如，一個鏈結串列或動態陣列）。
    *   **優點**：查找子節點高效。
    *   **缺點**：查找父節點不直接。

3.  **左子右兄弟表示法 (Left-Child Right-Sibling Representation)**
    *   這是一種將任意 N 元樹轉換為二元樹的通用方法。
    *   每個節點只儲存兩個指標：
        *   `leftChild`：指向它的第一個（最左邊的）子節點。
        *   `rightSibling`：指向它右邊的兄弟節點。
    *   **優點**：可以用二元樹的遍歷算法來遍歷任意樹。節點結構固定，易於實現。

#### 典型例子 (左子右兄弟表示法)

考慮原始樹結構：
```
       A
      /|\
     B C D
    / \   |
   E   F  G
```
轉換為左子右兄弟表示法後：
*   **A** 的 `leftChild` 指向 **B**，`rightSibling` 為 `NULL` (A沒有兄弟節點)。
*   **B** 的 `leftChild` 指向 **E**，`rightSibling` 指向 **C**。
*   **C** 的 `leftChild` 為 `NULL`，`rightSibling` 指向 **D**。
*   **D** 的 `leftChild` 指向 **G**，`rightSibling` 為 `NULL`。
*   **E** 的 `leftChild` 為 `NULL`，`rightSibling` 指向 **F**。
*   **F** 的 `leftChild` 為 `NULL`，`rightSibling` 為 `NULL`。
*   **G** 的 `leftChild` 為 `NULL`，`rightSibling` 為 `NULL`。

圖示轉換：
```
原始樹：                  轉換後的二元樹：
       A                             A
      /|\                           /
     B C D                         B
    / \ |                         / \
   E   F G                       E   C
                                  \   \
                                   F   D
                                        \
                                         G
```
注意：轉換後的「二元樹」不再保有原始的父子關係，而是將兄弟關係變為右子關係。在遍歷時，這需要特別處理來還原原始樹的結構。`leftChild` 實際上代表原始樹的 `child`，`rightSibling` 代表原始樹的 `next_sibling`。

#### 與相鄰概念的關聯
*   **鏈結串列 (Linked List)**：左子右兄弟表示法中，`rightSibling` 指標串聯起兄弟節點，本質上是一個鏈結串列。

-----

### 二元樹的表示法 (Binary Tree Representation)

二元樹由於其固定的子節點數量，有更簡潔的表示方法。

#### 核心觀念

1.  **鏈結串列表示法 (Linked List Representation)**
    *   每個節點是一個結構 (struct/class)，包含：
        *   數據欄位 (Data)
        *   指向左子節點的指標 ( `left_child` )
        *   指向右子節點的指標 ( `right_child` )
    *   **優點**：易於實現插入和刪除，空間效率高（只為存在的節點分配空間）。
    *   **缺點**：隨機存取效率低，遍歷需要追蹤指標。

    ```c++
    struct Node {
        int data;
        Node* left_child;
        Node* right_child;

        Node(int val) : data(val), left_child(nullptr), right_child(nullptr) {}
    };
    ```

2.  **陣列表示法 (Array Representation)**
    *   主要用於表示**完全二元樹**或**堆積**。
    *   將樹的節點按層次從左到右依次存儲到陣列中。
    *   如果根節點在索引 0 (或 1)，則對於任意節點 $i$：
        *   其左子節點在索引 $2i+1$ (或 $2i$)
        *   其右子節點在索引 $2i+2$ (或 $2i+1$)
        *   其父節點在索引 $\lfloor (i-1)/2 \rfloor$ (或 $\lfloor i/2 \rfloor$)
    *   **優點**：節省空間（不需要額外指標），隨機存取效率高，計算子節點/父節點方便。
    *   **缺點**：
        *   如果樹不是完全二元樹，會浪費大量空間（陣列中會有很多空缺）。
        *   插入和刪除操作可能涉及大量元素移動。

#### 典型例子 (陣列表示法)

考慮一個完全二元樹：
```
        1 (idx 0)
       / \
      2   3 (idx 1, 2)
     / \
    4   5 (idx 3, 4)
```
其陣列表示為：`[1, 2, 3, 4, 5]`

*   節點 `1` (索引 0)：
    *   左子節點 `2`：$2 \times 0 + 1 = 1$
    *   右子節點 `3`：$2 \times 0 + 2 = 2$
*   節點 `2` (索引 1)：
    *   左子節點 `4`：$2 \times 1 + 1 = 3$
    *   右子節點 `5`：$2 \times 1 + 2 = 4$
    *   父節點 `1`：$\lfloor (1-1)/2 \rfloor = 0$

#### 與相鄰概念的關聯
*   **堆積 (Heap)**：堆積利用二元樹的陣列表示法實現其資料結構，因為堆積本身就是完全二元樹。

-----

### 樹的遍歷 (Tree Traversal)

遍歷樹是指以某種系統化的方式訪問樹中的每個節點。對於二元樹，有幾種標準的遍歷方式。

#### 核心觀念
主要分為兩大類：深度優先搜尋 (DFS) 和廣度優先搜尋 (BFS)。

1.  **深度優先搜尋 (Depth-First Search, DFS)**
    *   沿著一條路徑深入到最遠的節點，然後回溯。
    *   對於二元樹，有三種主要的 DFS 方式：

        *   **前序遍歷 (Pre-order Traversal)**：
            *   訪問根節點。
            *   遍歷左子樹。
            *   遍歷右子樹。
            *   用途：複製樹、建立表達式樹的前序表達式（波蘭表示法）。

        *   **中序遍歷 (In-order Traversal)**：
            *   遍歷左子樹。
            *   訪問根節點。
            *   遍歷右子樹。
            *   用途：對於二元搜尋樹，中序遍歷會得到排序的節點序列。

        *   **後序遍歷 (Post-order Traversal)**：
            *   遍歷左子樹。
            *   遍歷右子樹。
            *   訪問根節點。
            *   用途：刪除樹、建立表達式樹的後序表達式（逆波蘭表示法）。

2.  **廣度優先搜尋 (Breadth-First Search, BFS) / 層次遍歷 (Level-order Traversal)**
    *   從根節點開始，逐層訪問所有節點。先訪問所有第 0 層的節點，然後是第 1 層的，依此類推。
    *   通常使用佇列 (Queue) 來實現。
    *   **用途**：查找最短路徑（在非權重圖中），或當你需要逐層處理節點時。

#### 典型例子

考慮以下二元樹：
```
        A
       / \
      B   C
     / \
    D   E
```

*   **前序遍歷 (根-左-右)**：A -> B -> D -> E -> C
    1.  訪問 A
    2.  訪問 B (A 的左子節點)
    3.  訪問 D (B 的左子節點)
    4.  回溯到 B，訪問 E (B 的右子節點)
    5.  回溯到 A，訪問 C (A 的右子節點)

*   **中序遍歷 (左-根-右)**：D -> B -> E -> A -> C
    1.  遍歷 A 的左子樹 (根 B)
        1.  遍歷 B 的左子樹 (根 D)
            1.  遍歷 D 的左子樹 (空)
            2.  訪問 D
            3.  遍歷 D 的右子樹 (空)
        2.  回溯到 B，訪問 B
        3.  遍歷 B 的右子樹 (根 E)
            1.  遍歷 E 的左子樹 (空)
            2.  訪問 E
            3.  遍歷 E 的右子樹 (空)
    2.  回溯到 A，訪問 A
    3.  遍歷 A 的右子樹 (根 C)
        1.  遍歷 C 的左子樹 (空)
        2.  訪問 C
        3.  遍歷 C 的右子樹 (空)

*   **後序遍歷 (左-右-根)**：D -> E -> B -> C -> A
    1.  遍歷 A 的左子樹 (根 B)
        1.  遍歷 B 的左子樹 (根 D)
            1.  遍歷 D 的左子樹 (空)
            2.  遍歷 D 的右子樹 (空)
            3.  訪問 D
        2.  回溯到 B，遍歷 B 的右子樹 (根 E)
            1.  遍歷 E 的左子樹 (空)
            2.  遍歷 E 的右子樹 (空)
            3.  訪問 E
        3.  回溯到 B，訪問 B
    2.  回溯到 A，遍歷 A 的右子樹 (根 C)
        1.  遍歷 C 的左子樹 (空)
        2.  遍歷 C 的右子樹 (空)
        3.  訪問 C
    3.  回溯到 A，訪問 A

*   **層次遍歷 (BFS)**：A -> B -> C -> D -> E
    1.  將 A 放入佇列。
    2.  取出 A，訪問 A。將 A 的子節點 (B, C) 放入佇列。佇列: [B, C]
    3.  取出 B，訪問 B。將 B 的子節點 (D, E) 放入佇列。佇列: [C, D, E]
    4.  取出 C，訪問 C。C 沒有子節點。佇列: [D, E]
    5.  取出 D，訪問 D。D 沒有子節點。佇列: [E]
    6.  取出 E，訪問 E。E 沒有子節點。佇列: []
    7.  佇列為空，遍歷結束。

#### 遞迴實現 (以 C++ 為例)

```cpp
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void preorder(Node* root) {
    if (root == nullptr) return;
    std::cout << root->data << " "; // 訪問根
    preorder(root->left);          // 遍歷左子樹
    preorder(root->right);         // 遍歷右子樹
}

void inorder(Node* root) {
    if (root == nullptr) return;
    inorder(root->left);           // 遍歷左子樹
    std::cout << root->data << " "; // 訪問根
    inorder(root->right);          // 遍歷右子樹
}

void postorder(Node* root) {
    if (root == nullptr) return;
    postorder(root->left);         // 遍歷左子樹
    postorder(root->right);        // 遍歷右子樹
    std::cout << root->data << " "; // 訪問根
}
```

#### 與相鄰概念的關聯
*   **圖的遍歷**：樹的遍歷是圖的遍歷（DFS, BFS）的特殊情況。在樹中，由於沒有循環，遍歷會更加簡單。
*   **堆疊 (Stack)**：深度優先遍歷的遞迴實現本質上就是利用了系統呼叫堆疊。非遞迴的 DFS 則需要顯式使用堆疊。
*   **佇列 (Queue)**：廣度優先遍歷則必須使用佇列來實現。

-----

## 3. 與相鄰概念的關聯

### 樹與圖 (Graphs)

#### 核心觀念
樹是圖的一種特殊且重要的子類型。

*   **圖 (Graph)**：由一組頂點 (Vertices) 和一組連接這些頂點的邊 (Edges) 組成。圖可以是無向的或有向的，可以包含循環。
*   **樹 (Tree)**：
    *   **定義一**：任何無環連通的無向圖。
    *   **定義二**：包含 $N$ 個頂點和 $N-1$ 條邊的連通無向圖。
    *   **定義三**：從一個特定節點（根）出發，到任何其他節點都只有唯一一條路徑的有向無環圖 (DAG)。

#### 關聯性
*   **廣義 vs. 特殊**：圖是更廣泛的概念，樹是圖的「極簡」版本，少了循環，多了唯一路徑的特性。
*   **演算法借用**：許多圖的演算法（如深度優先搜尋 DFS、廣度優先搜尋 BFS）可以直接應用於樹，但由於樹的特殊性質（無環），這些演算法在樹上的實現通常更簡單，無需處理循環。
*   **生成樹 (Spanning Tree)**：給定一個連通圖，它的生成樹是圖的一個子圖，包含了圖中所有的頂點，並且是一個樹。最小生成樹 (MST) 是其中邊權重之和最小的生成樹，常見演算法有 Prim's 和 Kruskal's。

### 樹與鏈結串列 (Linked Lists)

#### 核心觀念
鏈結串列可以看作是樹的一種退化形式。

*   **鏈結串列**：節點只包含數據和一個指向「下一個」節點的指標。它是一種線性結構。
*   **樹**：節點包含數據和多個指向其子節點的指標（例如，二元樹有左右兩個指標）。它是一種非線性結構。

#### 關聯性
*   **結構相似**：樹的鏈結表示法中，每個節點的指標指向其子節點，與鏈結串列中節點指向下一個節點的概念相似。
*   **退化**：如果一棵二元樹中，每個節點都只有一個子節點（例如，只有左子節點或只有右子節點），那麼這棵樹就退化成了一條鏈結串列。這種情況下，樹的高度達到最大值 ($N-1$)，操作效率會降低。

### 樹的應用場景

樹結構因其能夠有效表示階層和組織數據的特性，在計算機科學中有多種應用：

*   **文件系統**：作業系統中的目錄和檔案結構。
*   **語法解析 (Parsing)**：編譯器將程式碼解析成抽象語法樹 (Abstract Syntax Tree, AST)。
*   **數據壓縮**：霍夫曼樹 (Huffman Tree) 用於霍夫曼編碼。
*   **搜尋引擎**：B-樹、B+樹廣泛應用於資料庫索引和檔案系統。
*   **決策樹 (Decision Trees)**：機器學習中用於分類和迴歸。
*   **遊戲 AI**：迷你最大樹 (Minimax Tree) 用於決策過程。
*   **網路路由**：某些路由協議利用樹結構來尋找最佳路徑。

-----

## 4. 進階內容

### 平衡二元樹 (Balanced Binary Trees)

#### 核心觀念
為了解決二元搜尋樹在最壞情況下可能退化成鏈結串列，導致操作效率降低的問題（從 $O(\log N)$ 變為 $O(N)$），引入了平衡二元樹。

*   **目的**：確保樹的高度始終保持在 $O(\log N)$ 的範圍內，從而保證搜尋、插入、刪除操作的最佳時間複雜度。
*   **方法**：在每次插入或刪除操作後，自動調整樹的結構（通常通過旋轉操作）以維持平衡。

#### 典型例子
*   **AVL 樹 (Adelson-Velsky and Landis Tree)**：
    *   最早的自平衡二元搜尋樹。
    *   任何節點的左右子樹高度差的絕對值不超過 1。
    *   平衡因子 (Balance Factor) 定義為 `height(left_subtree) - height(right_subtree)`，其值必須在 {-1, 0, 1} 之間。
*   **紅黑樹 (Red-Black Tree)**：
    *   一種近似平衡的二元搜尋樹，比 AVL 樹的平衡條件更鬆散，但插入刪除操作的旋轉次數通常更少。
    *   廣泛應用於標準函式庫 (如 C++ STL 的 `std::map` 和 `std::set`) 和作業系統核心。

#### 與相鄰概念的關聯
*   **二元搜尋樹 (BST)**：平衡二元樹是二元搜尋樹的改良版，目的是克服其性能瓶頸。

### B-樹與 B+樹 (B-Trees and B+ Trees)

#### 核心觀念
這類樹通常用於外部儲存（磁碟），因為它們被設計成能夠最小化磁碟 I/O 操作。它們是 N 元搜尋樹，而非二元樹。

*   **目的**：由於磁碟 I/O 遠比記憶體存取慢，B-樹和 B+樹的目標是將樹的高度保持在極低，並將相關數據儲存在同一個磁碟區塊中，以減少存取磁碟的次數。
*   **特性**：
    *   所有葉節點都在同一層。
    *   每個節點可以有多個子節點（通常數十到數千個），以適應磁碟區塊的大小。

#### 典型例子
*   **B-樹**：
    *   每個節點（包括內部節點）都儲存鍵值和數據。
    *   內部節點也可以作為數據節點。
*   **B+樹**：
    *   只有葉節點儲存實際數據，內部節點只儲存鍵值用於索引。
    *   所有葉節點形成一個鏈結串列，使得範圍查詢非常高效。
    *   廣泛應用於資料庫索引 (例如 MySQL 的 InnoDB 引擎)。

#### 與相鄰概念的關聯
*   **檔案系統**：某些檔案系統 (如 NTFS, ReiserFS) 內部使用 B-樹或 B+樹來管理文件。
*   **資料庫系統**：是關聯式資料庫系統中索引實現的基石。

-----

## 5. 常見錯誤與澄清

1.  **混淆「滿二元樹」、「完全二元樹」與「完美二元樹」**
    *   **澄清**：
        *   **完美二元樹**是最嚴格的：所有內部節點都有兩個子節點，且所有葉節點都在同一層。它同時是滿二元樹和完全二元樹。
        *   **滿二元樹**：所有內部節點都有兩個子節點，但葉節點不一定在同一層。
        *   **完全二元樹**：除了最底層，所有層都被完全填滿；最底層的節點從左到右依次排列。
    *   **記法**：完美 $\subset$ 完全 $\cap$ 滿。

2.  **認為所有樹的表示法都是鏈結串列形式**
    *   **澄清**：雖然鏈結表示法很常用，但陣列表示法對於完全二元樹（如堆積）來說更高效且節省空間。此外，還有父節點陣列等表示方式，根據應用場景選擇最合適的表示法。

3.  **對「深度」和「高度」的計算混淆**
    *   **澄清**：
        *   **節點深度**：從根節點到該節點的邊數。根節點深度為 0。
        *   **節點高度**：從該節點到其最遠葉節點的邊數。葉節點高度為 0。
        *   **樹的高度**：根節點的高度。
    *   **記法**：從上往下數是深度，從下往上數是高度。

4.  **遞迴遍歷中的堆疊溢位 (Stack Overflow)**
    *   **澄清**：雖然遞迴遍歷代碼簡潔，但在處理深度很大的樹（例如，退化成鏈結串列的二元樹）時，遞迴呼叫的層次會非常深，可能導致系統堆疊溢位。此時應考慮使用迭代方式（顯式堆疊或佇列）實現遍歷。

5.  **誤認為樹一定是二元樹**
    *   **澄清**：二元樹只是樹的一種特殊形式。一般樹 (N 元樹) 的每個節點可以有多於兩個子節點。二元樹由於其簡單性和在特定演算法中的優勢而特別受重視。

-----

## 6. 小練習（附詳解）

### 小練習 1：樹狀結構術語辨識

考慮以下樹狀結構：

```
        A
       /|\
      B C D
     /   / \
    E   F   G
   / \
  H   I
```

請回答以下問題：
1.  根節點是哪一個？
2.  哪些是葉節點？
3.  哪些是內部節點？
4.  節點 B 的子節點有哪些？
5.  節點 D 的父節點是誰？
6.  節點 E 的兄弟節點有哪些？
7.  節點 H 的深度是多少？
8.  節點 B 的高度是多少？
9.  這棵樹的高度是多少？

#### 詳解

1.  **根節點是哪一個？**
    *   **答案**：A
    *   **解析**：A 是唯一沒有父節點的節點。

2.  **哪些是葉節點？**
    *   **答案**：C, H, I, F, G
    *   **解析**：這些節點都沒有子節點。

3.  **哪些是內部節點？**
    *   **答案**：A, B, D, E
    *   **解析**：這些節點至少有一個子節點。

4.  **節點 B 的子節點有哪些？**
    *   **答案**：E
    *   **解析**：只有 E 直接連接在 B 的下方。

5.  **節點 D 的父節點是誰？**
    *   **答案**：A
    *   **解析**：A 直接連接在 D 的上方。

6.  **節點 E 的兄弟節點有哪些？**
    *   **答案**：無
    *   **解析**：E 是 B 的唯一子節點，所以沒有兄弟節點。 (注意：B, C, D 互為兄弟，F, G 互為兄弟)。

7.  **節點 H 的深度是多少？**
    *   **答案**：3
    *   **解析**：從根 A 到 H 的路徑是 A -> B -> E -> H，經過了 3 條邊。 (A 深度 0, B 深度 1, E 深度 2, H 深度 3)

8.  **節點 B 的高度是多少？**
    *   **答案**：2
    *   **解析**：從 B 到其最遠葉節點 H 或 I 的路徑是 B -> E -> H (2 條邊) 或 B -> E -> I (2 條邊)。

9.  **這棵樹的高度是多少？**
    *   **答案**：3
    *   **解析**：樹的高度是根節點 A 的高度。從 A 到最遠葉節點 H 或 I 的路徑是 A -> B -> E -> H/I，長度為 3。

-----

### 小練習 2：二元樹遍歷

給定以下二元樹：

```
       10
      /  \
     5    15
    / \    /
   3   7  12
```

請寫出其：
1.  前序遍歷 (Pre-order Traversal) 結果
2.  中序遍歷 (In-order Traversal) 結果
3.  後序遍歷 (Post-order Traversal) 結果
4.  層次遍歷 (Level-order Traversal) 結果

#### 詳解

1.  **前序遍歷 (根-左-右)**
    *   **步驟**：
        1.  訪問根 `10`。
        2.  遍歷左子樹 (根 `5`)。
            1.  訪問根 `5`。
            2.  遍歷左子樹 (根 `3`)。
                1.  訪問根 `3`。
                2.  遍歷左子樹 (空)。
                3.  遍歷右子樹 (空)。
            3.  遍歷右子樹 (根 `7`)。
                1.  訪問根 `7`。
                2.  遍歷左子樹 (空)。
                3.  遍歷右子樹 (空)。
        3.  遍歷右子樹 (根 `15`)。
            1.  訪問根 `15`。
            2.  遍歷左子樹 (根 `12`)。
                1.  訪問根 `12`。
                2.  遍歷左子樹 (空)。
                3.  遍歷右子樹 (空)。
            3.  遍歷右子樹 (空)。
    *   **結果**：10 -> 5 -> 3 -> 7 -> 15 -> 12

2.  **中序遍歷 (左-根-右)**
    *   **步驟**：
        1.  遍歷左子樹 (根 `5`)。
            1.  遍歷左子樹 (根 `3`)。
                1.  遍歷左子樹 (空)。
                2.  訪問根 `3`。
                3.  遍歷右子樹 (空)。
            2.  訪問根 `5`。
            3.  遍歷右子樹 (根 `7`)。
                1.  遍歷左子樹 (空)。
                2.  訪問根 `7`。
                3.  遍歷右子樹 (空)。
        2.  訪問根 `10`。
        3.  遍歷右子樹 (根 `15`)。
            1.  遍歷左子樹 (根 `12`)。
                1.  遍歷左子樹 (空)。
                2.  訪問根 `12`。
                3.  遍歷右子樹 (空)。
            2.  訪問根 `15`。
            3.  遍歷右子樹 (空)。
    *   **結果**：3 -> 5 -> 7 -> 10 -> 12 -> 15

3.  **後序遍歷 (左-右-根)**
    *   **步驟**：
        1.  遍歷左子樹 (根 `5`)。
            1.  遍歷左子樹 (根 `3`)。
                1.  遍歷左子樹 (空)。
                2.  遍歷右子樹 (空)。
                3.  訪問根 `3`。
            2.  遍歷右子樹 (根 `7`)。
                1.  遍歷左子樹 (空)。
                2.  遍歷右子樹 (空)。
                3.  訪問根 `7`。
            3.  訪問根 `5`。
        2.  遍歷右子樹 (根 `15`)。
            1.  遍歷左子樹 (根 `12`)。
                1.  遍歷左子樹 (空)。
                2.  遍歷右子樹 (空)。
                3.  訪問根 `12`。
            2.  遍歷右子樹 (空)。
            3.  訪問根 `15`。
        3.  訪問根 `10`。
    *   **結果**：3 -> 7 -> 5 -> 12 -> 15 -> 10

4.  **層次遍歷 (Level-order Traversal)**
    *   **步驟**：
        1.  將根 `10` 放入佇列。
        2.  從佇列取出 `10`，訪問。將 `10` 的子節點 `5`, `15` 放入佇列。佇列: [5, 15]
        3.  從佇列取出 `5`，訪問。將 `5` 的子節點 `3`, `7` 放入佇列。佇列: [15, 3, 7]
        4.  從佇列取出 `15`，訪問。將 `15` 的子節點 `12` 放入佇列。佇列: [3, 7, 12]
        5.  從佇列取出 `3`，訪問。`3` 無子節點。佇列: [7, 12]
        6.  從佇列取出 `7`，訪問。`7` 無子節點。佇列: [12]
        7.  從佇列取出 `12`，訪問。`12` 無子節點。佇列: []
        8.  佇列為空，遍歷結束。
    *   **結果**：10 -> 5 -> 15 -> 3 -> 7 -> 12

-----

## 7. 延伸閱讀

*   **資料結構與演算法經典教材**
    *   《資料結構與演算法：Java 語言描述》 (Data Structures and Algorithms in Java by Michael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser)
    *   《資料結構與演算法分析：C 語言描述》 (Data Structures and Algorithm Analysis in C by Mark Allen Weiss)
    *   《演算法導論》 (Introduction to Algorithms by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein)

*   **特定主題深入學習**
    *   **平衡二元搜尋樹**：深入了解 AVL 樹和紅黑樹的旋轉操作和平衡條件。
    *   **B-樹與 B+樹**：研究其在資料庫索引和檔案系統中的實際應用。
    *   **樹的應用**：學習如何用樹解決實際問題，例如霍夫曼編碼、表達式求值、決策樹演算法等。
    *   **圖論**：理解樹作為圖的特殊形式，有助於更廣泛地理解資料結構之間的關係。

*   **線上資源**
    *   [GeeksforGeeks - Tree Data Structure](https://www.geeksforgeeks.org/tree-data-structure/) (英文)
    *   [維基百科 - 樹 (資料結構)](https://zh.wikipedia.org/zh-tw/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)) (中文)