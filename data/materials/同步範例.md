# 同步範例：理解多執行緒/多程序同步機制

本文將深入探討多執行緒與多程序環境中的同步機制，透過具體的範例，協助您理解不同同步工具的應用場景、優缺點及相關概念。

-----

## 核心概念與定義

在多執行緒（或多程序）的並行程式設計中，多個執行單元可能同時存取共享資源。如果沒有適當的協調，這種並行存取可能導致資料不一致或無法預期的行為，這就是所謂的「競態條件」（Race Condition）。同步機制正是為了解決這些問題而生，確保共享資源在任何時刻都被安全地存取。

### 什麼是同步？

#### 定義
同步（Synchronization）是指在並行運算中，協調多個執行緒或程序，使其在執行特定操作時，能夠按照預期的順序或互斥地存取共享資源，以維持資料的正確性與一致性。

#### 為什麼需要同步？
1.  **資料一致性 (Data Consistency)**：防止競態條件導致的資料損壞或不正確的計算結果。
2.  **操作順序 (Operation Ordering)**：確保特定操作在其他相關操作完成之後才執行。
3.  **資源管理 (Resource Management)**：控制對有限資源的存取，防止過度使用或死鎖。

#### 常見問題
*   **競態條件 (Race Condition)**：當多個執行緒或程序嘗試同時讀寫共享資料，且最終結果取決於這些存取操作的特定執行順序時發生。
*   **死鎖 (Deadlock)**：兩個或多個執行緒/程序互相等待對方釋放資源，導致所有相關執行緒/程序都無法繼續執行的狀態。
*   **活鎖 (Livelock)**：兩個或多個執行緒/程序在嘗試避免死鎖時，卻不斷改變狀態並互相響應，導致都無法完成實際工作的狀態。
*   **飢餓 (Starvation)**：某些執行緒/程序由於資源分配策略不公平，或是優先級較低，長時間無法獲取其所需的資源而無法執行。

-----

### 互斥鎖 (Mutex)

#### 定義/核心觀念
互斥鎖（Mutual Exclusion Lock，簡稱 Mutex）是一種最基本的同步原語，用於保護共享資源，確保在任何時刻只有一個執行緒可以存取被保護的程式碼區塊（稱為「臨界區」或「臨摹區」，Critical Section）。

*   **操作**：
    *   `lock()`：嘗試獲取鎖。如果鎖已被其他執行緒持有，則當前執行緒會被阻塞，直到鎖被釋放。
    *   `unlock()`：釋放鎖。如果有多個執行緒在等待該鎖，其中一個將會被喚醒並獲得鎖。

#### 典型例子：保護共享計數器

考慮一個共享的整數計數器，多個執行緒同時對其進行遞增操作。如果不使用互斥鎖，可能會發生競態條件。

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex> // 引入互斥鎖

std::mutex mtx; // 全局互斥鎖
int shared_counter = 0; // 共享計數器

void increment_counter() {
    for (int i = 0; i < 10000; ++i) {
        mtx.lock(); // 進入臨界區前加鎖
        shared_counter++; // 共享資源的存取
        mtx.unlock(); // 離開臨界區後解鎖
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(increment_counter);
    }

    for (std::thread& t : threads) {
        t.join();
    }

    // 預期結果應為 5 * 10000 = 50000
    std::cout << "Final counter value: " << shared_counter << std::endl;
    return 0;
}
```

在這個例子中，`mtx.lock()` 和 `mtx.unlock()` 確保了 `shared_counter++` 這一操作是原子性的（即在多執行緒環境下不可再分割的）。如果沒有互斥鎖，多個執行緒可能會同時讀取 `shared_counter` 的舊值，然後分別遞增並寫回，導致最終計數器值小於預期。

#### 與相鄰概念的關聯
*   **與二元號誌的關聯**：互斥鎖本質上可以看作是一個特殊的二元號誌（只允許0或1的計數器）。當互斥鎖被獲取時，其狀態變為「已鎖定」（或計數為0）；當釋放時，變為「未鎖定」（或計數為1）。
*   **保護臨界區**：互斥鎖的主要用途就是保護臨界區，使其獨占存取。

-----

### 號誌 (Semaphore)

#### 定義/核心觀念
號誌（Semaphore）是一種更通用的同步原語，它維護一個計數器，用於控制對有限資源的存取。號誌可以是計數型號誌（Counting Semaphore）或二元號誌（Binary Semaphore）。

*   **計數型號誌**：管理可用資源的數量。初始化為 `N`，表示有 `N` 個資源可用。
    *   `wait()` (或 `P()`、`acquire()`)：嘗試獲取一個資源。如果計數器大於0，則遞減計數器並繼續執行；否則，阻塞當前執行緒直到計數器大於0。
    *   `signal()` (或 `V()`、`release()`)：釋放一個資源。遞增計數器。如果有執行緒在等待號誌，其中一個會被喚醒。
*   **二元號誌**：計數器只能是0或1，功能與互斥鎖相似。

#### 典型例子：生產者-消費者問題

生產者-消費者問題是一個經典的並行編程問題，描述了一組生產者執行緒生成資料並放入共享緩衝區，以及一組消費者執行緒從緩衝區中取出資料進行處理。需要同步機制來確保：
1.  生產者不能向已滿的緩衝區添加資料。
2.  消費者不能從空的緩衝區中取出資料。
3.  對緩衝區的存取是互斥的。

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <vector>
#include <mutex> // 用於保護緩衝區存取
#include <semaphore.h> // POSIX 號誌

// 假設緩衝區最大容量
const int BUFFER_SIZE = 5;
std::queue<int> buffer;
std::mutex mtx; // 保護緩衝區的互斥鎖

// 號誌：
// empty_slots: 記錄緩衝區中空槽的數量，初始化為 BUFFER_SIZE
// full_slots: 記錄緩衝區中已填充槽的數量，初始化為 0
sem_t empty_slots;
sem_t full_slots;

void producer(int id) {
    for (int i = 0; i < 10; ++i) {
        // 等待一個空槽位
        sem_wait(&empty_slots);

        // 鎖定緩衝區以進行操作
        mtx.lock();
        int item = id * 100 + i;
        buffer.push(item);
        std::cout << "Producer " << id << " produced: " << item << ". Buffer size: " << buffer.size() << std::endl;
        mtx.unlock();

        // 通知有一個新項目已填充
        sem_post(&full_slots);

        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

void consumer(int id) {
    for (int i = 0; i < 10; ++i) {
        // 等待一個已填充的槽位
        sem_wait(&full_slots);

        // 鎖定緩衝區以進行操作
        mtx.lock();
        int item = buffer.front();
        buffer.pop();
        std::cout << "Consumer " << id << " consumed: " << item << ". Buffer size: " << buffer.size() << std::endl;
        mtx.unlock();

        // 通知有一個空槽位可用
        sem_post(&empty_slots);

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    // 初始化號誌
    sem_init(&empty_slots, 0, BUFFER_SIZE); // 0表示執行緒共享，BUFFER_SIZE為初始值
    sem_init(&full_slots, 0, 0);          // 0表示執行緒共享，0為初始值

    std::vector<std::thread> producers;
    std::vector<std::thread> consumers;

    for (int i = 0; i < 2; ++i) { // 2個生產者
        producers.emplace_back(producer, i);
    }
    for (int i = 0; i < 2; ++i) { // 2個消費者
        consumers.emplace_back(consumer, i);
    }

    for (std::thread& t : producers) {
        t.join();
    }
    for (std::thread& t : consumers) {
        t.join();
    }

    // 銷毀號誌
    sem_destroy(&empty_slots);
    sem_destroy(&full_slots);

    std::cout << "Finished production and consumption." << std::endl;
    return 0;
}
```

這個例子使用了兩個號誌來協調生產者和消費者，以及一個互斥鎖來保護緩衝區的互斥存取。
*   `empty_slots` 號誌控制生產者：當緩衝區滿時，生產者被阻塞。
*   `full_slots` 號誌控制消費者：當緩衝區空時，消費者被阻塞。
*   `mtx` 互斥鎖確保只有一個執行緒可以同時修改 `buffer`。

#### 與相鄰概念的關聯
*   **與互斥鎖的關聯**：二元號誌可以實現互斥鎖的功能。但號誌更通用，可以處理多個可用資源的情況，而互斥鎖只能處理單一資源的獨占存取。
*   **與條件變數的關聯**：號誌通常用於控制對資源的數量限制，而條件變數則用於等待特定條件的發生。它們在某些場景下可以互相替代，但通常條件變數與互斥鎖組合使用時更靈活，尤其是在複雜的狀態轉換等待中。

-----

### 條件變數 (Condition Variable)

#### 定義/核心觀念
條件變數（Condition Variable）通常與互斥鎖配合使用，用於在特定條件不滿足時讓執行緒等待，並在條件滿足時通知等待的執行緒繼續執行。它解決了號誌在處理複雜條件等待時可能力不從心的問題。

*   **核心操作**：
    *   `wait(mutex)`：原子性地釋放互斥鎖並使當前執行緒進入等待狀態。當被喚醒時，重新獲取互斥鎖並繼續執行。
    *   `signal()` (或 `notify_one()`)：喚醒一個正在等待的執行緒。
    *   `broadcast()` (或 `notify_all()`)：喚醒所有正在等待的執行緒。

#### 典型例子：使用條件變數的生產者-消費者問題

再次使用生產者-消費者問題，這次我們使用互斥鎖和條件變數來實現。

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <vector>
#include <mutex>
#include <condition_variable> // 引入條件變數

const int BUFFER_SIZE = 5;
std::queue<int> buffer;
std::mutex mtx; // 保護緩衝區的互斥鎖

// 條件變數：
// cond_not_empty: 當緩衝區不為空時，通知消費者
// cond_not_full: 當緩衝區不為滿時，通知生產者
std::condition_variable cond_not_empty;
std::condition_variable cond_not_full;

void producer_cv(int id) {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx); // RAII 風格的鎖

        // 當緩衝區滿時，生產者等待
        cond_not_full.wait(lock, [] { return buffer.size() < BUFFER_SIZE; });

        int item = id * 100 + i;
        buffer.push(item);
        std::cout << "Producer " << id << " produced: " << item << ". Buffer size: " << buffer.size() << std::endl;

        // 通知消費者，緩衝區不再為空
        cond_not_empty.notify_one(); 

        lock.unlock(); // 提前解鎖，提高並行度 (可選，unique_lock會在離開作用域時自動解鎖)
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

void consumer_cv(int id) {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx); // RAII 風格的鎖

        // 當緩衝區空時，消費者等待
        cond_not_empty.wait(lock, [] { return !buffer.empty(); });

        int item = buffer.front();
        buffer.pop();
        std::cout << "Consumer " << id << " consumed: " << item << ". Buffer size: " << buffer.size() << std::endl;

        // 通知生產者，緩衝區不再為滿
        cond_not_full.notify_one();

        lock.unlock(); // 提前解鎖 (可選)
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    std::vector<std::thread> producers;
    std::vector<std::thread> consumers;

    for (int i = 0; i < 2; ++i) { // 2個生產者
        producers.emplace_back(producer_cv, i);
    }
    for (int i = 0; i < 2; ++i) { // 2個消費者
        consumers.emplace_back(consumer_cv, i);
    }

    for (std::thread& t : producers) {
        t.join();
    }
    for (std::thread& t : consumers) {
        t.join();
    }

    std::cout << "Finished production and consumption (with CV)." << std::endl;
    return 0;
}
```

這個例子中：
*   `std::unique_lock<std::mutex>` 確保了在存取共享緩衝區時的互斥性。
*   `cond_not_full.wait(lock, [] { return buffer.size() < BUFFER_SIZE; });` 這行代碼會自動釋放 `lock`，讓執行緒進入等待狀態。當 `cond_not_full` 被喚醒時，它會重新獲取 `lock`，並檢查 lambda 表達式中的條件。如果條件仍不滿足，它會再次等待。
*   `cond_not_empty.notify_one()` 和 `cond_not_full.notify_one()` 用於喚醒一個等待中的執行緒。

#### 與相鄰概念的關聯
*   **與互斥鎖的組合**：條件變數必須與互斥鎖一起使用。互斥鎖保護共享資源的狀態，而條件變數用於等待該狀態的特定變化。
*   **與號誌的比較**：條件變數通常比號誌更適用於複雜的條件等待。號誌主要用於管理資源數量，而條件變數則專注於等待某個「布林條件」變為真。使用條件變數可以更清晰地表達等待邏輯，並且能夠避免某些情況下的死鎖或活鎖問題。

-----

## 進階內容：原子操作與記憶體模型

除了互斥鎖、號誌和條件變數這些重量級的同步原語外，還有輕量級的**原子操作（Atomic Operations）**。原子操作是不可中斷的操作，即便是多個執行緒同時對同一個變數執行原子操作，也能保證資料的正確性。它們通常用於簡單的計數器、旗標等場景，比鎖的開銷更小。

例如，C++11 引入了 `<atomic>` 頭文件，提供了 `std::atomic<T>` 模板，可以對基本類型進行原子操作：

```cpp
#include <atomic>

std::atomic<int> atomic_counter(0);

void increment_atomic_counter() {
    for (int i = 0; i < 10000; ++i) {
        atomic_counter++; // 這是一個原子操作，無需額外加鎖
    }
}
```

**記憶體模型 (Memory Model)** 則定義了在並行程式設計中，一個執行緒對記憶體的寫入何時對另一個執行緒可見的規則。這對於理解和避免更深層次的資料競態和確保正確的程式行為至關重要。例如，`std::memory_order` 用於指定原子操作的記憶體排序，以平衡效能和正確性。

-----

## 常見錯誤與澄清

### 1. 忘記解鎖 (Mutex Deadlock)
**錯誤**：在獲取互斥鎖後，由於程式邏輯錯誤（例如，提前返回、異常拋出）而沒有釋放鎖。
**澄清**：這會導致其他嘗試獲取該鎖的執行緒永遠阻塞，造成死鎖。使用 RAII（Resource Acquisition Is Initialization）風格的鎖（如 C++ 的 `std::lock_guard` 或 `std::unique_lock`）可以有效避免此問題，確保鎖在離開作用域時自動釋放。

### 2. 號誌初始化值不正確
**錯誤**：例如，生產者-消費者問題中 `full_slots` 號誌初始化為非零值，導致消費者在緩衝區為空時也能執行。
**澄清**：號誌的初始值應嚴格根據其所代表的資源數量來設定。`empty_slots` 應初始化為緩衝區容量，`full_slots` 應初始化為0。

### 3. 條件變數的虛假喚醒 (Spurious Wakeups)
**錯誤**：執行緒在被 `notify_one()` 或 `notify_all()` 喚醒後，沒有重新檢查其等待的條件，就直接繼續執行。
**澄清**：條件變數的 `wait` 操作可能會因為操作系統排程或其他原因在沒有被明確通知的情況下「虛假喚醒」。因此，**永遠應該在一個迴圈中檢查條件**，例如 `while (!condition) cond_var.wait(lock);` 或使用 C++11 帶預測條件的 `cond_var.wait(lock, []{return condition;});`。

### 4. 死鎖 (General Deadlock)
**錯誤**：多個執行緒以不同的順序獲取多個鎖，例如：
執行緒 A: 獲取鎖 L1 -> 獲取鎖 L2
執行緒 B: 獲取鎖 L2 -> 獲取鎖 L1
這可能導致 A 持有 L1 等待 L2，B 持有 L2 等待 L1，從而形成死鎖。
**澄清**：死鎖發生的四個必要條件：
1.  **互斥 (Mutual Exclusion)**：資源不能共享。
2.  **佔有並等待 (Hold and Wait)**：已持有至少一個資源並等待其他資源。
3.  **不可搶佔 (No Preemption)**：資源不能被強制從持有者那裡取走。
4.  **循環等待 (Circular Wait)**：存在一個資源鏈，每個執行緒都在等待鏈中下一個執行緒所持有的資源。

**避免死鎖的策略**：
*   **預防**：破壞死鎖的四個條件之一。最常見的是打破「佔有並等待」（一次性請求所有資源）或「循環等待」（定義資源獲取順序）。
*   **避免**：使用銀行家演算法等來動態判斷資源分配是否會導致不安全狀態。
*   **檢測與恢復**：允許死鎖發生，然後檢測並從中恢復（例如，終止某些執行緒）。

-----

## 小練習（附詳解）

### 小練習 1：使用互斥鎖保護共享列表

**情境**：有一個共享的整數列表 `std::vector<int>`。多個執行緒會向這個列表添加元素。請編寫程式碼，使用互斥鎖來確保每次只有一個執行緒可以向列表中添加元素。

**目標**：
1.  創建一個共享的 `std::vector<int>` 和一個 `std::mutex`。
2.  編寫一個函數 `add_to_list`，該函數接收一個整數作為參數，並將其安全地添加到列表中。
3.  創建多個執行緒，每個執行緒調用 `add_to_list` 多次。
4.  最後打印列表內容，驗證其正確性。

```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <mutex> // for std::mutex and std::lock_guard

std::vector<int> shared_list;
std::mutex list_mutex;

void add_to_list(int value) {
    // TODO: 在此處添加鎖機制
    // shared_list.push_back(value);
    // TODO: 在此處釋放鎖機制
}

void producer_task(int id, int num_elements) {
    for (int i = 0; i < num_elements; ++i) {
        add_to_list(id * 100 + i);
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

int main() {
    const int num_threads = 3;
    const int elements_per_thread = 5;
    std::vector<std::thread> threads;

    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back(producer_task, i, elements_per_thread);
    }

    for (std::thread& t : threads) {
        t.join();
    }

    std::cout << "Final list content: ";
    for (int val : shared_list) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
    // 預期總元素數量為 num_threads * elements_per_thread
    std::cout << "Total elements: " << shared_list.size() << std::endl;

    return 0;
}
```

#### 詳解：

1.  **引入頭文件**：`#include <mutex>`。
2.  **保護共享資源**：在 `add_to_list` 函數中，使用 `std::lock_guard<std::mutex>` 來確保對 `shared_list` 的互斥存取。`std::lock_guard` 是一個 RAII 類，它在構造時獲取鎖，在析構時釋放鎖，即使發生異常也能保證鎖的正確釋放。

```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

std::vector<int> shared_list;
std::mutex list_mutex;

void add_to_list(int value) {
    std::lock_guard<std::mutex> lock(list_mutex); // RAII 鎖，自動管理加鎖與解鎖
    shared_list.push_back(value);
}

void producer_task(int id, int num_elements) {
    for (int i = 0; i < num_elements; ++i) {
        add_to_list(id * 100 + i);
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

int main() {
    const int num_threads = 3;
    const int elements_per_thread = 5;
    std::vector<std::thread> threads;

    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back(producer_task, i, elements_per_thread);
    }

    for (std::thread& t : threads) {
        t.join();
    }

    std::cout << "Final list content: ";
    for (int val : shared_list) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
    std::cout << "Total elements: " << shared_list.size() << std::endl; // 應該是 15

    return 0;
}
```

-----

### 小練習 2：簡單的讀寫鎖實現（使用互斥鎖和條件變數）

**情境**：實現一個簡化的讀寫鎖（Reader-Writer Lock）。允許多個讀取者同時存取共享資源，但寫入者必須獨占存取（寫入時沒有任何讀取者或寫入者）。

**目標**：
1.  設計一個類 `ReadWriteLock`，包含 `read_lock()`、`read_unlock()`、`write_lock()`、`write_unlock()` 四個方法。
2.  使用 `std::mutex` 和 `std::condition_variable` 來實現同步邏輯。
3.  維護讀取者數量和是否有寫入者正在寫入的狀態變數。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>

class ReadWriteLock {
private:
    std::mutex mtx;
    std::condition_variable cv_read;  // 讀者等待的條件變數
    std::condition_variable cv_write; // 寫者等待的條件變數
    int readers;                      // 當前活躍的讀者數量
    bool writer_active;               // 是否有寫者正在寫入

public:
    ReadWriteLock() : readers(0), writer_active(false) {}

    void read_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        // 當有寫者正在寫入時，讀者等待
        // TODO: 添加等待邏輯
        readers++;
    }

    void read_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        readers--;
        // 如果沒有讀者了，並且有寫者在等待，通知一個寫者可以開始
        // TODO: 添加通知邏輯
    }

    void write_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        // 當有任何讀者或寫者活躍時，寫者等待
        // TODO: 添加等待邏輯
        writer_active = true;
    }

    void write_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        writer_active = false;
        // 寫者完成後，優先喚醒寫者 (避免讀者飢餓)，如果沒有寫者等待再喚醒讀者
        // TODO: 添加通知邏輯
    }
};

int shared_data = 0; // 共享資源

void reader_task(int id, ReadWriteLock& rw_lock) {
    for (int i = 0; i < 5; ++i) {
        rw_lock.read_lock();
        std::cout << "Reader " << id << " reads: " << shared_data << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // 模擬讀取時間
        rw_lock.read_unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模擬其他操作
    }
}

void writer_task(int id, ReadWriteLock& rw_lock) {
    for (int i = 0; i < 2; ++i) {
        rw_lock.write_lock();
        int new_val = id * 100 + i;
        shared_data = new_val;
        std::cout << "Writer " << id << " writes: " << new_val << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(150)); // 模擬寫入時間
        rw_lock.write_unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // 模擬其他操作
    }
}

int main() {
    ReadWriteLock rw_lock;
    std::vector<std::thread> threads;

    // 啟動讀者執行緒
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(reader_task, i, std::ref(rw_lock));
    }

    // 啟動寫者執行緒
    for (int i = 0; i < 1; ++i) { // 只有一個寫者，簡化問題
        threads.emplace_back(writer_task, i, std::ref(rw_lock));
    }

    for (std::thread& t : threads) {
        t.join();
    }

    std::cout << "Final shared_data: " << shared_data << std::endl;

    return 0;
}
```

#### 詳解：

1.  **狀態變數**：`readers` 追蹤活躍讀者的數量，`writer_active` 標誌是否有寫者正在寫入。
2.  **讀鎖 (`read_lock`/`read_unlock`)**：
    *   `read_lock()`：如果 `writer_active` 為 `true`，讀者必須等待（使用 `cv_read.wait`）。否則，增加 `readers` 計數。
    *   `read_unlock()`：減少 `readers` 計數。如果 `readers` 歸零且 `writer_active` 為 `false`，則可以喚醒等待的寫者 (`cv_write.notify_one()`)。
3.  **寫鎖 (`write_lock`/`write_unlock`)**：
    *   `write_lock()`：如果 `readers > 0` 或 `writer_active` 為 `true`，寫者必須等待（使用 `cv_write.wait`）。否則，設置 `writer_active = true`。
    *   `write_unlock()`：設置 `writer_active = false`。然後喚醒所有等待的讀者 (`cv_read.notify_all()`)，因為現在可以有多個讀者同時讀取了。如果沒有讀者等待，也可以嘗試喚醒一個寫者 (`cv_write.notify_one()`)。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <vector> // for std::vector

class ReadWriteLock {
private:
    std::mutex mtx;
    std::condition_variable cv_read;  // 讀者等待的條件變數
    std::condition_variable cv_write; // 寫者等待的條件變數
    int readers;                      // 當前活躍的讀者數量
    bool writer_active;               // 是否有寫者正在寫入
    int writers_waiting;              // 等待的寫者數量 (用於優化，防止寫者飢餓)

public:
    ReadWriteLock() : readers(0), writer_active(false), writers_waiting(0) {}

    void read_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        // 當有寫者正在寫入，或有寫者在等待 (防止寫者飢餓)，讀者等待
        cv_read.wait(lock, [this] { return !writer_active && writers_waiting == 0; });
        readers++;
    }

    void read_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        readers--;
        // 如果沒有讀者了，並且有寫者在等待，通知一個寫者可以開始
        if (readers == 0 && writers_waiting > 0) {
            cv_write.notify_one();
        }
    }

    void write_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        writers_waiting++; // 增加等待寫者計數
        // 當有任何讀者或寫者活躍時，寫者等待
        cv_write.wait(lock, [this] { return readers == 0 && !writer_active; });
        writers_waiting--; // 獲取鎖後減少等待寫者計數
        writer_active = true;
    }

    void write_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        writer_active = false;
        // 寫者完成後，優先喚醒寫者 (避免寫者飢餓)，如果沒有寫者等待再喚醒讀者
        if (writers_waiting > 0) {
            cv_write.notify_one(); // 喚醒一個等待的寫者
        } else {
            cv_read.notify_all(); // 喚醒所有等待的讀者
        }
    }
};

int shared_data = 0; // 共享資源

void reader_task(int id, ReadWriteLock& rw_lock) {
    for (int i = 0; i < 5; ++i) {
        rw_lock.read_lock();
        std::cout << "Reader " << id << " reads: " << shared_data << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // 模擬讀取時間
        rw_lock.read_unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模擬其他操作
    }
}

void writer_task(int id, ReadWriteLock& rw_lock) {
    for (int i = 0; i < 2; ++i) {
        rw_lock.write_lock();
        int new_val = id * 100 + i;
        shared_data = new_val;
        std::cout << "Writer " << id << " writes: " << new_val << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(150)); // 模擬寫入時間
        rw_lock.write_unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // 模擬其他操作
    }
}

int main() {
    ReadWriteLock rw_lock;
    std::vector<std::thread> threads;

    // 啟動讀者執行緒
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(reader_task, i, std::ref(rw_lock));
    }

    // 啟動寫者執行緒
    for (int i = 0; i < 1; ++i) { // 只有一個寫者，簡化問題
        threads.emplace_back(writer_task, i, std::ref(rw_lock));
    }

    for (std::thread& t : threads) {
        t.join();
    }

    std::cout << "Final shared_data: " << shared_data << std::endl;

    return 0;
}
```

這個簡化版的讀寫鎖實現了一種「寫者優先」的策略，即當有寫者在等待時，後來的讀者也會等待，以防止寫者飢餓。實際的讀寫鎖實現可能更複雜，例如考慮讀者飢餓、寫者飢餓的平衡等。

-----

## 延伸閱讀/參考

*   **操作系統原理**：深入理解行程管理、記憶體管理、檔案系統等，同步是其中一個核心概念。
    *   *Operating System Concepts* by Abraham Silberschatz, Peter B. Galvin, Greg Gagne
*   **並發編程 (Concurrency Programming)**：專注於多執行緒/多程序編程的理論與實踐。
    *   *The Art of Concurrency* by Clay Breshears
    *   *C++ Concurrency in Action* by Anthony Williams (對於 C++ 開發者尤其推薦)
*   **Pthread 程式庫**：在類 Unix 系統上進行多執行緒編程的標準 API。
*   **C++ `<thread>` 與 `<mutex>` 庫**：C++11 及更高版本提供了標準的並發原語。
*   **Java `java.util.concurrent` 包**：提供了豐富的並發工具和數據結構。
*   **Go 語言的 Goroutine 和 Channel**：Go 語言以其獨特的 CSP（Communicating Sequential Processes）模型提供了不同於傳統鎖的並發機制。