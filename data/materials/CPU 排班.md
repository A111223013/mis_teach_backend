# CPU 排班：核心概念與演算法

CPU 排班 (CPU Scheduling) 是作業系統中一項核心功能，它負責決定哪個準備就緒的行程 (Process) 將在 CPU 上執行。排班器的主要目標是最大化 CPU 利用率，同時確保系統的公平性、效率和響應性。

-----

### 1. 核心概念與定義

#### 什麼是 CPU 排班？

CPU 排班是作業系統中用來在多個可執行行程之間分配 CPU 時間的機制。當系統中有多個行程同時處於就緒狀態時，排班器 (Scheduler) 會根據預設的策略從中選取一個行程，並將 CPU 控制權交給它。

*   **核心觀念**：排班器是作業系統的一個模組，其核心職責是根據排班演算法從就緒佇列 (Ready Queue) 中挑選出下一個要執行在 CPU 上的行程。

*   **目的**：
    *   **最大化 CPU 利用率 (CPU Utilization)**：盡可能讓 CPU 保持忙碌。
    *   **最大化吞吐量 (Throughput)**：單位時間內完成的行程數量。
    *   **最小化周轉時間 (Turnaround Time)**：從行程提交到完成的總時間。
    *   **最小化等待時間 (Waiting Time)**：行程在就緒佇列中等待 CPU 的總時間。
    *   **最小化響應時間 (Response Time)**：從行程提交到首次響應 (開始執行) 的時間。

#### 排班決策點

排班決策點指的是作業系統排班器可能被呼叫，並做出行程切換決策的時機。

*   **定義**：當一個行程的狀態發生變更時，排班器可能會介入。
*   **典型例子**：
    1.  **行程從執行中狀態 (Running) 切換到等待狀態 (Waiting)**：例如，行程發出 I/O 請求，或等待子行程終止。此時 CPU 會被釋放。
    2.  **行程從執行中狀態 (Running) 切換到就緒狀態 (Ready)**：通常是因為時間片 (Time Quantum) 用完，或高優先級行程到達（在搶佔式排班中）。
    3.  **行程從等待狀態 (Waiting) 切換到就緒狀態 (Ready)**：例如，I/O 操作完成。
    4.  **行程終止 (Terminates)**：行程完成執行，釋放 CPU 和資源。

#### 排班類型

根據排班器是否可以在行程執行期間中斷它，分為兩種主要類型：

*   **非搶佔式 (Non-preemptive Scheduling)**
    *   **定義**：一旦 CPU 被分配給一個行程，該行程會持續佔用 CPU，直到它完成執行或自願進入等待狀態（例如發出 I/O 請求）。
    *   **核心觀念**：一旦開始，不可中斷。
    *   **與相鄰概念的關聯**：排班決策點只發生在行程終止或從執行中進入等待狀態。
    *   **例子**：先來先服務 (FCFS)，非搶佔式最短工作優先 (Non-preemptive SJF)。

*   **搶佔式 (Preemptive Scheduling)**
    *   **定義**：CPU 可以被強制從一個行程手中奪走，並分配給另一個行程。這通常發生在高優先級行程到達、時間片用完或 I/O 完成後有更高優先級行程就緒時。
    *   **核心觀念**：可隨時中斷當前執行中的行程。
    *   **與相鄰概念的關聯**：排班決策點可以發生在所有四種情況下，尤其是從執行中進入就緒狀態或從等待中進入就緒狀態時。這種排班類型需要處理**上下文切換 (Context Switching)** 的開銷。
    *   **例子**：時間輪轉 (Round Robin, RR)，搶佔式最短剩餘時間優先 (Shortest-Remaining-Time-First, SRTF)，優先級搶佔式排班。

-----

### 2. 典型例子與評估指標

為了評估不同的排班演算法的效能，我們需要一些關鍵指標。

#### 排班演算法的評估指標

*   **周轉時間 (Turnaround Time, $TT$)**
    *   **定義**：從行程提交到完成的總時間。
    *   **推導**：$TT = \text{完成時間} - \text{到達時間}$
    *   **關聯**：它衡量了行程在系統中逗留的總時長。

*   **等待時間 (Waiting Time, $WT$)**
    *   **定義**：行程在就緒佇列中等待 CPU 的總時間。
    *   **推導**：$WT = \text{周轉時間} - \text{執行時間 (Burst Time)}$
    *   **關聯**：它直接反映了排班演算法的公平性和效率，值越小越好。

*   **響應時間 (Response Time, $RT$)**
    *   **定義**：從行程提交到首次響應（即行程第一次獲得 CPU 並開始執行）的時間。
    *   **推導**：$RT = \text{首次響應時間} - \text{到達時間}$
    *   **關聯**：對於互動式系統而言，響應時間是一個非常重要的指標，值越小使用者體驗越好。

*   **CPU 利用率 (CPU Utilization)**
    *   **定義**：CPU 忙碌的時間比例。
    *   **推導**：$\text{CPU 利用率} = \frac{\text{CPU 忙碌時間}}{\text{總時間}}$
    *   **關聯**：通常用百分比表示，目標是最大化這個值。

*   **吞吐量 (Throughput)**
    *   **定義**：單位時間內完成的行程數量。
    *   **推導**：$\text{吞吐量} = \frac{\text{完成的行程總數}}{\text{總時間}}$
    *   **關聯**：衡量系統處理工作量的能力，值越大越好。

#### 簡單範例計算

假設有以下行程，它們在時間 0 到達，且是單核 CPU：

| 行程 (P) | 執行時間 (Burst Time, BT) |
| :------- | :------------------------ |
| P1       | 24                        |
| P2       | 3                         |
| P3       | 3                         |

**使用 FCFS (先來先服務) 排班**：

1.  **甘特圖 (Gantt Chart)**：
    ```
    P1 (0-24) | P2 (24-27) | P3 (27-30)
    0         24           27           30
    ```

2.  **指標計算**：

    *   **P1**：
        *   首次響應時間：0
        *   完成時間：24
        *   周轉時間 ($TT_1$) = $24 - 0 = 24$
        *   等待時間 ($WT_1$) = $24 - 24 = 0$

    *   **P2**：
        *   首次響應時間：24
        *   完成時間：27
        *   周轉時間 ($TT_2$) = $27 - 0 = 27$
        *   等待時間 ($WT_2$) = $27 - 3 = 24$

    *   **P3**：
        *   首次響應時間：27
        *   完成時間：30
        *   周轉時間 ($TT_3$) = $30 - 0 = 30$
        *   等待時間 ($WT_3$) = $30 - 3 = 27$

3.  **平均指標**：
    *   平均周轉時間 = $(24 + 27 + 30) / 3 = 81 / 3 = 27$
    *   平均等待時間 = $(0 + 24 + 27) / 3 = 51 / 3 = 17$
    *   平均響應時間 = $(0 + 24 + 27) / 3 = 51 / 3 = 17$

-----

### 3. 與相鄰概念的關聯

CPU 排班並非孤立存在，它與作業系統中的許多其他核心概念緊密相關。

*   **多工 (Multitasking)**
    *   **關聯**：CPU 排班是實現多工的基石。通過在不同行程之間快速切換 CPU，作業系統能夠創造出多個行程同時運行的假象，從而提高 CPU 利用率和系統響應性。沒有有效的排班，多工就無法實現。
    *   **核心觀念**：CPU 排班器決定了哪些行程在何時獲得 CPU，這是多工系統的「大腦」。

*   **行程管理 (Process Management)**
    *   **關聯**：排班器本身就是行程管理的一個重要組件。行程控制區塊 (PCB) 中包含了行程狀態、優先級、計時器等資訊，這些都是排班器做決策的依據。排班器負責將行程從就緒狀態轉換為執行狀態，並在需要時將執行狀態的行程轉換回就緒或等待狀態。
    *   **核心觀念**：行程管理為排班器提供了所有必要的數據和控制結構。

*   **上下文切換 (Context Switching)**
    *   **關聯**：每次排班器決定從一個行程切換到另一個行程時，都需要執行上下文切換。這包括保存當前行程的狀態（例如 CPU 暫存器、程式計數器等），然後載入下一個行程的狀態。上下文切換會產生額外的開銷，因為 CPU 在此期間不執行任何有用的工作。
    *   **核心觀念**：上下文切換是排班決策的實際執行機制，其開銷是排班演算法設計時需要考慮的重要因素。

*   **I/O 綁定 (I/O-bound) 與 CPU 綁定 (CPU-bound) 行程**
    *   **關聯**：排班演算法的選擇會受到行程性質的影響。
        *   **CPU 綁定行程**：大部分時間用於執行計算，I/O 請求較少。對於這類行程，減少上下文切換可能更有效。
        *   **I/O 綁定行程**：大部分時間用於等待 I/O 操作完成，CPU 執行時間較短。讓這類行程快速響應 I/O 完成並獲得 CPU，可以提高系統的整體吞吐量。
    *   **核心觀念**：一個好的排班策略應該能夠平衡不同類型行程的需求，例如，可以優先處理 I/O 綁定行程，以保持 I/O 裝置的忙碌，並提高系統響應性。

-----

### 4. 進階內容：常見排班演算法

#### 4.1 先來先服務 (First-Come, First-Served, FCFS)

*   **定義**：最簡單的排班演算法。行程按照它們進入就緒佇列的順序獲得 CPU。它是一種非搶佔式演算法。
*   **核心觀念**：先到先得。
*   **優點**：實現簡單，易於理解。
*   **缺點**：
    *   **護航效應 (Convoy Effect)**：一個長行程可能會讓許多短行程等待很長時間，導致平均等待時間和周轉時間很高。
    *   對 CPU 綁定行程和 I/O 綁定行程的處理不公平。
*   **例子**：
    *   假設行程如下：
        | 行程 | 到達時間 | 執行時間 |
        | :--- | :------- | :------- |
        | P1   | 0        | 10       |
        | P2   | 1        | 1        |
        | P3   | 2        | 2        |
    *   **甘特圖**：
        ```
        P1 (0-10) | P2 (10-11) | P3 (11-13)
        0         10           11           13
        ```
    *   **指標**：
        *   P1: 完成=10, $TT=10-0=10, WT=10-10=0$
        *   P2: 完成=11, $TT=11-1=10, WT=10-1=9$
        *   P3: 完成=13, $TT=13-2=11, WT=11-2=9$
        *   平均 $TT = (10+10+11)/3 = 31/3 \approx 10.33$
        *   平均 $WT = (0+9+9)/3 = 18/3 = 6$

#### 4.2 最短工作優先 (Shortest-Job-First, SJF)

*   **定義**：CPU 會分配給執行時間最短的行程。
*   **核心觀念**：優先處理執行時間最短的行程。
*   **優點**：對於給定的一組行程，SJF 演算法能夠產生最小的平均等待時間和平均周轉時間，是**最佳的**。
*   **缺點**：
    *   **難以預測**：在實際應用中，很難準確預測行程的下一個 CPU 執行時間（burst time）。通常需要使用歷史數據進行預測。
    *   **飢餓 (Starvation)**：如果系統中不斷有新的短行程到達，長行程可能永遠無法獲得 CPU。
*   **類型**：
    *   **非搶佔式 (Non-preemptive SJF)**：一旦行程開始執行，除非完成或阻塞，否則不會被中斷。
    *   **搶佔式 (Preemptive SJF) / 最短剩餘時間優先 (Shortest-Remaining-Time-First, SRTF)**：當一個新行程到達時，如果它的執行時間比當前執行行程的剩餘時間短，則會發生搶佔。

*   **例子 (SRTF)**：
    *   假設行程如下：
        | 行程 | 到達時間 | 執行時間 |
        | :--- | :------- | :------- |
        | P1   | 0        | 8        |
        | P2   | 1        | 4        |
        | P3   | 2        | 9        |
        | P4   | 3        | 5        |
    *   **甘特圖**：
        ```
        時間 0: P1 到達 (執行時間 8)。P1 開始執行。
        時間 1: P2 到達 (執行時間 4)。P1 剩餘 7，P2 剩餘 4。P2 搶佔 P1。
        時間 1-5: P2 執行。
        時間 5: P2 完成。P1 剩餘 7，P3 剩餘 9，P4 剩餘 5。選擇剩餘時間最短的 P4。
        時間 5-10: P4 執行。
        時間 10: P4 完成。P1 剩餘 7，P3 剩餘 9。選擇 P1。
        時間 10-17: P1 執行。
        時間 17: P1 完成。P3 剩餘 9。選擇 P3。
        時間 17-26: P3 執行。
        時間 26: P3 完成。

        0-1 (P1) | 1-5 (P2) | 5-10 (P4) | 10-17 (P1) | 17-26 (P3)
        0        1          5           10           17           26
        ```
    *   **指標**：
        *   P1: 首次響應=0, 完成=17, $TT=17-0=17, WT=17-8=9$
        *   P2: 首次響應=1, 完成=5, $TT=5-1=4, WT=4-4=0$
        *   P3: 首次響應=17, 完成=26, $TT=26-2=24, WT=24-9=15$
        *   P4: 首次響應=5, 完成=10, $TT=10-3=7, WT=7-5=2$
        *   平均 $TT = (17+4+24+7)/4 = 52/4 = 13$
        *   平均 $WT = (9+0+15+2)/4 = 26/4 = 6.5$

#### 4.3 優先級排班 (Priority Scheduling)

*   **定義**：每個行程都被賦予一個優先級數字。CPU 分配給具有最高優先級（通常是最小的優先級數字或最大的優先級數字，取決於約定）的行程。
*   **核心觀念**：高優先級行程優先執行。
*   **優點**：可以靈活地滿足不同應用場景的需求，例如，作業系統可以優先處理互動式行程。
*   **缺點**：
    *   **飢餓 (Starvation)**：低優先級行程可能永遠無法執行，如果高優先級行程不斷進入系統。
    *   **優先級定義問題**：如何為行程分配優先級是一個複雜的問題。
*   **解決飢餓**：
    *   **老化 (Aging)**：隨著時間的推移，逐漸增加長時間等待的行程的優先級，以防止飢餓。
*   **類型**：可以是搶佔式，也可以是非搶佔式。在搶佔式版本中，如果新到達的行程的優先級高於當前執行行程，則會發生搶佔。
*   **與相鄰概念的關聯**：作業系統的核心部分，如中斷處理，通常具有最高的優先級。

#### 4.4 時間輪轉 (Round Robin, RR)

*   **定義**：專為分時系統設計。每個行程獲得一小段 CPU 時間，稱為**時間片 (Time Quantum)**。時間片通常為 10 到 100 毫秒。一旦行程執行了它的時間片，它就會被搶佔並放入就緒佇列的末尾。
*   **核心觀念**：時間共享，公平分配。
*   **優點**：
    *   **響應時間好**：所有行程都能在短時間內得到響應，適合互動式系統。
    *   **公平**：每個行程都能輪流獲得 CPU。
*   **缺點**：
    *   **時間片大小的影響**：
        *   **時間片過大**：RR 退化為 FCFS，響應時間變差。
        *   **時間片過小**：上下文切換頻繁，導致過多的開銷，降低 CPU 利用率。
    *   平均周轉時間可能比 SJF 長。
*   **與相鄰概念的關聯**：實現多工的關鍵演算法之一，與上下文切換開銷直接相關。

*   **例子**：
    *   假設行程如下，時間片 $q = 4$：
        | 行程 | 到達時間 | 執行時間 |
        | :--- | :------- | :------- |
        | P1   | 0        | 24       |
        | P2   | 0        | 3        |
        | P3   | 0        | 3        |
    *   **甘特圖**：
        ```
        0-4 (P1) | 4-7 (P2) | 7-10 (P3) | 10-14 (P1) | 14-18 (P1) | 18-22 (P1) | 22-24 (P1)
        0        4          7           10          14           18           22           24
        ```
        *   時間 0：P1, P2, P3 都在就緒佇列 (P1, P2, P3)。P1 執行 4 個單位。P1 剩餘 20。就緒佇列變為 (P2, P3, P1)。
        *   時間 4：P2 執行 3 個單位並完成。就緒佇列變為 (P3, P1)。
        *   時間 7：P3 執行 3 個單位並完成。就緒佇列變為 (P1)。
        *   時間 10：P1 執行 4 個單位。P1 剩餘 16。就緒佇列變為 (P1)。
        *   時間 14：P1 執行 4 個單位。P1 剩餘 12。就緒佇列變為 (P1)。
        *   時間 18：P1 執行 4 個單位。P1 剩餘 8。就緒佇列變為 (P1)。
        *   時間 22：P1 執行 2 個單位並完成。
    *   **指標**：
        *   P1: 首次響應=0, 完成=24, $TT=24-0=24, WT=24-24=0$
        *   P2: 首次響應=4, 完成=7, $TT=7-0=7, WT=7-3=4$
        *   P3: 首次響應=7, 完成=10, $TT=10-0=10, WT=10-3=7$
        *   平均 $TT = (24+7+10)/3 = 41/3 \approx 13.67$
        *   平均 $WT = (0+4+7)/3 = 11/3 \approx 3.67$

#### 4.5 多層級佇列排班 (Multilevel Queue Scheduling)

*   **定義**：將就緒佇列劃分為多個獨立的佇列，每個佇列有自己的排班演算法。通常根據行程的屬性（如系統行程、互動式行程、批次行程）將行程永久分配到不同的佇列。
*   **核心觀念**：依行程類型分層排班。
*   **例子**：
    *   前景 (Foreground) 佇列：用於互動式行程，可能使用 RR 排班。
    *   背景 (Background) 佇列：用於批次行程，可能使用 FCFS 排班。
    *   各佇列之間也可以有優先級，例如前景佇列優先於背景佇列。
*   **優點**：能更好地滿足不同類型行程的需求，減少排班開銷（因為行程只在一個佇列中）。
*   **缺點**：
    *   行程被永久分配到一個佇列，靈活性較差。
    *   低優先級佇列中的行程可能發生飢餓。

#### 4.6 多層級回饋佇列排班 (Multilevel Feedback Queue Scheduling, MLFQ)

*   **定義**：允許行程在不同佇列之間移動。這種演算法試圖將 SJF 的優點（對短行程有利）和 RR 的優點（時間共享）結合起來，同時解決飢餓問題。
*   **核心觀念**：動態調整行程優先級，適應行程行為。
*   **運作原理**：
    1.  行程從最高優先級佇列開始執行（通常使用短時間片的 RR）。
    2.  如果行程用完了整個時間片但未完成，則被降級到下一個較低優先級的佇列（時間片通常更長）。
    3.  如果行程自願放棄 CPU（例如發出 I/O 請求），則它保留在當前佇列中，或者在下次就緒時可能被提升到更高優先級。
    4.  可以引入老化機制，定期提升長時間等待在較低優先級佇列中的行程，以防止飢餓。
*   **優點**：
    *   能很好地響應短行程和 I/O 綁定行程。
    *   對 CPU 綁定行程也相對公平。
    *   解決飢餓問題。
*   **缺點**：非常複雜，需要調整多個參數：佇列數量、每個佇列的排班演算法、行程晉升/降級的條件。

-----

### 5. 常見錯誤與澄清

*   **誤解 1：搶佔式排班總是比非搶佔式好。**
    *   **澄清**：雖然搶佔式排班在響應時間和公平性方面通常表現更好，但它會引入額外的上下文切換開銷。對於某些批次處理系統，非搶佔式排班可能因為較低的開銷而更有效。最佳選擇取決於系統的需求和行程的特性。

*   **誤解 2：SJF 總是可行的。**
    *   **澄清**：SJF (最短工作優先) 在理論上是最佳的，因為它能提供最小的平均等待時間。然而，它需要預知行程的下一個 CPU 執行時間，這在實際中很難做到。作業系統通常使用歷史數據來預測，這會引入不準確性。SRTF（搶佔式 SJF）面臨同樣的預測挑戰。

*   **誤解 3：周轉時間就是等待時間加上執行時間。**
    *   **澄清**：周轉時間 = 完成時間 - 到達時間。等待時間 = 周轉時間 - 執行時間。這兩者不是簡單的加和關係。周轉時間包含了執行時間和所有等待時間（在就緒佇列中的等待，以及可能的 I/O 等待）。等待時間只計算在就緒佇列中等待 CPU 的時間。

*   **誤解 4：時間片越小，RR 演算法效能越好。**
    *   **澄清**：時間片過小會導致頻繁的上下文切換，這會增加系統開銷，使 CPU 在無用的切換工作中花費更多時間，從而降低 CPU 利用率和吞吐量。理想的時間片大小應該足夠大，以減少上下文切換開銷，但又足夠小，以保持良好的響應時間。

-----

### 6. 小練習（附詳解）

假設有以下行程到達，請計算各種排班演算法的平均周轉時間與平均等待時間。

| 行程 | 到達時間 (Arrival Time, AT) | 執行時間 (Burst Time, BT) |
| :--- | :-------------------------- | :------------------------ |
| P1   | 0                           | 5                         |
| P2   | 1                           | 3                         |
| P3   | 2                           | 8                         |
| P4   | 3                           | 6                         |

#### 練習 1：使用 FCFS (先來先服務)

**步驟**：

1.  根據到達時間順序排班。
2.  繪製甘特圖。
3.  計算每個行程的完成時間、周轉時間和等待時間。
4.  計算平均周轉時間和平均等待時間。

**詳解**：

1.  **排班順序**：P1 (AT=0) -> P2 (AT=1) -> P3 (AT=2) -> P4 (AT=3)

2.  **甘特圖**：
    ```
    P1 (0-5) | P2 (5-8) | P3 (8-16) | P4 (16-22)
    0        5          8           16          22
    ```

3.  **計算指標**：

    *   **P1**：
        *   完成時間：5
        *   周轉時間 ($TT_1$) = $5 - 0 = 5$
        *   等待時間 ($WT_1$) = $5 - 5 = 0$
    *   **P2**：
        *   完成時間：8
        *   周轉時間 ($TT_2$) = $8 - 1 = 7$
        *   等待時間 ($WT_2$) = $7 - 3 = 4$
    *   **P3**：
        *   完成時間：16
        *   周轉時間 ($TT_3$) = $16 - 2 = 14$
        *   等待時間 ($WT_3$) = $14 - 8 = 6$
    *   **P4**：
        *   完成時間：22
        *   周轉時間 ($TT_4$) = $22 - 3 = 19$
        *   等待時間 ($WT_4$) = $19 - 6 = 13$

4.  **平均指標**：
    *   平均周轉時間 = $(5 + 7 + 14 + 19) / 4 = 45 / 4 = 11.25$
    *   平均等待時間 = $(0 + 4 + 6 + 13) / 4 = 23 / 4 = 5.75$

#### 練習 2：使用 SRTF (最短剩餘時間優先)，時間片為無限小（即時搶佔）

**步驟**：

1.  追蹤每個時間點上就緒佇列中行程的剩餘執行時間。
2.  每當有新行程到達或當前行程完成時，選擇剩餘時間最短的行程執行。
3.  繪製甘特圖。
4.  計算每個行程的完成時間、周轉時間和等待時間。
5.  計算平均周轉時間和平均等待時間。

**詳解**：

1.  **初始狀態**：
    *   時間 0：P1 (BT=5) 到達。就緒佇列: (P1:5)。P1 開始執行。

2.  **甘特圖與追蹤**：
    *   **時間 0-1**：P1 執行。P1 剩餘 4。
    *   **時間 1**：P2 (BT=3) 到達。就緒佇列: (P1:4, P2:3)。P2 剩餘時間最短，搶佔 P1。
    *   **時間 1-3**：P2 執行。P2 剩餘 1。
    *   **時間 2**：P3 (BT=8) 到達。就緒佇列: (P1:4, P2:2, P3:8)。P2 仍然最短。
    *   **時間 3**：P4 (BT=6) 到達。就緒佇列: (P1:4, P2:1, P3:8, P4:6)。P2 仍然最短。
    *   **時間 3-4**：P2 執行。P2 剩餘 0。**P2 完成**。
    *   **時間 4**：就緒佇列: (P1:4, P3:8, P4:6)。P1 (剩餘 4) 最短，P1 繼續執行。
    *   **時間 4-8**：P1 執行。P1 剩餘 0。**P1 完成**。
    *   **時間 8**：就緒佇列: (P3:8, P4:6)。P4 (剩餘 6) 最短，P4 執行。
    *   **時間 8-14**：P4 執行。P4 剩餘 0。**P4 完成**。
    *   **時間 14**：就緒佇列: (P3:8)。P3 執行。
    *   **時間 14-22**：P3 執行。P3 剩餘 0。**P3 完成**。

    ```
    P1 (0-1) | P2 (1-4) | P1 (4-8) | P4 (8-14) | P3 (14-22)
    0        1          4          8           14           22
    ```

3.  **計算指標**：

    *   **P1**：
        *   首次響應時間：0
        *   完成時間：8
        *   周轉時間 ($TT_1$) = $8 - 0 = 8$
        *   等待時間 ($WT_1$) = $8 - 5 = 3$
    *   **P2**：
        *   首次響應時間：1
        *   完成時間：4
        *   周轉時間 ($TT_2$) = $4 - 1 = 3$
        *   等待時間 ($WT_2$) = $3 - 3 = 0$
    *   **P3**：
        *   首次響應時間：14
        *   完成時間：22
        *   周轉時間 ($TT_3$) = $22 - 2 = 20$
        *   等待時間 ($WT_3$) = $20 - 8 = 12$
    *   **P4**：
        *   首次響應時間：8
        *   完成時間：14
        *   周轉時間 ($TT_4$) = $14 - 3 = 11$
        *   等待時間 ($WT_4$) = $11 - 6 = 5$

4.  **平均指標**：
    *   平均周轉時間 = $(8 + 3 + 20 + 11) / 4 = 42 / 4 = 10.5$
    *   平均等待時間 = $(3 + 0 + 12 + 5) / 4 = 20 / 4 = 5$

-----

### 7. 延伸閱讀/參考

*   **書籍**：
    *   Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts*. Wiley. (作業系統領域的經典教材，詳細介紹了各種排班演算法及其原理。)
    *   Tanenbaum, A. S., & Bos, H. (2015). *Modern Operating Systems*. Pearson. (另一本廣受好評的作業系統教材，提供了深入的排班器實現細節。)
*   **線上資源**：
    *   許多大學的作業系統課程網站會提供免費的講義和投影片，例如 MIT OpenCourseware。
    *   維基百科：CPU 排程 (CPU scheduling)。