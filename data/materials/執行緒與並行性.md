# 執行緒與並行性：理解現代軟體的核心

本章節將深入探討執行緒（Thread）與並行性（Concurrency）這兩個在現代軟體開發中不可或缺的核心概念。理解它們不僅能幫助你編寫更有效率的程式，也能更好地掌握複雜系統的運作機制。

-----

### 什麼是執行緒 (Thread)？

#### 核心概念：程式執行的最小單位

執行緒，常被稱為「輕量級行程 (lightweight process)」，是作業系統排程器能夠排程執行的最小單元。一個標準的行程（Process）可以包含一個或多個執行緒。

*   **行程 (Process)**：
    *   一個獨立的執行環境，擁有自己的記憶體空間、檔案描述符、全域變數等資源。
    *   行程間的通訊（IPC, Inter-Process Communication）通常較為複雜且開銷較大。
    *   行程的建立與銷毀成本較高。
*   **執行緒 (Thread)**：
    *   共享其所屬行程的記憶體空間、檔案描述符等大部分資源。
    *   每個執行緒有自己獨立的程式計數器 (Program Counter)、暫存器 (Registers) 和堆疊 (Stack)。
    *   執行緒間的通訊相對容易，因為它們共享記憶體。
    *   執行緒的建立與銷毀成本比行程低。

這意味著，在一個行程內部，所有執行緒都可以直接存取同一個位址空間中的資料。這種共享資源的特性是執行緒模型的一大優勢，但也帶來了同步的挑戰。

#### 典型例子：網頁瀏覽器與文字編輯器

1.  **網頁瀏覽器**：
    *   當你開啟瀏覽器時，它是一個行程。
    *   當你同時打開多個分頁（Tab），這些分頁可能由不同的執行緒處理。
    *   當一個分頁正在載入圖片或執行 JavaScript 時，另一個分頁仍然可以響應你的操作，這就是多執行緒的體現。一個執行緒負責渲染頁面，另一個負責網路請求，還有一個負責使用者介面互動。
2.  **文字編輯器 (例如 Word)**：
    *   主執行緒負責處理使用者輸入、顯示文字。
    *   後台執行緒可能負責自動儲存、拼寫檢查、語法高亮等。即使拼寫檢查正在進行，你仍然可以流暢地打字，這提高了應用程式的響應性。

#### 與相鄰概念的關聯：行程與多工

執行緒是行程的「子單位」。多工 (Multitasking) 是作業系統同時運行多個任務（行程或執行緒）的能力。現代作業系統透過時間分片（Time-slicing）等技術，讓多個行程或執行緒在單一 CPU 上輪流執行，給人一種它們在「同時」運行的錯覺。多執行緒是實現行程內部多工的一種方式。

-----

### 並行性 (Concurrency) 與平行性 (Parallelism)

#### 核心概念：同時處理與同時執行

這兩個術語經常被混淆，但它們有著本質的區別。

*   **並行性 (Concurrency)**：
    *   **定義**：指的是一個系統能夠「同時處理」多個任務的能力。這裡的「同時處理」不一定是真正的同時發生，更多的是指在某個時間點上，多個任務的進度都在推進，但它們可能以交錯 (interleaving) 的方式在單一處理器上執行。
    *   **核心思想**：任務進度的疊加，即使資源有限，也能保持多個任務同時「活躍」。
    *   **應用場景**：I/O 密集型任務（如網路請求、檔案讀寫），因為任務大部分時間都在等待外部資源，CPU 可以切換去處理其他任務。

*   **平行性 (Parallelism)**：
    *   **定義**：指的是一個系統能夠「同時執行」多個任務的能力。這要求有多個物理執行單元（如多核 CPU、多處理器），使得多個任務可以在同一時刻真正地同時運行。
    *   **核心思想**：任務在多個獨立的執行單元上真實地同時發生。
    *   **應用場景**：CPU 密集型任務（如大型數學計算、圖形渲染），可以將計算任務分解並分配給多個核心同時進行，以縮短總執行時間。

#### 區別與關聯：單核與多核 CPU

| 特性       | 並行性 (Concurrency)                               | 平行性 (Parallelism)                               |
| :--------- | :--------------------------------------------------- | :--------------------------------------------------- |
| **執行方式** | 任務交錯執行（時間分片）                             | 任務真正同時執行                                     |
| **所需資源** | 單核 CPU 即可實現                                    | 多核 CPU 或多處理器                                  |
| **目標**     | 提高響應性、處理多個任務                             | 提高吞吐量、加速計算                                 |
| **類比**     | 一位廚師同時處理多道菜（切菜、炒菜、燉湯交替進行） | 多位廚師同時處理多道菜（每位廚師負責一道菜）         |

**關聯**：平行性是實現並行性的一種方式，但並行性不一定需要平行性。在單核 CPU 上，只能透過並行來模擬多任務；而在多核 CPU 上，既可以實現並行，也可以實現真正的平行。

#### 典型例子：下載檔案與影像處理

1.  **下載多個檔案 (並行性)**：
    *   當你使用下載管理器同時下載 10 個檔案時，即使是單核 CPU，由於下載大部分時間都在等待網路傳輸，CPU 可以切換到處理其他檔案的網路封包、更新下載進度條等任務。這是一種並行處理，因為它們在「進度」上同時推進。
2.  **影像處理 (平行性)**：
    *   對一張高解析度圖片進行濾鏡處理（例如模糊、銳化），如果將圖片分割成多個區塊，並將每個區塊的處理任務分配給多個 CPU 核心同時執行，這就是平行性。多個核心同時對不同的圖片區塊進行運算，大大縮短了整體處理時間。

#### 進階內容：Python 的 GIL (Global Interpreter Lock)

Python 的 GIL (Global Interpreter Lock) 是一個特殊的例子。在 CPython 解釋器中，GIL 確保在任何給定時刻，只有一個執行緒可以執行 Python 字節碼。這意味著，即使在多核 CPU 上，Python 的多執行緒程式在 CPU 密集型任務上也無法實現真正的平行執行，因為 GIL 限制了多個執行緒同時存取 Python 物件。

*   **影響**：對於 CPU 密集型任務，Python 多執行緒的效能提升不明顯，甚至可能因為 GIL 的競爭而下降。
*   **適用場景**：對於 I/O 密集型任務，多執行緒依然有用，因為在等待 I/O 時，GIL 會被釋放，其他執行緒可以執行。
*   **解決方案**：對於需要平行計算的 Python 任務，通常會使用多行程 (Multiprocessing) 模組，或者使用 C/C++ 擴展來繞過 GIL 的限制。

-----

### 執行緒同步 (Synchronization)

#### 核心概念：確保資料一致性與避免競爭條件

由於多個執行緒共享相同的記憶體空間，如果多個執行緒同時讀寫同一份資料，可能會導致資料不一致或產生不可預測的結果，這就是所謂的「競爭條件 (Race Condition)」。執行緒同步的目標就是協調多個執行緒的執行順序，以避免這些問題。

#### 典型例子：銀行帳戶轉帳

想像一個銀行帳戶，初始餘額為 1000 元。現在有兩個執行緒同時執行操作：
*   執行緒 A：存入 200 元。
*   執行緒 B：取出 200 元。

理想結果：1000 + 200 - 200 = 1000 元。

若沒有同步機制，可能發生的競爭條件：

| 步驟 | 執行緒 A (存入 200)       | 執行緒 B (取出 200)       | 帳戶餘額 (共享變數) |
| :--- | :-------------------------- | :-------------------------- | :------------------ |
| 1    | 讀取餘額：1000              |                             | 1000                |
| 2    |                             | 讀取餘額：1000              | 1000                |
| 3    | 計算新餘額：1000 + 200 = 1200 |                             | 1000                |
| 4    |                             | 計算新餘額：1000 - 200 = 800 | 1000                |
| 5    | 寫入新餘額：1200            |                             | **1200**            |
| 6    |                             | 寫入新餘額：800             | **800**             |

最終餘額為 800 元，而非預期的 1000 元，這是一個典型的競爭條件導致的錯誤。

#### 與相鄰概念的關聯：執行緒安全

**執行緒安全 (Thread Safety)**：指的是程式碼在多執行緒環境下，能夠被多個執行緒同時執行而不會產生錯誤或不一致的結果。上述的銀行帳戶例子就是執行緒不安全的。

為實現執行緒安全，需要使用同步機制，常見的同步機制包括：

*   **互斥鎖 (Mutex)**：
    *   **核心觀念**：確保在任何給定時間內，只有一個執行緒可以存取被保護的共享資源。當一個執行緒鎖定互斥鎖時，其他試圖鎖定該互斥鎖的執行緒將會被阻塞，直到鎖被釋放。
    *   **例子**：上述銀行帳戶轉帳，在讀取餘額、計算新餘額、寫入新餘額的整個「臨界區間 (Critical Section)」前後加上互斥鎖。

*   **號誌 (Semaphore)**：
    *   **核心觀念**：一個計數器，用於控制對多個共享資源的存取。初始化時設定一個最大計數，每當一個執行緒獲取資源，計數器減一；釋放資源，計數器加一。當計數器為零時，其他請求資源的執行緒將被阻塞。
    *   **例子**：限制同時下載的檔案數量。若最大計數設為 5，則最多只能有 5 個執行緒同時進行下載，當有執行緒完成下載釋放號誌後，其他等待的執行緒才能繼續。

*   **條件變數 (Condition Variable)**：
    *   **核心觀念**：通常與互斥鎖一起使用，用於執行緒之間的等待和通知。一個執行緒可以等待某個條件成立（透過 `wait()` 操作），同時釋放互斥鎖；另一個執行緒在條件成立後通知等待的執行緒（透過 `signal()` 或 `broadcast()` 操作）。
    *   **例子**：生產者-消費者模型。當緩衝區滿時，生產者等待；當緩衝區空時，消費者等待。生產者生產後通知消費者，消費者消費後通知生產者。

-----

### 進階內容：死結 (Deadlock)

#### 定義：多個執行緒互相等待資源導致永久阻塞

死結是多執行緒程式設計中的一個嚴重問題，當多個執行緒在競爭共享資源時，每個執行緒都持有某個資源並等待其他執行緒持有的資源，從而導致所有執行緒都無法繼續執行。

#### 死結的四個必要條件 (Coffman Conditions)：

1.  **互斥 (Mutual Exclusion)**：資源不能被共享，在任何時刻只能被一個執行緒佔用。
2.  **持有並等待 (Hold and Wait)**：一個執行緒在持有至少一個資源的同時，又去請求獲取其他執行緒持有的資源。
3.  **不可剝奪 (No Preemption)**：資源只能由佔用它的執行緒自願釋放，不能被強制從執行緒手中搶奪。
4.  **循環等待 (Circular Wait)**：存在一個執行緒等待鏈，使得 $T_1$ 等待 $T_2$，$T_2$ 等待 $T_3$，...，$T_n$ 等待 $T_1$。

只要打破其中任何一個條件，就可以預防或避免死結。

#### 例子：兩個執行緒與兩個互斥鎖

想像有兩個互斥鎖 `lockA` 和 `lockB`，以及兩個執行緒 `Thread1` 和 `Thread2`。

```
Thread1:                      Thread2:
  acquire(lockA)                acquire(lockB)
  acquire(lockB)                acquire(lockA)
  release(lockB)                release(lockA)
  release(lockA)                release(lockB)
```

**死結情境**：
1.  `Thread1` 成功獲取 `lockA`。
2.  `Thread2` 成功獲取 `lockB`。
3.  `Thread1` 嘗試獲取 `lockB`，但 `lockB` 已被 `Thread2` 佔用，`Thread1` 進入等待。
4.  `Thread2` 嘗試獲取 `lockA`，但 `lockA` 已被 `Thread1` 佔用，`Thread2` 進入等待。

此時，兩個執行緒都在等待對方釋放資源，形成循環等待，導致死結。

#### 預防與避免：

*   **預防**：
    *   **打破持有並等待**：一次性請求所有需要的資源，或者釋放已持有的資源再去請求新的。
    *   **打破不可剝奪**：允許系統強行剝奪（預先釋放）已分配的資源。
    *   **打破循環等待**：對所有資源進行排序，並強制執行緒按照資源的順序請求。例如，所有執行緒都先獲取 `lockA`，再獲取 `lockB`。
*   **避免**：
    *   **銀行家演算法 (Banker's Algorithm)**：在資源分配前進行安全性檢查，如果分配後可能導致不安全狀態（即可能發生死結），則拒絕該資源請求。

-----

### 常見錯誤與澄清

1.  **混淆並行與平行**
    *   **錯誤**：認為多執行緒程式總是在多核 CPU 上實現「平行」執行。
    *   **澄清**：並行（Concurrency）是處理多個任務的能力，可以是交錯執行（單核）或真正同時執行（多核）。平行（Parallelism）才是真正的同時執行。對於 CPU 密集型任務，多執行緒在單核 CPU 上沒有效能優勢。對於某些語言（如 Python），即使在多核 CPU 上，GIL 也會限制多執行緒的平行性。
2.  **認為多執行緒總是比單執行緒快**
    *   **錯誤**：任何程式改成多執行緒都會跑得更快。
    *   **澄清**：多執行緒會帶來額外的開銷，例如執行緒建立與銷毀、執行緒上下文切換（Context Switching）、同步機制（鎖）的開銷等。如果任務並非 I/O 密集型或可以有效並行/平行化，或者分解任務的開銷大於並行化帶來的收益，多執行緒反而可能使程式變慢。
3.  **忽略執行緒安全問題**
    *   **錯誤**：多個執行緒存取共享變數時沒有考慮同步。
    *   **澄清**：這是導致程式行為不確定、資料損壞的常見原因。任何可能被多個執行緒同時修改的共享變數都必須受到適當的同步機制保護，例如互斥鎖。
4.  **死結的誤用或過度使用鎖**
    *   **錯誤**：在不需要同步的地方也使用鎖，或者鎖的粒度過大/過小。
    *   **澄清**：過度使用鎖會導致效能下降（鎖競爭）。鎖的粒度過大會限制並行性，而粒度過小可能無法完全保護資料。死結是由於鎖的使用不當導致的。設計同步機制時需要仔細權衡。
5.  **對 Python GIL 的誤解**
    *   **錯誤**：因為 Python 有 GIL，所以多執行緒完全無用。
    *   **澄清**：GIL 主要影響 CPU 密集型任務的平行性。對於 I/O 密集型任務（如網路請求、檔案讀寫），當一個執行緒在等待 I/O 時，GIL 會被釋放，允許其他執行緒執行，因此多執行緒仍然能有效提高應用程式的響應性和並行處理能力。

-----

### 小練習 (附詳解)

#### 小練習 1: 判斷並行性與平行性

**情境描述**：
判斷以下兩種情境，是屬於「並行性」還是「平行性」，並解釋原因。

1.  **情境 A**：你在一個**單核 CPU** 的電腦上，同時開啟了網頁瀏覽器、音樂播放器和文字處理軟體。它們似乎都在運行，你可以隨時切換到任何一個應用程式並繼續操作。
2.  **情境 B**：你在一個**四核 CPU** 的電腦上，使用一個影片編輯軟體匯出一段 4K 影片。該軟體將影片分割成多個區塊，並利用所有四個核心同時進行編碼運算。

**解答**：

1.  **情境 A**：
    *   **判斷**：屬於 **並行性 (Concurrency)**。
    *   **解釋**：雖然你感覺這些應用程式在同時運行，但由於是單核 CPU，CPU 在任何一個時刻只能執行一個任務。作業系統會透過「時間分片」技術，在這些應用程式之間快速切換，讓每個應用程式都獲得短暫的執行時間，從而給使用者造成它們同時運行的錯覺。這是一種任務交錯執行的表現，符合並行性的定義。

2.  **情境 B**：
    *   **判斷**：屬於 **平行性 (Parallelism)**。
    *   **解釋**：這台電腦有四個 CPU 核心，影片編輯軟體能夠將影片編碼任務分解並分配給這四個核心「真正地同時」進行運算。每個核心都在同一時間處理影片的不同區塊，從而顯著加快了匯出速度。這符合平行性的定義，即多個任務在多個獨立的執行單元上真實地同時發生。

-----

#### 小練習 2: 識別競爭條件與解決方案

**情境描述**：
假設你正在開發一個簡單的線上商店系統，其中有一個共享的庫存數量變數 `stock_count`。現在有兩個顧客（代表兩個執行緒）同時嘗試購買商品。

以下是一個簡化的 Python 偽碼，展示了兩個執行緒如何嘗試減少庫存：

```python
stock_count = 100 # 全域共享變數

def buy_item():
    if stock_count > 0:
        # 這裡模擬一些處理時間
        # (例如：檢查訂單、網路延遲等)
        current_stock = stock_count
        current_stock -= 1
        stock_count = current_stock
        print(f"成功購買！剩餘庫存: {stock_count}")
    else:
        print("庫存不足，購買失敗！")

# 假設 Thread1 和 Thread2 會同時執行 buy_item()
# Thread1.start()
# Thread2.start()
```

**任務**：

1.  識別上述程式碼中可能存在的競爭條件。
2.  使用互斥鎖 (Mutex) 來解決這個競爭條件，提供修改後的程式碼（偽碼）。

**解答**：

1.  **識別競爭條件**：
    *   **位置**：`if stock_count > 0:` 檢查到 `stock_count = current_stock` 這一整個區塊。
    *   **問題**：考慮以下時序：
        1.  `Thread1` 執行到 `if stock_count > 0:`，假設此時 `stock_count` 為 1。條件為真。
        2.  `Thread1` 繼續執行到 `current_stock = stock_count`，`current_stock` 變為 1。
        3.  此時，作業系統將 CPU 切換給 `Thread2`。
        4.  `Thread2` 執行到 `if stock_count > 0:`，此時 `stock_count` 仍為 1。條件為真。
        5.  `Thread2` 繼續執行到 `current_stock = stock_count`，`current_stock` 變為 1。
        6.  `Thread2` 執行 `current_stock -= 1`，`current_stock` 變為 0。
        7.  `Thread2` 執行 `stock_count = current_stock`，`stock_count` 變為 0。`Thread2` 輸出 "成功購買！剩餘庫存: 0"。
        8.  此時，作業系統將 CPU 切換回 `Thread1`。
        9.  `Thread1` 從步驟 2 之後繼續執行 `current_stock -= 1`，`current_stock` 變為 0。
        10. `Thread1` 執行 `stock_count = current_stock`，`stock_count` 變為 0。`Thread1` 輸出 "成功購買！剩餘庫存: 0"。
    *   **結果**：最終 `stock_count` 變為 0，但實際上執行了兩次購買操作，導致超賣（如果初始庫存為 1，只能賣出一個）。兩個執行緒都認為自己成功購買，但邏輯上是不正確的。

2.  **使用互斥鎖解決**：
    為了確保 `stock_count` 的讀取、修改和寫入是原子性的（不可分割的），我們需要使用互斥鎖來保護這段「臨界區間」。

    ```python
    import threading

    stock_count = 100 # 全域共享變數
    stock_lock = threading.Lock() # 建立一個互斥鎖

    def buy_item():
        global stock_count # 宣告使用全域變數
        stock_lock.acquire() # 嘗試獲取鎖，如果被佔用則等待
        try:
            if stock_count > 0:
                # 這裡模擬一些處理時間
                # current_stock = stock_count # 不再需要這個中間變數，直接操作共享變數
                stock_count -= 1
                print(f"成功購買！剩餘庫存: {stock_count}")
            else:
                print("庫存不足，購買失敗！")
        finally:
            stock_lock.release() # 確保無論如何都會釋放鎖

    # 模擬多執行緒執行
    threads = []
    for _ in range(2): # 建立兩個執行緒
        t = threading.Thread(target=buy_item)
        threads.append(t)
        t.start()

    for t in threads:
        t.join() # 等待所有執行緒完成

    print(f"最終庫存: {stock_count}")
    ```

    *   **解釋**：當 `Thread1` 獲取 `stock_lock` 後，它會進入 `try` 區塊，其他任何試圖獲取 `stock_lock` 的執行緒（例如 `Thread2`）將會被阻塞，直到 `Thread1` 完成其操作並在 `finally` 區塊中釋放鎖。這樣就保證了在任何給定時刻，只有一個執行緒能夠讀取和修改 `stock_count`，從而避免了競爭條件。如果初始 `stock_count` 為 1，最終 `stock_count` 會是 0，並且只有一個 `Thread` 打印 "成功購買！"，另一個會打印 "庫存不足，購買失敗！"。這才是正確的邏輯。

-----

### 延伸閱讀/參考

*   **作業系統概論**：
    *   Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. **Operating System Concepts (作業系統概念)**. 經典的作業系統教材，詳細講解了行程、執行緒、同步、死結等概念。
*   **並行程式設計**：
    *   Maurice Herlihy, Nir Shavit. **The Art of Multiprocessor Programming (多處理器程式設計藝術)**. 深入探討並行資料結構和演算法。
*   **特定語言的並行庫文件**：
    *   **Python `threading` and `multiprocessing` modules**: [https://docs.python.org/zh-tw/3/library/threading.html](https://docs.python.org/zh-tw/3/library/threading.html), [https://docs.python.org/zh-tw/3/library/multiprocessing.html](https://docs.python.org/zh-tw/3/library/multiprocessing.html)
    *   **Java Concurrency (JUC)**: `java.util.concurrent` 套件。
    *   **C++11 `std::thread`**: [https://en.cppreference.com/w/cpp/thread](https://en.cppreference.com/w/cpp/thread)
*   **設計模式**：
    *   Doug Lea. **Concurrent Programming in Java: Design Principles and Patterns**. 雖然專注於 Java，但其設計原則和模式適用於所有並行程式設計。