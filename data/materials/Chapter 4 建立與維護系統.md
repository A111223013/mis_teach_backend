# Chapter 4 建立與維護系統

### 核心概念：系統生命週期概述

**定義/核心觀念**
系統生命週期（System Life Cycle, SLC）是指一個資訊系統從其規劃、建立、部署、運作、維護到最終淘汰的整個過程。它為系統的開發與管理提供了一個結構化的框架，確保每個階段都能被有效管理。系統建立與維護是SLC中兩個最核心且相互關聯的階段，它們共同決定了系統的品質、穩定性與長期價值。

**與相鄰概念的關聯**
系統生命週期是理解所有與系統相關活動的總體框架。在「系統建立」階段，我們將從無到有地創造系統，這牽涉到需求、設計、實作與測試；而在「系統維護」階段，我們則確保系統能持續穩定運作並適應未來的變化。建立階段的決策會直接影響維護階段的複雜度與成本，因此兩者之間存在著強烈的因果關係。

-----

### 4.1 系統建立：從規劃到部署

系統建立階段涵蓋了將一個概念或需求轉化為一個可運作系統的所有活動。

#### 4.1.1 需求分析與規劃

**定義/核心觀念**
這是系統建立的第一步，旨在深入理解使用者、業務流程與相關利害關係人的需求，並將其轉化為清晰、可衡量的系統規格。規劃階段則基於這些需求，制定專案範圍、時間表、資源分配與風險管理策略。

**典型例子與推導**
*   **需求收集方法**：訪談、問卷、觀察、原型法、使用者故事（User Story）。
    *   **使用者故事範例**：「作為一個註冊用戶，我希望能夠重設我的密碼，以便在忘記密碼時可以重新登入。」
*   **可行性研究**：評估技術可行性、經濟可行性、操作可行性與時間可行性。
*   **輸出成果**：系統需求規格書（SRS）、專案計畫書。

**與相鄰概念的關聯**
需求分析的品質直接決定了後續設計與實作的正確性。如果需求定義不明確或有誤，則無論設計得多麼精良，實作得多麼完美，最終產品都無法滿足實際需求，導致大量返工與成本浪費。它為系統設計提供了藍圖。

#### 4.1.2 系統設計

**定義/核心觀念**
系統設計是將需求分析階段定義的「做什麼」轉化為「如何做」的詳細技術藍圖。它涵蓋了系統的整體架構、資料結構、模組劃分、使用者介面、安全機制等方面的規劃。

**典型例子與推導**
*   **系統架構設計**：
    *   例如：三層式架構（表現層、業務邏輯層、資料存取層），微服務架構。
    *   推導：選擇架構需考量可擴展性、可維護性、安全性與效能等因素。
*   **資料庫設計**：
    *   透過實體關係圖（ERD, Entity-Relationship Diagram）描述資料結構與關聯。
    *   將ERD轉化為關聯式資料庫的表格結構。
    *   例如：為電商系統設計產品、訂單、使用者等實體及其之間的關係。
*   **使用者介面（UI）設計**：設計流程圖、線框圖（Wireframe）、原型，確保使用者體驗（UX）。

**與相鄰概念的關聯**
系統設計是連接需求與實作的橋樑。好的設計能夠指導開發人員高效地編寫程式碼，並提升系統的可維護性、可擴展性與穩定性。設計階段的不足可能導致實作困難、系統效能瓶頸或難以維護的「技術債」。

#### 4.1.3 系統實作與測試

**定義/核心觀念**
**實作**是將系統設計圖紙轉化為實際可執行程式碼的過程。這涉及編寫程式、開發資料庫、配置伺服器等。
**測試**是驗證系統是否符合需求規格，並找出潛在缺陷的過程。它貫穿於整個實作階段，旨在確保系統的品質與可靠性。

**典型例子與推導**
*   **實作**：
    *   選定程式語言（如：Python, Java, C#）、開發框架（如：Django, Spring Boot, .NET Core）。
    *   遵循編碼規範（Code Convention）與程式碼審查（Code Review）。
*   **測試**：
    *   **單元測試 (Unit Testing)**：針對最小可測試單元（如：函式、方法）進行測試。
    *   **整合測試 (Integration Testing)**：測試不同模組之間介面的交互作用。
    *   **系統測試 (System Testing)**：測試整個系統是否符合需求規格。
    *   **驗收測試 (Acceptance Testing)**：由使用者進行，確認系統是否滿足業務需求。
    *   推導：自動化測試的導入可以大大提高測試效率和準確性，減少人工錯誤。

**與相鄰概念的關聯**
實作是將設計構想付諸實踐的具體行動。測試則是實作品質的保證，它能及早發現問題，降低後期修復成本。實作與測試的結果直接影響系統部署的順利程度及後續維護的負擔。

#### 4.1.4 系統部署與上線

**定義/核心觀念**
部署是將開發完成並測試通過的系統安裝到生產環境，使其可供最終使用者訪問與操作的過程。上線（Go-Live）是系統正式對外發布，開始提供服務的時刻。

**典型例子與推導**
*   **環境準備**：配置伺服器、網路、資料庫、作業系統及必要的運行時環境。
*   **部署策略**：
    *   **直接切換 (Big Bang Deployment)**：一次性替換舊系統，風險較高。
    *   **分階段部署 (Phased Deployment)**：逐步將新功能或模組上線。
    *   **藍綠部署 (Blue/Green Deployment)**：維護兩個相同的生產環境（Blue和Green），新版本部署在Green上，測試完成後切換流量，失敗可快速回滾。
    *   **金絲雀部署 (Canary Deployment)**：將新版本發布給一小部分用戶，觀察其行為，確認穩定後再逐步擴大範圍。
*   **資料遷移**：將舊系統的歷史資料安全、完整地轉移到新系統中。
*   **使用者訓練**：培訓最終使用者如何操作新系統。

**與相鄰概念的關聯**
部署是系統建立的終點，也是系統維護的起點。部署的順利與否直接影響系統的可用性和使用者滿意度。部署後的系統立即進入維護階段，需要持續監控和支援。

-----

### 4.2 系統維護：持續運作與演進

系統維護是系統生命週期中最長且通常成本最高的部分，旨在確保系統持續穩定、有效率地運作，並能適應新的需求與環境變化。

#### 4.2.1 維護的類型

**核心概念**
系統維護主要分為四種類型，它們各自有不同的目的和觸發時機。

1.  **矯正性維護 (Corrective Maintenance)**
    *   **定義**：修正系統中已發現的錯誤、缺陷或故障，以恢復其正常功能。這些錯誤可能是在設計、實作或部署階段引入，但在實際運行中才顯現出來。
    *   **例子**：修復一個導致資料儲存失敗的程式錯誤、解決一個導致系統當機的記憶體洩漏問題。
2.  **適應性維護 (Adaptive Maintenance)**
    *   **定義**：修改系統以適應外部環境的變化，例如作業系統升級、資料庫版本更新、硬體平台更換、法規變動或與其他系統的介面調整。
    *   **例子**：更新系統程式碼以支援最新的作業系統版本、調整資料庫連接池配置以適應新的資料庫伺服器、修改稅務計算模組以符合新的稅法規定。
3.  **完善性維護 (Perfective Maintenance)**
    *   **定義**：增強或改進系統的功能、效能或可維護性，以滿足使用者或業務部門未來的需求，或提升系統的整體效率。這類維護通常源於使用者回饋或業務優化需求。
    *   **例子**：增加新的報表功能、優化資料庫查詢以提高響應速度、重構程式碼以提高可讀性和模組化程度、改善使用者介面以提升操作體驗。
4.  **預防性維護 (Preventive Maintenance)**
    *   **定義**：主動對系統進行修改和改進，以預防未來可能發生的問題、降低故障風險，或延長系統的壽命。這類維護通常不直接回應已發生的錯誤，而是基於預測和最佳實踐。
    *   **例子**：定期備份資料、檢查系統日誌以監控潛在問題、清理無用資料以釋放儲存空間、升級過時的第三方函式庫版本以修補潛在的安全漏洞、重構有高風險或複雜性的程式碼模組。

**與相鄰概念的關聯**
這四種維護類型共同構成了系統維護的整體策略。雖然它們目的不同，但在實際操作中往往會相互交叉。例如，在進行完善性維護時，可能會同時發現並修復一些小錯誤（矯正性），或者優化某些程式碼以適應未來的環境變化（預防性/適應性）。理解這些類型有助於資源分配、排程和管理維護請求。

#### 4.2.2 維護活動與流程

**核心概念**
為了有效管理系統維護，需要一系列標準化的活動和流程，確保所有變更都能被追蹤、控制和驗證。

**典型例子與推導**
1.  **問題追蹤與報告 (Issue Tracking)**：
    *   使用者或監控系統發現問題時，透過問題追蹤系統（如Jira, Redmine）建立工單（Ticket）。
    *   工單包含問題描述、重現步驟、嚴重程度、影響範圍等。
2.  **變更管理 (Change Management)**：
    *   **流程**：
        1.  **變更請求 (Change Request, CR)**：提出變更需求（無論是修正、增強或適應）。
        2.  **影響評估**：分析變更對系統、使用者、資源的影響。
        3.  **審核與批准**：由變更諮詢委員會 (CAB) 或相關負責人審核並批准變更。
        4.  **規劃與排程**：制定變更實施計畫、時間表。
        5.  **實施**：執行變更。
        6.  **測試與驗證**：確保變更正確無誤且未引入新問題。
        7.  **部署**：將變更發布到生產環境。
        8.  **監控與回顧**：監控變更後系統運作狀況，並評估變更效果。
    *   推導：嚴格的變更管理流程能降低系統故障風險，確保所有變更有據可循且可追溯。
3.  **版本控制 (Version Control)**：
    *   使用Git, SVN等工具管理所有程式碼、配置檔案和文件。
    *   確保所有修改都有歷史紀錄，可以追溯到特定版本，並在必要時回滾。
4.  **系統監控 (System Monitoring)**：
    *   使用監控工具（如Prometheus, Zabbix, Grafana）實時監測系統的效能、資源使用率、錯誤日誌等。
    *   設定警報機制，以便在異常情況發生時及時通知運維人員。
5.  **文件更新 (Documentation Update)**：
    *   任何系統變更，無論是程式碼、架構或配置，都必須同步更新相關文件（設計文件、操作手冊、API文件等），以保持文件與系統現狀的一致性。

**與相鄰概念的關聯**
這些維護活動和流程是保障系統長期穩定運作的基石。它們與建立階段的成果緊密相連，例如，良好的設計文件和編碼規範會大大簡化維護階段的閱讀和修改工作。同時，持續的監控和問題追蹤為矯正性維護提供了依據，而變更管理則確保了適應性、完善性和預防性維護的有序進行。

#### 4.2.3 維護的挑戰與策略

**核心概念**
系統維護面臨諸多挑戰，尤其對於長期運作的遺留系統。有效的策略能幫助組織克服這些困難，降低維護成本。

**典型例子與推導**
*   **常見挑戰**：
    *   **遺留系統 (Legacy Systems)**：程式碼老舊、缺乏文件、使用過時技術、原開發人員離職。
    *   **技術債 (Technical Debt)**：為了快速上線或節省成本而採取的權宜之計，導致程式碼品質差、難以維護或擴展。
    *   **文件不足或過時**：系統運作久遠，文件未隨系統更新，導致維護人員難以理解系統。
    *   **知識流失**：核心開發或維護人員離職，系統知識隨之流失。
    *   **維護成本高昂**：維護工作量大，且往往難以預測。
*   **應對策略**：
    *   **重構 (Refactoring)**：在不改變外部行為的前提下，改善程式碼的內部結構，以提高其可讀性、可維護性和擴展性（預防性維護的一種）。
    *   **逐步淘汰/重寫 (Phased Retirement/Rewrite)**：對於無法維護的遺留系統，規劃逐步將功能遷移到新系統，或徹底重寫。
    *   **加強文件化**：確保所有變更都及時更新文件，甚至可以考慮自動生成文件。
    *   **知識傳承**：透過Code Review、Pair Programming、內部訓練和詳細的文件來傳遞知識。
    *   **自動化**：導入自動化測試、部署和監控，減少人工操作錯誤，提高效率。
    *   **技術債管理**：定期評估並規劃償還技術債，將其納入開發排程。

**與相鄰概念的關聯**
維護的挑戰直接影響系統的總體擁有成本（TCO）。在系統建立階段就應當考量未來的可維護性，例如採用模組化設計、編寫清晰的程式碼、提供充足的文件等，以減少未來的維護挑戰。解決這些挑戰是確保系統長期生命力的關鍵。

-----

### 4.3 建立與維護的整合：DevOps與持續交付

**核心概念**
DevOps 是一種文化、運動或實踐，旨在統一軟體開發 (Dev) 和軟體運營 (Ops)。其核心目標是縮短系統開發生命週期，提供高品質的持續交付。它模糊了傳統上「建立」與「維護」的界限，將兩者視為一個持續的、循環的過程。

**典型例子與推導**
*   **持續整合 (Continuous Integration, CI)**：開發人員頻繁地將程式碼整合到共享儲存庫，每次整合都會觸發自動化建構和測試，及早發現並修正錯誤。
*   **持續交付 (Continuous Delivery, CD)**：在CI的基礎上，確保軟體總是處於可部署狀態，可以隨時快速、安全地部署到生產環境。
*   **持續部署 (Continuous Deployment)**：將持續交付推向極致，任何通過自動化測試的程式碼變更都會自動部署到生產環境，無需人工介入。
*   **CI/CD Pipeline**：自動化的工具鏈，將程式碼從開發者的電腦一直自動化到生產環境。
    *   **範例流程**：
        1.  開發者提交程式碼到版本控制系統 (Git)。
        2.  CI工具 (如Jenkins, GitLab CI, GitHub Actions) 自動偵測並觸發建構。
        3.  執行單元測試、整合測試。
        4.  生成軟體構件 (Artifacts)。
        5.  如果所有測試通過，自動部署到預生產環境。
        6.  執行更全面的系統測試、使用者驗收測試。
        7.  若一切正常，自動或手動觸發部署到生產環境。
        8.  部署後進行自動化監控與回饋。
*   **文化轉變**：鼓勵開發團隊和運維團隊之間的協作、溝通和共享責任。
*   **自動化一切**：從程式碼建構、測試、部署到基礎設施配置（Infrastructure as Code, IaC）都盡可能自動化。

**與相鄰概念的關聯**
DevOps 和 CI/CD 實踐是現代軟體開發與運維的最佳模式，它直接應對了傳統瀑布模型中開發與運維部門壁壘森嚴導致的問題。它將建立階段的快速迭代與維護階段的穩定性、可持續性緊密結合，極大地提高了系統的響應能力和創新速度。通過自動化，許多預防性維護工作在開發階段就被內建進流程，而矯正性維護也能更快地被識別和部署修正。

-----

### 小練習 (附詳解)

#### 小練習 1：系統維護類型判斷

**題目**
某公司有一個線上訂餐系統。請判斷以下情境分別屬於哪種系統維護類型：

1.  用戶報告稱，在點擊「提交訂單」按鈕後，有時會彈出一個錯誤訊息，且訂單未能成功送出。開發團隊在檢查後發現是後端API在特定情況下處理併發請求時出現了競態條件（Race Condition）導致的。
2.  由於新的法規要求，所有線上交易系統必須支援最新的安全加密協議 TLS 1.3。該公司需要更新其系統的網路通訊模組以符合此要求。
3.  營銷部門提出，希望在訂餐介面增加一個「推薦餐點」區塊，根據用戶的歷史訂單紀錄提供個性化推薦。
4.  系統運維團隊發現，每隔幾個月資料庫伺服器的CPU使用率就會在深夜飆高，經分析是某些舊的日誌檔未被自動清理導致儲存空間不足，進而影響了資料庫效能。他們決定實作一個定期清理日誌的排程任務。

**詳解**

1.  **矯正性維護 (Corrective Maintenance)**
    *   **理由**：系統功能未能正常運作（訂單提交失敗），這是由於程式碼中的缺陷（競態條件）導致的錯誤。維護目標是修正這個已發現的錯誤。
2.  **適應性維護 (Adaptive Maintenance)**
    *   **理由**：系統需要修改以適應外部環境的變化（新的法規要求支持 TLS 1.3）。這並非系統自身的錯誤，而是為了符合外部規範。
3.  **完善性維護 (Perfective Maintenance)**
    *   **理由**：這是為了增加新的功能（推薦餐點區塊）以提升用戶體驗和業務價值。它使系統更加完善，滿足了新的業務需求。
4.  **預防性維護 (Preventive Maintenance)**
    *   **理由**：雖然目前還未導致嚴重故障，但系統運維團隊預見到潛在的問題（日誌檔過多影響效能），並主動實作措施（定期清理排程）來避免未來可能發生的性能下降或故障。

-----

#### 小練習 2：簡單的系統建立流程概述

**題目**
假設您被要求為一個小型內部部門設計一個「會議室預訂系統」。請您從需求分析到部署，簡述整個系統建立的主要階段和每個階段的核心活動（簡要說明即可），並指出在部署後最優先的維護活動是什麼。

**詳解**

1.  **需求分析與規劃**
    *   **核心活動**：
        *   與部門使用者訪談，了解他們預訂會議室的現有流程、遇到的痛點（例如：重複預訂、資訊不透明）。
        *   定義系統功能：使用者可以查看空閒會議室、預訂會議室、取消預訂、查看自己的預訂記錄。管理員可以管理會議室資訊。
        *   確定專案範圍、預計時間表與資源。
    *   **輸出**：簡要的需求列表。

2.  **系統設計**
    *   **核心活動**：
        *   **架構設計**：考慮採用簡單的網頁應用架構（前端+後端API+資料庫）。
        *   **資料庫設計**：設計會議室表、預訂記錄表、使用者表，明確各表欄位和關聯。
        *   **介面設計**：繪製網頁介面草圖（如：會議室日曆視圖、預訂表單）。
    *   **輸出**：簡單的資料庫結構圖、介面草圖。

3.  **系統實作與測試**
    *   **核心活動**：
        *   **實作**：使用選定的技術棧（例如：Python/Flask + SQLite）開發前後端程式碼，建立資料庫。
        *   **測試**：
            *   單元測試：測試每個預訂函式、取消函式是否正確。
            *   整合測試：測試前端提交預訂請求後，後端是否正確處理並更新資料庫。
            *   系統測試：模擬用戶從登入到預訂、取消的整個流程。
    *   **輸出**：可運行的系統原型。

4.  **系統部署與上線**
    *   **核心活動**：
        *   **環境準備**：在內部伺服器或雲端主機上安裝作業系統、資料庫和應用運行環境。
        *   **應用部署**：將開發好的程式碼部署到伺服器上。
        *   **資料初始化**：初始化會議室列表、管理員帳號等基礎資料。
        *   **使用者訓練**：向部門用戶簡要介紹系統如何使用。
    *   **輸出**：系統正式上線，部門用戶開始使用。

5.  **部署後最優先的維護活動**
    *   最優先的維護活動是**系統監控與矯正性維護**。
    *   **理由**：系統剛上線時，雖然經過測試，但實際使用環境複雜，用戶操作多樣，很可能會暴露出一些在測試中未能發現的錯誤（Bug）。因此，需要密切監控系統的穩定性、效能和錯誤日誌，並快速響應和修復用戶報告的問題，確保系統能正常運作。

-----

### 常見錯誤與澄清

1.  **誤區：系統維護只是修復Bug。**
    *   **澄清**：這是一個常見的誤解。修復Bug屬於**矯正性維護**，只是系統維護的四種類型之一。實際上，**適應性維護**（適應環境變化）、**完善性維護**（新增功能、提升效能）和**預防性維護**（主動優化、避免未來問題）在系統的生命週期中佔據了更多時間和資源，且對於系統的長期價值更為重要。

2.  **誤區：系統建立完成後，專案就結束了。**
    *   **澄清**：系統建立完成並部署上線後，專案進入了**運作與維護階段**。這通常是系統生命週期中最長的部分。如果建立階段被比作蓋房子，那麼維護階段就是持續的居住、裝修、適應環境和修繕。一個系統若沒有良好的維護，其價值會迅速遞減，甚至無法使用。

3.  **誤區：維護階段才需要考慮系統的可維護性。**
    *   **澄清**：系統的可維護性（Maintainability）應從**需求分析和設計階段**就開始考慮。在設計階段採用模組化、低耦合、高內聚的設計原則，在實作階段遵循編碼規範、編寫清晰的程式碼和充分的註解，並在各階段產生完善的文件，都能極大地降低未來維護的複雜度和成本。早期投入精力提升可維護性，將在系統的長期運作中獲得巨大的回報。

-----

### 延伸閱讀/參考

*   **書籍**
    *   《軟體工程：實務的建構方法》 (Software Engineering: A Practitioner's Approach) - Roger S. Pressman, Bruce R. Maxim：經典的軟體工程教材，涵蓋系統生命週期的各個階段。
    *   《人月神話》(The Mythical Man-Month) - Frederick Brooks：關於軟體專案管理的經典著作，儘管年代久遠，但許多見解至今仍具啟發性，尤其對於理解專案的複雜性和挑戰。
    *   《SRE：Google 運維解密》(Site Reliability Engineering: How Google Runs Production Systems) - Betsy Beyer et al.：深入探討Google如何通過SRE實踐來建立和維護大規模、高可靠性的系統，對DevOps有很好的啟發。
*   **文章/文檔**
    *   **敏捷宣言 (Agile Manifesto)**：理解現代軟體開發中迭代、協作和響應變化的核心原則。
        *   [https://agilemanifesto.org/](https://agilemanifesto.org/)
    *   **維基百科：軟體維護 (Software Maintenance)**：提供軟體維護的廣泛概述和不同類型解釋。
        *   [https://zh.wikipedia.org/wiki/軟體維護](https://zh.wikipedia.org/wiki/軟體維護)
    *   **What is DevOps?** (Red Hat 或其他雲廠商提供的DevOps介紹)：深入理解DevOps的原則和實踐。
        *   [https://www.redhat.com/en/topics/devops/what-is-devops](https://www.redhat.com/en/topics/devops/what-is-devops)