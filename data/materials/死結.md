# 死結

死結（Deadlock）是作業系統與並行程式設計中一個關鍵且複雜的議題。當多個程序（或執行緒）競爭共享資源時，如果彼此互相等待對方釋放資源，導致所有程序都無法繼續執行，便會發生死結。了解死結的成因、判斷與處理策略，對於設計穩定、高效的並行系統至關重要。

-----

### 1. 核心概念與定義

#### 1.1 什麼是死結？

**定義：** 死結是指兩個或多個程序在競爭共享資源時，彼此互相等待對方釋放資源，導致所有相關程序都無法繼續執行的一種僵持狀態。一旦進入死結，除非外部介入，否則這些程序將永遠無法完成。

#### 1.2 死結的必要條件（Coffman 條件）

死結的發生必須同時滿足以下四個條件。如果這四個條件中至少有一個不被滿足，那麼死結就不會發生。

1.  **互斥 (Mutual Exclusion):**
    *   **核心觀念：** 至少有一個資源必須以非共享模式持有，即一次只有一個程序可以使用該資源。例如，印表機或特定的記憶體區塊。如果資源可以共享（如唯讀檔案），則不會因其引發死結。

2.  **持有並等待 (Hold and Wait):**
    *   **核心觀念：** 一個程序至少持有一個資源，同時等待獲取另一個被其他程序（可能也是死結的一部分）持有的資源。

3.  **不可搶佔 (No Preemption):**
    *   **核心觀念：** 資源不能被強制從持有它的程序中搶走，只能由持有者自願釋放。

4.  **循環等待 (Circular Wait):**
    *   **核心觀念：** 存在一個程序集合 $\{P_0, P_1, \dots, P_n\}$，其中 $P_0$ 等待 $P_1$ 所持有的資源，$P_1$ 等待 $P_2$ 所持有的資源，$\dots$，而 $P_n$ 等待 $P_0$ 所持有的資源。這形成了一個程序與資源之間的環形依賴鏈。

-----

### 2. 典型例子與資源分配圖

#### 2.1 典型例子

*   **餐桌哲學家問題 (Dining Philosophers Problem):**
    *   **描述：** 這是並行系統中最經典的死結範例之一。五位哲學家圍坐在圓桌旁，每人面前有一碗義大利麵，每兩位哲學家之間放置一支筷子。哲學家需要兩支筷子（左右各一支）才能進食。
    *   **死結成因：** 如果所有哲學家同時拿起他們左手邊的筷子，那麼所有哲學家都各持一支筷子，並等待他們右手邊的筷子（而這支筷子正被他們右邊的哲學家持有）。這完美地滿足了死結的四個條件，導致所有哲學家都無法進食。

*   **交通死結：**
    *   **描述：** 在城市交通中，如果四輛車在一個十字路口同時嘗試右轉，每輛車都佔據了其前方車輛的路徑，便可能形成死結。
    *   **死結成因：** 每輛車都「持有」它佔據的道路空間，同時「等待」它前方車輛佔據的空間被釋放。這形成了一個環形等待。

*   **資料庫死結：**
    *   **描述：** 在資料庫系統中，事務（Transaction）對資料進行操作時會鎖定（Lock）資源（如資料表、行）。
    *   **死結成因：** 考慮兩個事務 $T_1$ 和 $T_2$。
        *   $T_1$ 鎖定資源 $A$，然後請求鎖定資源 $B$。
        *   $T_2$ 鎖定資源 $B$，然後請求鎖定資源 $A$。
        *   此時，$T_1$ 持有 $A$ 等待 $B$，$T_2$ 持有 $B$ 等待 $A$，形成循環等待，導致死結。

#### 2.2 資源分配圖 (Resource-Allocation Graph)

**核心觀念：** 資源分配圖是一種有向圖，用於描述系統中程序與資源之間的分配與請求關係，是判斷死結的重要工具。

*   **圖的組成：**
    *   **節點 (Nodes):**
        *   **程序節點 (Process Node):** 用圓圈表示，例如 $P_1, P_2, \dots$。
        *   **資源節點 (Resource Node):** 用方塊表示，例如 $R_1, R_2, \dots$。如果資源有多個實例（Instance），則在方塊內繪製點來表示實例的數量。

    *   **邊 (Edges):**
        *   **請求邊 (Request Edge):** 從程序節點指向資源節點的有向邊 ($P_i \to R_j$)。表示程序 $P_i$ 正在請求資源 $R_j$ 的一個實例。
        *   **分配邊 (Assignment Edge):** 從資源節點指向程序節點的有向邊 ($R_j \to P_i$)。表示資源 $R_j$ 的一個實例已經分配給程序 $P_i$。

*   **死結判斷：**
    1.  **若圖中沒有環 (Cycle)，則系統中沒有死結。**
    2.  **若圖中有環：**
        *   **如果每個資源類型只有一個實例：** 圖中存在環就意味著死結發生。
        *   **如果每個資源類型有多個實例：** 圖中存在環僅表示**可能**發生死結。需要進一步分析（例如使用銀行家演算法）來判斷是否確實存在死結。

**例子推導：**

假設系統中有兩個程序 $P_1, P_2$ 和兩個資源 $R_1, R_2$。每個資源只有一個實例。

*   $P_1$ 持有 $R_1$，請求 $R_2$。
*   $P_2$ 持有 $R_2$，請求 $R_1$。

**資源分配圖表示：**

```
   +----+     +----+
   | P1 |<----| R1 |
   +----+     +----+
     |          ^
     | Request  | Assignment
     v          |
   +----+     +----+
   | P2 |<----| R2 |
   +----+     +----+
```

圖中有一條環 $P_1 \to R_2 \to P_2 \to R_1 \to P_1$。由於每個資源只有一個實例，所以此系統存在死結。

-----

### 3. 與相鄰概念的關聯

#### 3.1 互斥鎖 (Mutex) 與號誌 (Semaphore)

*   **關聯：** 互斥鎖和號誌是用於解決並行程序中同步問題的基礎工具，它們實現了「互斥」條件。然而，如果這些同步原語使用不當，反而會引入「持有並等待」和「循環等待」等條件，進而導致死結。
*   **例子：** 程式員忘記釋放鎖、或以不同順序獲取多個鎖，都是導致死結的常見原因。

#### 3.2 競爭條件 (Race Condition)

*   **關聯：** 競爭條件是指多個程序或執行緒以不可預測的順序訪問和操作共享資料，導致最終結果取決於這些操作的精確時序。死結可以被視為一種**極端且嚴重**的競爭條件結果，它導致系統完全停滯。
*   **差異：** 競爭條件不一定導致系統停滯，它可能只是導致計算結果不正確。死結則必然導致相關程序停滯不前。

#### 3.3 活鎖 (Livelock)

*   **關聯：** 活鎖與死結類似，也是一種程序無法取得進展的狀態。然而，與死結中的程序完全停滯不同，活鎖中的程序會不斷改變它們的狀態，試圖避免衝突，但由於同步協定設計問題，它們會無限期地重複相同的動作序列，永遠無法完成任務。
*   **例子：** 兩個人在狹窄走廊上相遇，都試圖禮讓對方而向同一個方向移動，然後又退回，不斷重複，永遠無法通過。

#### 3.4 飢餓 (Starvation)

*   **關聯：** 飢餓是指在多任務環境中，一個或多個程序因為資源分配策略不公、優先級設定問題或其他原因，長時間無法獲得所需的資源，導致其無法執行。
*   **差異：** 死結必然導致飢餓，因為死結中的程序永遠無法獲得所需的資源。但飢餓不一定是由死結引起的，例如，一個低優先級的程序可能因為高優先級程序不斷地搶佔資源而長期得不到執行，這不是死結。

-----

### 4. 進階內容：死結處理策略

操作系統處理死結有三種主要策略：死結預防、死結避免、死結偵測與恢復。

#### 4.1 死結預防 (Deadlock Prevention)

**核心觀念：** 通過破壞死結的四個必要條件中的至少一個，從而從設計上保證死結永遠不會發生。

1.  **破壞「互斥」條件：**
    *   **策略：** 將資源設計為可共享。
    *   **限制：** 對於許多資源（如印表機、寫入權限），互斥性是其本質屬性，無法消除。因此，此方法不適用於所有資源。

2.  **破壞「持有並等待」條件：**
    *   **策略一：一次性請求所有資源。** 程序在開始執行前，必須一次性請求並獲取所有它可能需要的資源。如果無法全部獲取，則不獲取任何資源，並等待直到能一次性全部獲取。
        *   **優點：** 簡潔有效。
        *   **缺點：**
            *   **資源利用率低：** 程序可能在大部分時間裡持有它暫時不需要的資源。
            *   **可能發生飢餓：** 需要大量資源的程序可能很難一次性滿足其所有請求。
            *   **難以預測：** 程序在執行前可能無法確切知道它將來需要哪些資源。
    *   **策略二：釋放已持有資源。** 當程序請求新資源且無法立即獲取時，它必須釋放所有當前持有的資源，並重新請求所有需要的資源（包括之前釋放的）。

3.  **破壞「不可搶佔」條件：**
    *   **策略一：** 如果一個程序請求的資源不可用，則操作系統可以強制它釋放所有已持有的資源。
    *   **策略二：** 如果一個程序需要某些資源，而這些資源正被另一個等待的程序持有，那麼操作系統可以搶佔這些資源並分配給請求的程序。
    *   **限制：** 僅適用於狀態容易保存和恢復的資源（如CPU暫存器）。對於印表機這類資源，搶佔可能會導致列印結果不一致。

4.  **破壞「循環等待」條件：**
    *   **策略：** 規定所有資源類型都必須以統一的、預先定義好的順序請求。
        *   **實現：** 為每個資源類型賦予一個唯一的數字編號。程序必須按遞增的順序請求資源。如果程序需要資源 $R_j$，它必須首先釋放所有編號大於 $R_j$ 的資源。
        *   **優點：** 簡單有效。
        *   **缺點：**
            *   **資源利用率低：** 程序可能不得不提前請求它暫時不需要的資源。
            *   **編號難度：** 合理的資源編號可能難以決定。
            *   **靈活性差：** 增加新資源或改變順序會影響所有程序。

#### 4.2 死結避免 (Deadlock Avoidance)

**核心觀念：** 在資源分配時，操作系統會動態檢查分配請求，確保系統始終保持在「安全狀態」。如果一個資源請求會導致系統進入不安全狀態，則拒絕該請求。

*   **安全狀態 (Safe State):**
    *   當且僅當存在一個「安全序列」時，系統處於安全狀態。
    *   **安全序列：** 一個程序執行序列 $<P_1, P_2, \dots, P_n>$，使得對於每個 $P_i$，它所需的額外資源都能由當前可用資源與所有已完成程序 $P_j$ (其中 $j < i$) 釋放的資源來滿足。
    *   如果系統處於安全狀態，那麼就保證所有程序都能在某個時間點完成。如果系統處於不安全狀態，則可能發生死結。

*   **銀行家演算法 (Banker's Algorithm):**
    *   **定義：** 最著名的死結避免演算法。它需要系統預先知道每個程序對每種資源的最大需求量。當程序請求資源時，銀行家演算法會檢查如果滿足這個請求，系統是否仍然處於安全狀態。
    *   **步驟概述：**
        1.  初始化：記錄每個程序的最大需求量、當前已分配量和當前可用資源量。
        2.  請求檢查：當程序 $P_i$ 請求資源時，首先檢查請求量是否超過其最大需求量。
        3.  安全性檢查：
            *   假設滿足請求，更新系統資源狀態。
            *   運行安全性演算法：嘗試找到一個安全序列。如果找到，則批准請求；否則，拒絕請求並恢復到請求前的狀態。
    *   **優點：** 比死結預防的限制性小，資源利用率更高。
    *   **缺點：**
        *   **性能開銷：** 每次資源請求都需要運行安全性演算法。
        *   **信息限制：** 要求預知所有程序的最大資源需求，這在實際系統中很難做到。
        *   **程序數量固定：** 程序不能中途退出或進入，資源數量不能動態改變。

#### 4.3 死結偵測與恢復 (Deadlock Detection and Recovery)

**核心觀念：** 允許死結發生，然後偵測它們並從中恢復。

*   **死結偵測 (Deadlock Detection):**
    *   **方法：**
        1.  **等待圖 (Wait-for Graph):** 如果每個資源類型只有一個實例，可以使用等待圖。等待圖是資源分配圖的簡化版，只包含程序節點和程序之間的等待關係。如果等待圖中存在環，則存在死結。
        2.  **偵測演算法：** 對於每個資源類型有多個實例的情況，需要更複雜的演算法（如銀行家演算法的變體），定期檢查系統的資源分配狀態，判斷是否存在環或不安全狀態。
    *   **執行時機：** 偵測演算法可以在每次資源請求時運行（開銷大），也可以週期性運行（如每隔一段時間或當CPU利用率下降時）。

*   **死結恢復 (Deadlock Recovery):**
    *   一旦偵測到死結，必須採取措施從中恢復。
    *   **策略一：程序終止 (Process Termination):**
        1.  **終止所有死結程序：** 最簡單粗暴的方法，但會造成巨大的工作損失。
        2.  **一次終止一個程序：** 依據某些標準（如程序的優先級、已花費的時間、還需完成的工作量、持有的資源數量、需要更多資源的數量等）選擇一個或多個程序終止，直到死結被解除。
    *   **策略二：資源搶佔 (Resource Preemption):**
        1.  **選擇犧牲者：** 選擇一個或多個程序作為犧牲者，從它們那裡搶佔資源。選擇標準與程序終止類似。
        2.  **回溯 (Rollback)：** 被搶佔資源的程序可能需要回溯到某個安全狀態，以確保其操作的正確性。這通常涉及撤銷一些操作，並重新執行。
        3.  **飢餓：** 必須確保資源搶佔策略不會導致某些程序長期被搶佔而永遠無法完成（飢餓）。

-----

### 5. 常見錯誤與澄清

#### 5.1 誤解一：只要使用鎖，就一定能避免死結。

*   **澄清：** 鎖（無論是互斥鎖、讀寫鎖或其他同步機制）本身是為了實現互斥而設計的。如果鎖的使用不當，例如多個程序以不同順序獲取多個鎖，或者忘記釋放鎖，反而會導致死結。鎖是死結發生的必要條件之一（互斥），而非避免死結的靈丹妙藥。避免死結需要仔細設計鎖的獲取與釋放策略。

#### 5.2 誤解二：死結只發生在多執行緒程式中。

*   **澄清：** 雖然多執行緒程式是死結常見的發生場所，但死結的概念更廣泛。它可能發生在：
    *   **多進程系統：** 不同進程競爭共享資源。
    *   **分散式系統：** 遠端服務、資料庫等之間的資源競爭。
    *   **資料庫事務：** 兩個或多個事務互相鎖定不同的資料行，導致互相等待。
    *   **網路協議：** 某些情況下可能出現環形依賴。

#### 5.3 誤解三：死結、活鎖和飢餓是一回事。

*   **澄清：** 這三個概念雖然都描述了程序無法取得進展的狀態，但它們的表現和原因有所不同：
    *   **死結 (Deadlock):** 程序完全停滯，無法改變狀態，因為它們無限期地等待某個被其他死結程序持有的資源。
    *   **活鎖 (Livelock):** 程序不斷改變狀態，嘗試避免衝突，但由於同步邏輯缺陷，它們會無限期地重複相同的動作序列，永遠無法完成任務。程序是「活」的，但沒有進展。
    *   **飢餓 (Starvation):** 一個或多個程序長時間無法獲得所需的資源，因為資源分配策略不公，或者有更高優先級的程序不斷搶佔資源。飢餓的程序可能最終會執行，只是時間很長。死結必然導致飢餓，但飢餓不一定是由死結引起。

-----

### 6. 小練習（附詳解）

#### 小練習 1：資源分配圖分析

**題目：**
考慮一個系統，其中有兩個程序 $P_1, P_2$ 和兩個資源 $R_1, R_2$。每個資源只有一個實例。
當前的資源分配狀態如下：
*   $P_1$ 持有 $R_1$，請求 $R_2$。
*   $P_2$ 持有 $R_2$，請求 $R_1$。

請繪製資源分配圖，並判斷系統是否存在死結。

**詳解：**

1.  **繪製程序節點和資源節點：**
    *   程序節點：$P_1$ (圓圈), $P_2$ (圓圈)
    *   資源節點：$R_1$ (方塊), $R_2$ (方塊)。由於每個資源只有一個實例，方塊內不需要點。

2.  **添加分配邊 (Assignment Edges)：**
    *   $P_1$ 持有 $R_1$：從 $R_1$ 指向 $P_1$ 的邊 ($R_1 \to P_1$)。
    *   $P_2$ 持有 $R_2$：從 $R_2$ 指向 $P_2$ 的邊 ($R_2 \to P_2$)。

3.  **添加請求邊 (Request Edges)：**
    *   $P_1$ 請求 $R_2$：從 $P_1$ 指向 $R_2$ 的邊 ($P_1 \to R_2$)。
    *   $P_2$ 請求 $R_1$：從 $P_2$ 指向 $R_1$ 的邊 ($P_2 \to R_1$)。

4.  **最終資源分配圖：**

    ```
       P1 <---- R1
       |        ^
       | Request| Assignment
       v        |
       R2 <---- P2
    ```
    簡化為環路表示：
    $P_1 \to R_2 \to P_2 \to R_1 \to P_1$

5.  **判斷死結：**
    *   觀察資源分配圖，我們發現存在一個環：$P_1 \to R_2 \to P_2 \to R_1 \to P_1$。
    *   由於每個資源類型（$R_1, R_2$）都只有一個實例，圖中存在環就意味著死結發生。
    *   因此，**系統存在死結。**

#### 小練習 2：死結預防策略應用

**題目：**
有兩個資源 $A$ 和 $B$，以及兩個程序 $P_1$ 和 $P_2$。
*   $P_1$ 的操作順序為：請求 $A$，請求 $B$，使用 $A$ 和 $B$，釋放 $B$，釋放 $A$。
*   $P_2$ 的操作順序為：請求 $B$，請求 $A$，使用 $A$ 和 $B$，釋放 $A$，釋放 $B$。

1.  這種情況下是否可能發生死結？請說明原因。
2.  如何運用死結預防中的「破壞循環等待」策略來避免此死結？

**詳解：**

1.  **是否可能發生死結？**
    *   **是的，可能發生死結。**
    *   **原因：** 假設發生以下時序：
        1.  $P_1$ 請求並獲取資源 $A$。
        2.  $P_2$ 請求並獲取資源 $B$。
        3.  此時，$P_1$ 持有 $A$，然後請求 $B$（但 $B$ 被 $P_2$ 持有）。
        4.  $P_2$ 持有 $B$，然後請求 $A$（但 $A$ 被 $P_1$ 持有）。
    *   這滿足了死結的四個必要條件：
        *   **互斥：** $A$ 和 $B$ 都是互斥資源。
        *   **持有並等待：** $P_1$ 持有 $A$ 等待 $B$，$P_2$ 持有 $B$ 等待 $A$。
        *   **不可搶佔：** 資源不能被搶佔。
        *   **循環等待：** $P_1$ 等待 $P_2$ 持有的 $B$， $P_2$ 等待 $P_1$ 持有的 $A$，形成環路。

2.  **如何運用「破壞循環等待」策略避免死結？**
    *   **核心策略：** 規定所有資源類型都必須以統一的、預先定義好的順序請求。
    *   **步驟：**
        1.  **為資源編號：** 我們可以為資源 $A$ 和 $B$ 賦予一個全局唯一的順序號。例如，設 $A$ 的編號為 1， $B$ 的編號為 2。
        2.  **修改程序請求順序：**
            *   **規定：** 所有程序必須以資源編號遞增的順序請求資源。
            *   **對 $P_1$ 和 $P_2$ 的調整：**
                *   如果 $P_1$ 和 $P_2$ 都需要資源 $A$ (編號 1) 和資源 $B$ (編號 2)，那麼它們都必須先請求 $A$，然後再請求 $B$。
            *   **調整後的程序操作順序：**
                *   $P_1$: 請求 $A$，請求 $B$，使用 $A$ 和 $B$，釋放 $B$，釋放 $A$。 (此順序符合要求)
                *   $P_2$: **請求 $A$，請求 $B$**，使用 $A$ 和 $B$，釋放 $B$，釋放 $A$。 (原先請求 $B$ 再請求 $A$ 的行為被修正)
    *   **結果：**
        *   現在，$P_1$ 和 $P_2$ 都會嘗試先獲取 $A$。如果 $P_1$ 獲取了 $A$，那麼 $P_2$ 會等待 $A$ 釋放。當 $P_1$ 完成對 $A$ 的請求後，它會繼續請求 $B$。如果 $P_1$ 成功獲取 $A$ 和 $B$ 並完成，它會釋放所有資源。此時 $P_2$ 就能獲取 $A$ 和 $B$ 並執行。
        *   反之，如果 $P_2$ 先獲取了 $A$，則 $P_1$ 會等待 $A$ 釋放。
        *   由於不再存在一個程序持有低序號資源並等待高序號資源，同時另一個程序持有高序號資源並等待低序號資源的情況，**循環等待條件被破壞，從而避免了死結。**

-----

### 7. 延伸閱讀與參考

*   **作業系統概論 (Operating System Concepts)**
    *   作者：Abraham Silberschatz, Peter B. Galvin, Greg Gagne
    *   內容：這是作業系統領域的經典教科書，其中關於死結的章節提供了詳細的理論基礎、演算法和案例研究。

*   **現代作業系統 (Modern Operating Systems)**
    *   作者：Andrew S. Tanenbaum, Herbert Bos
    *   內容：另一本廣受好評的作業系統教科書，對死結問題也有深入淺出的講解。

*   **並行程式設計 (Concurrency Programming)**
    *   主題：任何關於並行程式設計、多執行緒編程的書籍或線上課程，通常都會詳細討論死結的預防、檢測和避免。

*   **資料庫系統概念 (Database System Concepts)**
    *   主題：資料庫系統中的並行控制（Concurrency Control）章節，會專門討論事務死結的檢測與解決方案。