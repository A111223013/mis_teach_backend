# 資料結構對程式效率的影響

-----

### 核心概念與定義

資料結構是電腦科學中用來組織、管理和儲存資料的方式，以便能更有效率地存取和修改。程式效率則是衡量一個程式在執行時消耗資源（主要是時間和記憶體）的程度。兩者之間存在著密不可分的關係：資料結構的選擇直接決定了特定演算法的效率上限。

#### 資料結構 (Data Structure)
- **定義：** 一種特定組織資料的方式，旨在優化對資料的存取、操作和儲存。不同的資料結構適用於不同的應用場景，它們各自提供特定的優勢和權衡。
- **核心觀念：** 資料結構不僅僅是儲存資料，更重要的是定義了資料之間的關係以及允許在這些資料上執行的操作集合。選擇合適的資料結構是編寫高效能程式的基石。
- **例子：** 陣列（Array）、鏈結串列（Linked List）、樹（Tree）、圖（Graph）、雜湊表（Hash Table）等。

#### 程式效率 (Program Efficiency)
- **定義：** 衡量程式在執行時所消耗的計算資源量。主要從兩個方面評估：
    1.  **時間複雜度 (Time Complexity)：** 衡量程式執行所需的「時間」與輸入資料量之間的關係。通常以操作次數來表示，而不是實際的秒數，因為實際時間受硬體、作業系統等因素影響。
    2.  **空間複雜度 (Space Complexity)：** 衡量程式執行所需的「記憶體」與輸入資料量之間的關係。包括儲存輸入資料本身、程式變數、遞迴堆疊等所需的空間。
- **核心觀念：** 程式效率的評估通常使用**漸近分析 (Asymptotic Analysis)**，特別是**大 O 符號 (Big O Notation)** 來描述。它描述了當輸入規模變得非常大時，演算法性能的上限趨勢。
- **例子：**
    *   $O(1)$：常數時間，操作次數與輸入大小無關。
    *   $O(\log n)$：對數時間，輸入大小增加時，操作次數緩慢增加。
    *   $O(n)$：線性時間，操作次數與輸入大小成正比。
    *   $O(n \log n)$：線性對數時間，常見於高效排序演算法。
    *   $O(n^2)$：平方時間，操作次數與輸入大小的平方成正比，效率較低。
- **與資料結構的關聯：** 不同的資料結構對於相同的操作（例如插入、刪除、搜尋）會有不同的時間和空間複雜度。因此，選擇一個在特定應用中能提供最佳操作效率的資料結構至關重要。

-----

### 典型例子與比較

了解不同資料結構在常用操作上的效率，是選擇最佳方案的關鍵。以下比較幾種常見資料結構：

#### 陣列 (Array)
- **定義：** 儲存在連續記憶體位置中的同類型資料集合，透過索引進行存取。
- **核心觀念：** 提供極佳的隨機存取能力，因為記憶體地址可直接計算。
- **操作效率：**
    *   **存取 (Access by index)：** $O(1)$
        *   **推導：** 假設陣列起始地址為 `base_addr`，每個元素大小為 `size_of_element`，要存取索引 `i` 的元素，其地址為 `base_addr + i * size_of_element`。這是一個簡單的數學運算，所需時間與陣列大小無關。
    *   **插入/刪除 (Insertion/Deletion at arbitrary position)：** $O(n)$
        *   **推導：** 在陣列中間插入或刪除元素，需要將其後的所有元素向前或向後移動一個位置，以保持記憶體連續性。這涉及到 $n-i$ 個元素的移動，其中 $i$ 是插入/刪除的位置，因此複雜度與 $n$ 成正比。
    *   **插入/刪除 (Insertion/Deletion at end)：** $O(1)$ (對於固定大小陣列)，$O(1)$ 攤銷時間 (對於動態陣列，如 `std::vector` 或 `ArrayList`)
        *   **推導：** 在陣列尾部操作通常不需要移動其他元素。對於動態陣列，雖然偶爾會發生擴容導致 $O(n)$ 的複製，但長期來看，平均每次操作是常數時間。
- **應用：** 需要頻繁隨機存取、資料量相對固定、對記憶體連續性有要求的場景。

#### 鏈結串列 (Linked List)
- **定義：** 由一系列節點（Node）組成，每個節點包含資料和指向下一個節點的指針。記憶體位置不一定連續。
- **核心觀念：** 彈性地支持插入和刪除操作，無需移動大量元素。
- **操作效率：**
    *   **存取 (Access by index)：** $O(n)$
        *   **推導：** 要存取索引 `i` 的元素，必須從鏈結串列的頭部開始，沿著指針逐個節點遍歷，直到找到第 `i` 個節點。所需遍歷次數與 `i` 成正比，最差情況下為 $n$ 次。
    *   **插入/刪除 (Insertion/Deletion at specific position *if pointer to node is known*)：** $O(1)$
        *   **推導：** 如果已知要操作的節點及其前後節點的指針，只需修改少數指針即可完成插入或刪除，與鏈結串列大小無關。
    *   **插入/刪除 (Insertion/Deletion at head/tail)：** $O(1)$ (如果維護頭尾指針)
        *   **推導：** 直接操作頭部或尾部指針，只需修改少數指針。
- **應用：** 需要頻繁在中間插入或刪除元素、資料量不確定、記憶體不需連續的場景。

#### 二元搜尋樹 (Binary Search Tree - BST)
- **定義：** 一種特殊的二元樹，其中每個節點的值都大於其左子樹中的所有值，且小於其右子樹中的所有值。
- **核心觀念：** 結合了陣列的搜尋效率（在某種程度上）和鏈結串列的彈性插入/刪除能力。
- **操作效率 (平均情況)：**
    *   **搜尋 (Search)、插入 (Insertion)、刪除 (Deletion)：** $O(\log n)$
        *   **推導：** 在平衡的二元搜尋樹中，每次比較都會將搜尋範圍縮小一半，類似二分搜尋。因此，操作次數與樹的高度成正比，而平衡樹的高度約為 $\log n$。
- **操作效率 (最差情況 - skewed tree)：**
    *   **搜尋、插入、刪除：** $O(n)$
        *   **推導：** 如果樹退化成一條鏈結串列（例如，插入的元素總是遞增或遞減），則樹的高度變為 $n$，操作效率會降為線性時間。為避免此情況，需要使用**平衡二元搜尋樹**（如 AVL 樹、紅黑樹）。
- **應用：** 需要快速搜尋、排序、範圍查詢、同時支持動態插入刪除的場景。

#### 雜湊表 (Hash Table)
- **定義：** 一種根據鍵（key）直接存取值（value）的資料結構，透過雜湊函數將鍵映射到一個儲存位置。
- **核心觀念：** 在理想情況下提供常數時間的平均操作效率。
- **操作效率 (平均情況)：**
    *   **插入 (Insertion)、刪除 (Deletion)、搜尋 (Search)：** $O(1)$
        *   **推導：** 透過雜湊函數直接計算出元素的儲存位置，無需遍歷。假設雜湊函數均勻分佈且衝突處理得當，操作時間與輸入大小無關。
- **操作效率 (最差情況 - collision handling issues)：**
    *   **插入、刪除、搜尋：** $O(n)$
        *   **推導：** 當發生大量雜湊衝突時，所有元素可能都被映射到同一個儲存位置，此時需要遍歷該位置上的所有元素（例如使用鏈結串列處理衝突），效率退化為線性時間。
- **應用：** 字典（Dictionary）、快取（Cache）、集合（Set）的實現、需要極快速鍵值查詢的場景。

-----

### 與相鄰概念的關聯

資料結構並非孤立存在，它與演算法、記憶體管理和軟體設計模式等概念緊密相連，共同影響程式的整體效能。

#### 1. 資料結構與演算法 (Algorithms)
- **關聯：** 資料結構是演算法的骨架，演算法是操作資料結構的步驟。一個演算法的效率，往往取決於它所操作的資料結構是否得當。
- **例子：**
    *   **排序演算法：** 快速排序（Quick Sort）在陣列上表現優異，而合併排序（Merge Sort）則對陣列和鏈結串列都適用。如果對鏈結串列使用基於索引的排序演算法（如氣泡排序），其效率會因為鏈結串列 $O(n)$ 的隨機存取而大幅降低。
    *   **圖遍歷演算法：** 廣度優先搜尋（BFS）和深度優先搜尋（DFS）在圖上的實現，通常會利用佇列（Queue）或堆疊（Stack）這些資料結構來輔助遍歷。
- **核心觀念：** 演算法設計者必須根據問題的特性和所選資料結構的操作效率來選擇或設計演算法，以達到最佳的綜合性能。一個再精妙的演算法，如果其底層資料結構選擇不當，也很難達到預期的效率。

#### 2. 資料結構與記憶體管理 (Memory Management)
- **關聯：** 資料結構的選擇直接影響記憶體的使用模式、快取命中率以及記憶體碎片化程度。
- **例子：**
    *   **陣列 vs. 鏈結串列：**
        *   **陣列：** 元素在記憶體中是連續儲存的，這有利於**快取友好性 (Cache Locality)**。當存取陣列中的一個元素時，CPU 很可能會將其附近的一塊記憶體資料（稱為快取行，Cache Line）預先載入到高速快取中，這使得對鄰近元素的後續存取速度更快。
        *   **鏈結串列：** 元素分散在記憶體的各個位置，導致快取命中率較低。每次存取一個新節點可能都需要從主記憶體中載入，速度相對較慢。
    *   **動態記憶體分配：** 許多資料結構（如樹、圖、鏈結串列）需要頻繁地動態分配和釋放記憶體節點。這可能導致**記憶體碎片化 (Memory Fragmentation)**，即記憶體中存在大量小的、不連續的可用空間，最終影響記憶體利用率。
- **核心觀念：** 在追求時間效率的同時，也必須考慮空間效率和記憶體存取模式。在現代計算機體系結構中，快取機制對程式性能有著巨大影響，因此資料結構的快取友好性是一個不可忽視的設計考量。

#### 3. 資料結構與軟體設計模式 (Software Design Patterns)
- **關聯：** 許多設計模式內部會利用特定的資料結構來解決通用設計問題，或作為其實現的基礎。
- **例子：**
    *   **命令模式 (Command Pattern)：** 常用佇列（Queue）來儲存一系列待執行的命令，以便依序執行或提供撤銷功能。
    *   **觀察者模式 (Observer Pattern)：** 主題（Subject）通常使用鏈結串列或陣列來儲存所有觀察者（Observer）的引用，以便在狀態改變時通知它們。
    *   **策略模式 (Strategy Pattern)：** 如果有多種演算法策略可供選擇，可能會使用雜湊表或映射（Map）來根據鍵動態地選擇和載入相應的策略物件。
- **核心觀念：** 設計模式提供了解決常見軟體設計問題的範本。理解這些模式如何利用資料結構，有助於我們在更高層次上設計出既高效又可維護的軟體系統。

-----

### 進階內容：快取友好性與攤銷分析

#### 快取友好性 (Cache Locality)
- **核心觀念：** 現代 CPU 的處理速度遠超主記憶體存取速度。為彌補這一差距，CPU 設有多級快取（L1, L2, L3）。當資料被存取時，它及其附近的一些資料塊會被載入到快取中。如果程式能頻繁地存取快取中已有的資料，那麼性能會顯著提升，這就是快取友好性。
- **影響：**
    *   **陣列：** 由於元素在記憶體中是連續儲存的，當存取 `arr[i]` 時，`arr[i+1]`, `arr[i+2]` 等很可能同時被載入到快取中。這使得對這些鄰近元素的後續存取非常快，展現出良好的空間局部性。
    *   **鏈結串列：** 節點在記憶體中分散，當存取一個節點時，下一個節點很可能不在快取中，需要從主記憶體重新載入，導致「快取失誤（Cache Miss）」頻繁發生，性能下降。
- **實踐意義：** 儘管某些資料結構在理論上的時間複雜度相同（例如，尋找某個值的平衡二元搜尋樹和雜湊表，在某些情況下都可能是 $O(\log n)$ 或 $O(1)$），但其底層記憶體存取模式對實際性能的影響可能截然不同。對於大量數據的遍歷和連續操作，陣列或基於陣列的資料結構（如堆、動態陣列）通常比基於指針的資料結構（如鏈結串列、標準的二元樹）有更好的實際性能。

#### 攤銷分析 (Amortized Analysis)
- **核心觀念：** 攤銷分析是一種用於評估演算法操作平均性能的方法。它考慮的是一系列操作的總成本，而不是單個操作的最壞情況成本。即使某個單一操作的成本很高，但如果這種高成本的操作很少發生，且被大量低成本操作分攤，那麼平均來看，每個操作的成本可能依然很低。
- **例子：** **動態陣列 (Dynamic Array)** 的插入操作。
    *   當動態陣列滿時，需要分配一個更大的新記憶體空間（通常是當前大小的兩倍），然後將所有舊元素複製到新空間，最後釋放舊空間。這個擴容操作的成本是 $O(n)$，其中 $n$ 是當前元素數量。
    *   然而，在兩次 $O(n)$ 的擴容操作之間，會有大量的 $O(1)$ 插入操作。
    *   **推導：** 考慮從空陣列開始，插入 $n$ 個元素的總成本。假設每次擴容都將容量加倍。則總成本可以表示為：
        $1 + 2 + 4 + \dots + n \approx 2n$ （複製操作）+ $n$ （單次插入操作）
        總成本約為 $O(n)$。將這總成本分攤到 $n$ 次插入操作上，則每次插入的**攤銷成本**為 $O(n)/n = O(1)$。
- **實踐意義：** 攤銷分析告訴我們，在某些情況下，即使存在偶爾開銷很大的操作，我們仍然可以宣稱其平均效率很高。這對於設計和選擇資料結構（例如用於緩衝區、隊列等）非常重要，它讓我們能夠更精確地理解其在長期運行下的性能。

-----

### 常見錯誤與澄清

#### 誤解一：永遠選擇理論上「最快」的資料結構。
- **澄清：** 沒有「萬能」的資料結構。一個資料結構在某種操作上表現最佳，但在其他操作上可能表現平平甚至很差。例如，雜湊表在平均情況下提供 $O(1)$ 的查詢速度，但如果記憶體有限或存在惡意衝突，其性能可能急劇下降；而且它不擅長範圍查詢或保持元素順序。選擇資料結構應根據具體應用場景中**最頻繁、最關鍵**的操作來權衡時間複雜度、空間複雜度以及實現的複雜度。

#### 誤解二：只關注時間複雜度，忽略空間複雜度。
- **澄清：** 儘管時間效率是首要考量，但空間複雜度在許多實際應用中同樣重要。
    *   在嵌入式系統、行動裝置等記憶體受限的環境中，過大的空間開銷可能導致程式無法運行甚至崩潰。
    *   即使在記憶體充裕的環境中，過多的記憶體使用也會影響快取命中率，進而間接影響時間效率。
    *   在某些大規模數據處理場景，例如圖形處理或大數據分析，即使是微小的空間開銷差異也可能累積成巨大的記憶體需求。
    *   **時間-空間權衡 (Time-Space Trade-off)** 是一個常見的設計決策：有時可以犧牲一些記憶體來換取更快的執行速度，反之亦然。

#### 誤解三：混淆 Big O 符號表示的「最差情況」與「平均情況」。
- **澄清：** Big O 符號通常用於描述演算法在**最差情況 (Worst-Case)** 下的性能上限。這對於保證演算法的可靠性很重要，因為它確保了即使在最不利的輸入下，演算法的執行時間也不會超過某個閾值。
    *   然而，許多資料結構和演算法在**平均情況 (Average-Case)** 下的性能遠好於最差情況。例如，雜湊表和非平衡二元搜尋樹的平均查詢時間遠優於它們的最差情況 $O(n)$。
    *   在實際應用中，通常會更接近平均情況的性能。因此，理解兩者之間的差異至關重要。在設計系統時，需要根據實際的輸入數據分佈和對最壞情況的容忍度來決定。例如，對於安全敏感的應用，即使平均性能良好，也必須考慮最壞情況的穩定性。

-----

### 小練習（附詳解）

#### 小練習一：選購清單管理

**情境：**
你正在開發一個手機應用程式，用於管理用戶的購物清單。清單中的商品需要能夠：
1.  **快速新增商品**（通常新增到清單尾部或任意位置）。
2.  **快速勾選已購買商品**（即從清單中刪除）。
3.  **瀏覽清單**（從頭到尾遍歷所有商品）。
4.  **查詢特定商品是否存在**。
5.  **商品順序可能需要調整**（例如，將某商品移動到清單頂部或底部）。

請為這個購物清單應用程式選擇最適合的資料結構，並解釋你的選擇。

**詳解：**

1.  **分析需求：**
    *   **快速新增商品 (1)：** 需要 $O(1)$ 或攤銷 $O(1)$。
    *   **快速刪除商品 (2)：** 需要 $O(1)$ 或 $O(\log n)$。如果知道商品位置，則 $O(1)$ 更佳。
    *   **瀏覽清單 (3)：** 需要 $O(n)$，所有結構都能做到。
    *   **查詢特定商品 (4)：** 需要 $O(1)$ 或 $O(\log n)$。
    *   **調整商品順序 (5)：** 這意味著需要頻繁地在中間插入/刪除或移動元素。

2.  **排除選項：**
    *   **單向鏈結串列：**
        *   優點：新增/刪除操作（如果已知節點或在頭尾）是 $O(1)$。
        *   缺點：查詢是 $O(n)$，調整順序需要遍歷找到位置，也是 $O(n)$。這不滿足「快速查詢」和「調整順序」的需求。
    *   **陣列 (固定大小)：**
        *   優點：瀏覽和隨機存取是 $O(1)$。
        *   缺點：新增/刪除在中間是 $O(n)$，商品數量不確定時不適合。不滿足「快速新增/刪除」需求。
    *   **雜湊表：**
        *   優點：新增、刪除、查詢平均是 $O(1)$。
        *   缺點：**不保持順序**。無法輕鬆實現「瀏覽清單（按順序）」和「調整商品順序」。
    *   **二元搜尋樹：**
        *   優點：新增、刪除、查詢平均是 $O(\log n)$。可以遍歷得到排序的結果。
        *   缺點：不直接支持「調整順序」為任意位置，除非重新構建部分樹。

3.  **推薦資料結構：**
    *   **雙向鏈結串列 (Doubly Linked List)** 或 **動態陣列 (Dynamic Array)**。

4.  **詳細解釋與權衡：**

    *   **選擇一：雙向鏈結串列 (Doubly Linked List)**
        *   **優點：**
            *   **快速新增/刪除：** 如果已知要操作的節點，可以在 $O(1)$ 時間內完成插入和刪除。如果新增到頭尾，也是 $O(1)$。
            *   **調整順序：** 如果已知要移動的商品節點及其目標位置節點，可以在 $O(1)$ 時間內將其取出並重新插入。
            *   **瀏覽清單：** 可以雙向遍歷，效率 $O(n)$。
        *   **缺點：**
            *   **查詢特定商品：** 仍然需要 $O(n)$ 時間遍歷，這不夠「快速」。
            *   **記憶體開銷：** 每個節點需要額外兩個指針（`next` 和 `prev`），比單向鏈結串列或陣列大。
        *   **結論：** 如果「調整順序」是高頻操作，且「查詢」可以容忍 $O(n)$ 或配合其他結構（如哈希映射）來快速定位節點，則雙向鏈結串列是很好的選擇。

    *   **選擇二：動態陣列 (Dynamic Array, 如 C++ 的 `std::vector` 或 Java 的 `ArrayList`)**
        *   **優點：**
            *   **快速新增商品 (尾部)：** 攤銷 $O(1)$。
            *   **瀏覽清單：** $O(n)$，且由於記憶體連續，快取友好，實際速度很快。
            *   **查詢特定商品：** 如果按索引查詢是 $O(1)$，如果按值查詢則是 $O(n)$。
        *   **缺點：**
            *   **快速刪除/中間插入：** 仍然是 $O(n)$，因為需要移動後續元素。
            *   **調整順序：** 將商品從中間移動到另一位置，本質上是先刪除後插入，兩個 $O(n)$ 操作。
        *   **結論：** 如果「新增到尾部」和「瀏覽」是主要操作，且「刪除/調整順序」頻率較低，或者商品數量通常不大，則動態陣列是好的選擇。

    *   **綜合方案（推薦）：**
        如果「快速查詢」和「快速調整順序」都非常重要，可以考慮使用**雙向鏈結串列**，並結合一個**雜湊表**來輔助快速查詢。
        *   **資料結構：**
            *   一個 `DoublyLinkedList<Item>` 儲存購物清單的商品順序。每個 `Item` 包含商品名稱、狀態等信息。
            *   一個 `HashMap<String, Node<Item>>` 將商品名稱映射到 `DoublyLinkedList` 中對應的節點指針。
        *   **操作效率：**
            *   **快速新增商品：** 新增到雙向鏈結串列尾部是 $O(1)$，同時在雜湊表中新增映射也是 $O(1)$。總體 $O(1)$。
            *   **快速勾選已購買商品 (刪除)：** 通過雜湊表 $O(1)$ 找到節點，然後在雙向鏈結串列中 $O(1)$ 刪除。總體平均 $O(1)$。
            *   **瀏覽清單：** 遍歷雙向鏈結串列是 $O(n)$。
            *   **查詢特定商品是否存在：** 通過雜湊表 $O(1)$ 查詢。
            *   **調整商品順序：** 通過雜湊表 $O(1)$ 找到要移動的節點，然後在雙向鏈結串列中 $O(1)$ 調整其前後指針，並在目標位置 $O(1)$ 重新插入。總體平均 $O(1)$。
        *   **權衡：** 增加了記憶體開銷（雙向鏈結串列的指針 + 雜湊表），但換取了所有關鍵操作的極高效率。這是一個常見的「時間換空間」策略。

#### 小練習二：比較陣列與鏈結串列在特定操作下的效率

**問題：**
比較在 C 語言中，一個大小為 $N$ 的整數陣列 (`int arr[N]`) 和一個包含 $N$ 個整數的單向鏈結串列 (`struct Node* head`)，分別執行以下操作的**時間複雜度**，並簡要解釋原因。

1.  讀取第 $k$ 個元素（`arr[k-1]` 或鏈結串列中的第 $k$ 個節點）。
2.  在第 $k$ 個元素**之前**插入一個新元素。

**詳解：**

1.  **讀取第 $k$ 個元素：**

    *   **陣列 (`arr`)：**
        *   **時間複雜度：** $O(1)$
        *   **解釋：** 陣列元素在記憶體中是連續儲存的。要讀取第 $k$ 個元素，只需要知道陣列的起始地址和每個元素的大小，就可以透過一個簡單的數學運算（`起始地址 + (k-1) * 元素大小`）直接計算出其記憶體地址並存取。這個過程與 $N$ 的大小無關。

    *   **單向鏈結串列 (`head`)：**
        *   **時間複雜度：** $O(k)$，最差情況 $O(N)$
        *   **解釋：** 單向鏈結串列的元素分散在記憶體中，無法直接透過索引計算地址。要讀取第 $k$ 個元素，必須從頭節點 (`head`) 開始，沿著 `next` 指針逐一遍歷，直到到達第 $k$ 個節點。這個過程需要 $k-1$ 次指針跳轉，因此時間複雜度與 $k$ 成正比。在最差情況下（讀取最後一個元素），需要遍歷所有 $N$ 個節點，為 $O(N)$。

2.  **在第 $k$ 個元素之前插入一個新元素：**

    *   **陣列 (`arr`)：**
        *   **時間複雜度：** $O(N)$
        *   **解釋：** 在陣列的第 $k$ 個位置插入新元素，需要將原先從第 $k$ 個元素開始到陣列末尾的所有元素向後移動一個位置，為新元素騰出空間。這涉及到 $(N-k+1)$ 個元素的移動操作。在最差情況下（在第一個位置插入），需要移動所有 $N$ 個元素，因此時間複雜度為 $O(N)$。

    *   **單向鏈結串列 (`head`)：**
        *   **時間複雜度：** $O(k)$，最差情況 $O(N)$
        *   **解釋：** 要在第 $k$ 個元素之前插入新元素，首先必須找到第 $(k-1)$ 個節點（即要插入位置的前一個節點），以便修改其 `next` 指針。找到第 $(k-1)$ 個節點的過程需要從頭節點開始遍歷 $k-2$ 次指針跳轉，這是 $O(k)$。一旦找到該節點，插入操作本身（創建新節點，修改兩個指針）是 $O(1)$。因此，總的時間複雜度由尋找前一個節點的過程決定，為 $O(k)$。在最差情況下（在最後一個元素之前插入），需要遍歷 $N-1$ 個節點，為 $O(N)$。
        *   **特別說明：** 如果是在鏈結串列的**頭部**插入，則時間複雜度是 $O(1)$，因為無需遍歷，直接修改 `head` 指針即可。

-----

### 延伸閱讀

1.  **《演算法導論》 (Introduction to Algorithms)** by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein.
    *   被譽為演算法領域的聖經，對資料結構和演算法的理論基礎有深入而嚴謹的闡述。

2.  **《資料結構與演算法分析》 (Data Structures and Algorithm Analysis in C++/Java/C)** by Mark Allen Weiss.
    *   以清晰易懂的方式介紹各種資料結構及其演算法，並提供具體的程式碼實現和性能分析。

3.  **線上資源：**
    *   **LeetCode：** 提供了大量的演算法和資料結構練習題，是提升實戰能力的絕佳平台。
    *   **GeeksforGeeks：** 涵蓋了豐富的電腦科學主題，包括資料結構、演算法、程式語言等，提供了詳細的解釋和程式碼範例。
    *   **Wikipedia (各資料結構條目)：** 提供對各種資料結構的簡潔定義、特性和操作複雜度的概述。