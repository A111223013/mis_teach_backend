# 8-1 設計模式應用

設計模式是軟體開發領域中，針對在特定情境下，重複出現的問題所提出的通用、可重複使用的解決方案。它們並非直接可用的程式碼，而是一種描述如何在不同情境下解決特定設計問題的藍圖或模板。學習設計模式能幫助開發者使用已驗證過的最佳實踐來構建更靈活、可維護且易於擴展的系統。

-----

### 1. 核心概念與定義：設計模式是什麼？

#### 1.1 什麼是設計模式？

**定義/核心觀念：**
設計模式（Design Patterns）是軟體工程中，針對在特定情境下重複出現的設計問題，所提出的一套標準化、經實踐驗證的解決方案。它們是由一群被稱為「四人幫」（Gang of Four, GoF）的作者，在 1994 年出版的經典書籍《Design Patterns: Elements of Reusable Object-Oriented Software》中首次系統性地提出，書中定義了 23 種經典設計模式。

設計模式不是一種程式語言，也不是可以直接複製貼上的程式碼，而是一種**思維框架**或**藍圖**。它描述了物件或類別之間如何互動以解決特定問題的結構，提供了通用的解決方案，讓開發者能夠在不同專案中重複應用這些概念，而無需從零開始重新發明輪子。

#### 1.2 為什麼需要設計模式？

**核心觀念：**
採用設計模式帶來多重效益，有助於提升軟體品質與開發效率：

*   **提供共同語言 (Common Vocabulary)：** 模式為開發團隊提供了一套標準化的術語。當團隊成員討論「單例模式」或「策略模式」時，他們知道在談論什麼樣的設計結構，有助於溝通與理解。
*   **提供經驗證的解決方案 (Proven Solutions)：** 模式代表了在數十年間被證明有效的最佳實踐。應用這些模式意味著你正在使用已被廣泛測試和認可的解決方案，降低了設計出錯誤或低效方案的風險。
*   **提高程式碼可讀性與可維護性 (Readability & Maintainability)：** 使用標準模式的程式碼更容易被新成員理解，因為他們可能已經熟悉這些模式。遵循模式的結構，使得未來修改或擴展系統變得更容易。
*   **促進程式碼重用 (Code Reusability)：** 設計模式鼓勵將重複的設計結構抽象化，有助於創建更通用、可重用的元件，減少重複編寫相似功能的程式碼。
*   **提升系統彈性與可擴展性 (Flexibility & Extensibility)：** 許多模式旨在解耦不同部分的功能，使得系統的某一部分可以在不影響其他部分的情況下被修改或替換，從而提高系統的彈性與可擴展性。
*   **降低複雜度 (Reduce Complexity)：** 透過將複雜問題分解為更小、可管理的、且已被解決的子問題，設計模式有助於管理大型軟體系統的複雜性。

#### 1.3 設計模式的分類

GoF 將 23 種設計模式分為三大類，每一類解決不同層面的問題：

*   **創建型模式 (Creational Patterns)：**
    *   **目的：** 關注物件的創建機制，以一種適合特定情境的方式來創建物件。它們將物件的創建與其使用方解耦。
    *   **例子：** 單例模式 (Singleton)、工廠方法模式 (Factory Method)、抽象工廠模式 (Abstract Factory)、建造者模式 (Builder)、原型模式 (Prototype)。
    *   **與相鄰概念的關聯：** 這些模式使得在不直接暴露創建邏輯的情況下，彈性地創建物件，例如：工廠模式可以根據不同條件產生不同的物件類型，而單例模式則確保只有一個實例。

*   **結構型模式 (Structural Patterns)：**
    *   **目的：** 關注類別和物件如何組成更大的結構。它們描述了如何組合物件和類別來形成更大的結構，同時保持結構的彈性與效率。
    *   **例子：** 適配器模式 (Adapter)、橋接模式 (Bridge)、組合模式 (Composite)、裝飾者模式 (Decorator)、外觀模式 (Facade)、享元模式 (Flyweight)、代理模式 (Proxy)。
    *   **與相鄰概念的關聯：** 這些模式幫助我們設計出更具彈性的類別結構，例如：裝飾者模式可以在不修改原始類別的情況下為物件動態添加新功能，而適配器模式則讓不相容的介面能夠協同工作。

*   **行為型模式 (Behavioral Patterns)：**
    *   **目的：** 關注物件之間的責任分配和互動方式。它們描述了物件之間如何溝通，以確保各物件能有效地完成任務。
    *   **例子：** 責任鏈模式 (Chain of Responsibility)、命令模式 (Command)、迭代器模式 (Iterator)、中介者模式 (Mediator)、備忘錄模式 (Memento)、觀察者模式 (Observer)、狀態模式 (State)、策略模式 (Strategy)、模板方法模式 (Template Method)、造訪者模式 (Visitor)。
    *   **與相鄰概念的關聯：** 這些模式優化了物件之間的互動，例如：策略模式允許在運行時替換物件的行為，而觀察者模式則讓物件在狀態改變時能夠自動通知其他依賴它的物件。

-----

### 2. 典型設計模式解析

本節將深入探討兩種在實務中廣泛應用的設計模式：單例模式（創建型）和策略模式（行為型）。

#### 2.1 創建型模式範例：單例模式 (Singleton Pattern)

**核心觀念：**
單例模式 (Singleton Pattern) 的目的是確保一個類別在任何時刻都只有一個實例存在，並提供一個全域的訪問點給這個唯一的實例。這對於管理那些需要協調整個系統行為的類別（例如日誌記錄器、配置管理器、資料庫連線池）非常有用。

**典型例子與推導：**

想像一個應用程式需要一個記錄日誌的功能。如果每次需要寫日誌時都創建一個新的日誌物件，這不僅會消耗資源，還可能導致日誌文件的寫入衝突或順序混亂。這時，我們需要一個唯一的 `Logger` 實例來處理所有的日誌請求。

**如何實現？**

1.  **私有建構子 (Private Constructor)：** 阻止外部直接透過 `new` 關鍵字創建類別實例。
2.  **靜態實例變數 (Static Instance Variable)：** 儲存類別的唯一實例。
3.  **公共靜態方法 (Public Static Method)：** 提供一個全域的訪問點，用於獲取這個唯一的實例。這個方法通常會檢查實例是否已經存在，如果不存在則創建它，否則直接返回現有的實例。

**Python-like Pseudocode 示例：**

```python
class Logger:
    _instance = None  # 靜態實例變數，初始化為 None

    def __new__(cls):
        # 覆寫 __new__ 方法來控制實例的創建
        if cls._instance is None:
            print("Creating a new Logger instance...")
            cls._instance = super(Logger, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        # 只有在第一次創建實例時才初始化
        if not hasattr(self, '_initialized'): # 避免重複初始化
            print("Logger initialized.")
            self._initialized = True
            self.log_level = "INFO" # 其他初始化屬性

    def log(self, message):
        print(f"[{self.log_level}] {message}")

# --- 客戶端程式碼 ---
logger1 = Logger()
logger1.log("This is the first log message.")

logger2 = Logger()
logger2.log("This is the second log message.")

print(f"Are logger1 and logger2 the same instance? {logger1 is logger2}")

logger1.log_level = "DEBUG" # 改變其中一個實例的屬性

logger2.log("Now log_level is DEBUG.") # 另一個實例也會反映這個改變
```

**輸出：**

```
Creating a new Logger instance...
Logger initialized.
[INFO] This is the first log message.
[INFO] This is the second log message.
Are logger1 and logger2 the same instance? True
[DEBUG] Now log_level is DEBUG.
```

**與相鄰概念的關聯：**

*   **與靜態類別/靜態方法的區別：**
    *   **靜態類別 (或只有靜態方法的類別)：** 通常不能被實例化，所有成員都是靜態的。它不能實現介面（在某些語言中），也不能被多型化。
    *   **單例模式：** 雖然只有一個實例，但它仍然是一個**物件實例**。這意味著它可以實現介面、繼承其他類別、並以多型的方式行為。它擁有物件生命週期，只是這個生命週期被模式所管理。
*   **考量點：**
    *   **執行緒安全 (Thread Safety)：** 在多執行緒環境下，多個執行緒可能同時嘗試創建單例實例，導致創建多個實例。上述 Python 範例的 `__new__` 方法在 CPython GIL (Global Interpreter Lock) 下通常是執行緒安全的，但在其他環境或語言中可能需要額外的同步機制（例如雙重檢查鎖定 `Double-Checked Locking`）。
    *   **延遲初始化 (Lazy Initialization)：** 單例模式通常會實作延遲初始化，即只有當首次需要實例時才創建它，這可以節省資源。

#### 2.2 行為型模式範例：策略模式 (Strategy Pattern)

**核心觀念：**
策略模式 (Strategy Pattern) 允許在運行時選擇演算法。它定義了一系列演算法，將每一個演算法封裝起來，並使它們可以互相替換。策略模式讓演算法的變化獨立於使用它的客戶端。

**典型例子與推導：**

想像一個電子商務網站需要根據不同的促銷活動（例如，滿額打折、買一送一、會員專屬折扣）計算商品的最終價格。如果把所有計算邏輯都寫在一個類別中，會導致這個類別變得臃腫、難以維護和擴展（每次新增一種折扣都需要修改它）。策略模式提供了一個優雅的解決方案。

**如何實現？**

1.  **策略介面/抽象類別 (Strategy Interface/Abstract Class)：** 定義所有具體策略類別必須實現的通用方法。
2.  **具體策略類別 (Concrete Strategy Classes)：** 實現策略介面，提供具體的演算法實作。
3.  **上下文類別 (Context Class)：** 持有一個策略介面的引用，並將客戶端的請求委派給當前設定的策略物件。上下文類別不直接實現演算法，它只知道如何使用策略介面。

**Python-like Pseudocode 示例：**

```python
# 1. 策略介面 (定義所有具體策略必須實現的方法)
class DiscountStrategy:
    def calculate_final_price(self, price):
        raise NotImplementedError("Subclasses must implement this method")

# 2. 具體策略類別 A: 沒有折扣
class NoDiscountStrategy(DiscountStrategy):
    def calculate_final_price(self, price):
        print("Applying no discount.")
        return price

# 2. 具體策略類別 B: 八折優惠
class TwentyPercentOffStrategy(DiscountStrategy):
    def calculate_final_price(self, price):
        print("Applying 20% off discount.")
        return price * 0.8

# 2. 具體策略類別 C: 會員專享九折
class MemberDiscountStrategy(DiscountStrategy):
    def calculate_final_price(self, price):
        print("Applying member 10% off discount.")
        return price * 0.9

# 3. 上下文類別 (使用策略)
class ShoppingCart:
    def __init__(self, discount_strategy: DiscountStrategy):
        self._discount_strategy = discount_strategy

    def set_discount_strategy(self, discount_strategy: DiscountStrategy):
        self._discount_strategy = discount_strategy

    def checkout(self, base_price):
        final_price = self._discount_strategy.calculate_final_price(base_price)
        print(f"Original price: ${base_price:.2f}")
        print(f"Final price after discount: ${final_price:.2f}")
        return final_price

# --- 客戶端程式碼 ---
item_price = 100

# 初始使用無折扣策略
print("--- Scenario 1: No Discount ---")
cart = ShoppingCart(NoDiscountStrategy())
cart.checkout(item_price)

# 切換到八折策略
print("\n--- Scenario 2: 20% Off Discount ---")
cart.set_discount_strategy(TwentyPercentOffStrategy())
cart.checkout(item_price)

# 切換到會員專享九折策略
print("\n--- Scenario 3: Member Discount ---")
cart.set_discount_strategy(MemberDiscountStrategy())
cart.checkout(item_price)
```

**輸出：**

```
--- Scenario 1: No Discount ---
Applying no discount.
Original price: $100.00
Final price after discount: $100.00

--- Scenario 2: 20% Off Discount ---
Applying 20% off discount.
Original price: $100.00
Final price after discount: $80.00

--- Scenario 3: Member Discount ---
Applying member 10% off discount.
Original price: $100.00
Final price after discount: $90.00
```

**與相鄰概念的關聯：**

*   **與工廠模式 (Factory Pattern) 的區別：**
    *   **工廠模式：** 關注物件的**創建**，根據輸入參數返回不同的物件實例。
    *   **策略模式：** 關注物件的**行為**，允許在運行時替換物件所使用的演算法。
    *   它們可以結合使用：例如，一個工廠可以根據某些條件創建並返回不同的策略物件。
*   **與模板方法模式 (Template Method Pattern) 的區別：**
    *   **模板方法模式：** 使用**繼承**。在一個抽象類別中定義一個演算法的骨架（模板方法），將某些步驟延遲到子類別中實現。演算法結構固定，子類別只能改變部分步驟。
    *   **策略模式：** 使用**組合**。將整個演算法封裝在獨立的類別中，並讓上下文物件在運行時選擇使用哪個演算法。它提供了更大的彈性，可以完全替換演算法。

-----

### 3. 設計模式的效益與考量

#### 3.1 設計模式的效益

總結來說，應用設計模式能為軟體開發帶來以下顯著效益：

*   **提高程式碼的可讀性與可維護性：** 遵循標準模式的程式碼結構清晰，易於理解，降低了後期維護的難度。
*   **促進程式碼重用：** 模式抽象出通用設計，鼓勵創建可重用的組件，減少重複開發。
*   **提升系統的彈性與可擴展性：** 模式通常旨在解耦組件，使得系統更易於修改和擴展新功能，而無需大量改動現有程式碼。
*   **提供共同語言，便於團隊溝通：** 團隊成員可以使用模式名稱來高效溝通設計意圖和解決方案，減少歧義。
*   **降低設計風險：** 模式是經過驗證的最佳實踐，應用它們可以避免常見的設計錯誤。

#### 3.2 設計模式的考量

儘管設計模式帶來諸多好處，但在應用時也需謹慎：

*   **並非萬靈丹，過度使用可能增加複雜度：** 並非所有問題都需要設計模式。不恰當或過度使用模式（即「金錢鍍層 Gold Plating」或「過度工程 Over-engineering」）可能會引入不必要的複雜性，反而使程式碼更難理解和維護。
*   **選擇適合的模式而非硬套：** 每個模式都有其適用情境和限制。關鍵在於深入理解問題和模式本身，選擇最符合當前需求的解決方案，而不是為了使用模式而使用。
*   **學習曲線：** 對於不熟悉設計模式的開發者來說，學習和理解它們需要一定的時間和精力。

-----

### 4. 常見錯誤與澄清

在使用設計模式的過程中，開發者常會遇到一些誤解或陷阱。了解這些可以幫助我們更有效地應用模式。

*   **錯誤 1：將設計模式視為程式碼庫**
    *   **澄清：** 設計模式是**抽象的解決方案**和**思考框架**，而非可以直接複製貼上的程式碼。每個專案的情境不同，即使是同一個模式，其具體實作也會有所差異。理解模式背後的原理和意圖遠比背誦其程式碼結構重要。
*   **錯誤 2：過度設計 (Over-engineering) 或 金錢鍍層 (Gold Plating)**
    *   **澄清：** 這是最常見的錯誤之一。開發者有時會為了使用某個「高級」模式而強行將其應用到一個簡單的問題上，導致系統變得過於複雜，增加了不必要的開發和維護成本。遵循 **YAGNI (You Ain't Gonna Need It)** 原則，只在確實需要時才引入模式，從小處著手，逐步重構。
*   **錯誤 3：誤用模式或不理解其適用情境**
    *   **澄清：** 每個設計模式都有其特定的適用情境和解決的問題。如果對模式理解不夠深入，或者錯誤地將其應用於不適合的場景，不僅無法解決問題，反而可能製造新的問題，使得系統更加混亂。例如，在不需要確保唯一實例的場景下使用單例模式，或者在行為替換邏輯非常簡單時仍堅持使用策略模式。
*   **錯誤 4：忽略執行緒安全等非功能性需求**
    *   **澄清：** 許多設計模式，尤其是在創建型模式中，在單執行緒環境下實作可能很簡單，但在多執行緒環境下會面臨執行緒安全問題。例如，單例模式在多執行緒環境下需要額外的同步機制（如鎖）來確保其唯一性。在應用模式時，必須將非功能性需求（如效能、安全性、並行性）納入考量。
*   **錯誤 5：將設計模式視為獨立的個體，而非相互關聯的工具**
    *   **澄清：** 設計模式並非相互獨立，它們經常會協同工作。例如，一個工廠模式可能用於創建不同的策略模式實例，然後將這些策略提供給一個上下文物件。理解模式之間的關聯性，可以幫助我們設計出更強大、更靈活的系統。

-----

### 5. 小練習

#### #### 練習 1：實作延遲初始化與執行緒安全的單例模式

**題目：**
設計一個 `DatabaseConnection` 類別，確保在整個應用程式運行期間只有一個資料庫連線實例。這個實例應該在首次需要時才被創建 (延遲初始化)，並且在多執行緒環境下也能安全運作。

**步驟：**

1.  定義一個 `DatabaseConnection` 類別。
2.  將其建構子設為私有 (在 Python 中，透過覆寫 `__new__` 方法或 `_instance` 變數來實現)。
3.  提供一個公共的靜態方法或屬性來獲取 `DatabaseConnection` 的實例。
4.  實作延遲初始化：實例僅在首次請求時才創建。
5.  確保在多執行緒環境下的執行緒安全。

**詳解 (Python 範例，使用 `threading.Lock` 確保執行緒安全)：**

```python
import threading
import time

class DatabaseConnection:
    _instance = None
    _lock = threading.Lock() # 創建一個鎖來保證執行緒安全

    def __new__(cls):
        # 雙重檢查鎖定 (Double-Checked Locking) 模式的簡化版
        # 確保只有一個執行緒能創建實例
        with cls._lock:
            if cls._instance is None:
                print("--- Creating a new DatabaseConnection instance ---")
                # 模擬耗時的資料庫連線操作
                time.sleep(0.1)
                cls._instance = super(DatabaseConnection, cls).__new__(cls)
                cls._instance._initialized = False # 標記尚未初始化 __init__
        return cls._instance

    def __init__(self):
        # 確保 __init__ 只被執行一次
        if not self._initialized:
            print("--- Initializing DatabaseConnection ---")
            # 實際的資料庫連線參數或資源初始化
            self.connection_string = "mysql://user:pass@host:port/db"
            self._initialized = True
            print(f"Database connected with: {self.connection_string}")

    def execute_query(self, query):
        if self._initialized:
            print(f"Executing query: '{query}' using connection {id(self)}")
        else:
            print("Database connection not properly initialized.")

# --- 測試多執行緒環境下的單例 ---
def client_task(thread_id):
    print(f"Thread {thread_id}: Requesting DatabaseConnection instance...")
    db_conn = DatabaseConnection()
    db_conn.execute_query(f"SELECT data FROM table WHERE id={thread_id}")
    print(f"Thread {thread_id}: Got instance {id(db_conn)}")

threads = []
for i in range(5):
    thread = threading.Thread(target=client_task, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

# 驗證所有執行緒是否都獲取了同一個實例
print("\n--- Verifying instances ---")
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(f"Instance 1 ID: {id(db1)}")
print(f"Instance 2 ID: {id(db2)}")
print(f"Are db1 and db2 the same instance? {db1 is db2}")

```

**解釋：**
*   `_instance` 儲存唯一的實例。
*   `_lock` 是一個 `threading.Lock` 物件，用於同步對 `_instance` 的訪問，防止多個執行緒同時創建實例。
*   `__new__` 方法被覆寫，這是 Python 中創建物件實例的實際入口。我們在其中使用了 `with cls._lock:` 來確保在檢查 `_instance` 並創建它時是原子操作。
*   `__init__` 方法也做了防止重複初始化的處理，因為 `__new__` 返回的可能是已存在的實例，此時 `__init__` 不應再次執行初始化邏輯。

#### #### 練習 2：應用策略模式設計一個折扣計算器

**題目：**
假設你正在開發一個電子商務平台，需要根據不同的促銷活動計算商品的最終價格。請使用策略模式設計一個彈性的折扣計算器，目前有兩種折扣策略：
*   **全額免運 (FreeShippingStrategy)：** 不打折，但免運費 (簡化為不影響商品價格，只打印提示)。
*   **八折優惠 (EightiethDiscountStrategy)：** 價格打八折。
*   **買二送一 (BuyTwoGetOneFreeStrategy)：** 購買三件商品，其中一件免費 (例如，每三件中最便宜的一件免費，這裡簡化為購買兩件以上就總價少一件最便宜商品的價格)。

**步驟：**

1.  定義一個 `DiscountStrategy` 介面 (或抽象類別)，包含一個計算折扣的方法。這個方法將接收商品列表和原始總價。
2.  實作 `FreeShippingStrategy`、`EightiethDiscountStrategy` 和 `BuyTwoGetOneFreeStrategy` 這三個具體策略類別。
3.  創建一個 `ShoppingCart` (購物車) 作為 Context 類別，它持有 `DiscountStrategy` 的實例，並提供一個方法來設定不同的策略。
4.  在客戶端程式碼中，展示如何根據需求切換不同的折扣策略並計算最終價格。

**詳解 (Python 範例)：**

```python
# 1. 策略介面 (定義所有具體策略必須實現的方法)
class DiscountStrategy:
    def calculate_final_price(self, items: list, original_total_price: float) -> float:
        raise NotImplementedError("Subclasses must implement this method")

# 2. 具體策略類別 A: 全額免運 (不影響商品價格)
class FreeShippingStrategy(DiscountStrategy):
    def calculate_final_price(self, items: list, original_total_price: float) -> float:
        print("Discount applied: Free Shipping! (Price remains unchanged)")
        return original_total_price

# 2. 具體策略類別 B: 八折優惠
class EightiethDiscountStrategy(DiscountStrategy):
    def calculate_final_price(self, items: list, original_total_price: float) -> float:
        print("Discount applied: 20% Off!")
        return original_total_price * 0.8

# 2. 具體策略類別 C: 買二送一 (最便宜的一件免費)
class BuyTwoGetOneFreeStrategy(DiscountStrategy):
    def calculate_final_price(self, items: list, original_total_price: float) -> float:
        if len(items) >= 3:
            # 找到最便宜的商品價格
            prices = [item['price'] for item in items]
            min_price = min(prices)
            print(f"Discount applied: Buy 2 Get 1 Free! Deducting {min_price:.2f}.")
            return original_total_price - min_price
        else:
            print("Discount not applicable: Need at least 3 items for Buy 2 Get 1 Free.")
            return original_total_price

# 3. 上下文類別 (購物車，使用策略)
class ShoppingCart:
    def __init__(self, discount_strategy: DiscountStrategy):
        self._discount_strategy = discount_strategy
        self.items = []

    def add_item(self, name: str, price: float):
        self.items.append({'name': name, 'price': price})

    def set_discount_strategy(self, discount_strategy: DiscountStrategy):
        self._discount_strategy = discount_strategy

    def checkout(self):
        original_total_price = sum(item['price'] for item in self.items)
        print(f"\n--- Checking out with items: {[item['name'] for item in self.items]}, Original Total: ${original_total_price:.2f} ---")
        final_price = self._discount_strategy.calculate_final_price(self.items, original_total_price)
        print(f"Final Price: ${final_price:.2f}")
        return final_price

# --- 客戶端程式碼 ---

# 建立購物車，初始設定為免運費策略
cart = ShoppingCart(FreeShippingStrategy())
cart.add_item("Laptop", 1200.00)
cart.add_item("Mouse", 25.00)
cart.checkout()

# 改變策略為八折優惠
cart.set_discount_strategy(EightiethDiscountStrategy())
cart.checkout()

# 改變策略為買二送一，並增加商品數量
cart.add_item("Keyboard", 75.00)
cart.set_discount_strategy(BuyTwoGetOneFreeStrategy())
cart.checkout()

# 測試買二送一但商品不足的情況
print("\n--- Test Buy 2 Get 1 Free with insufficient items ---")
small_cart = ShoppingCart(BuyTwoGetOneFreeStrategy())
small_cart.add_item("Book A", 20.00)
small_cart.add_item("Book B", 15.00)
small_cart.checkout()

```

**解釋：**
*   `DiscountStrategy` 定義了 `calculate_final_price` 介面，規範了所有折扣策略的行為。
*   `FreeShippingStrategy`、`EightiethDiscountStrategy` 和 `BuyTwoGetOneFreeStrategy` 實作了這個介面，各自包含了不同的折扣計算邏輯。
*   `ShoppingCart` 是上下文類別，它不再直接處理複雜的折扣邏輯，而是持有一個 `DiscountStrategy` 物件。當需要計算總價時，它將任務委派給當前設定的策略物件。
*   客戶端程式碼只需創建不同的策略物件，並傳遞給購物車，即可在運行時輕鬆切換不同的折扣計算方式，而無需修改 `ShoppingCart` 類別的內部邏輯，大大提高了系統的彈性和可擴展性。

-----

### 6. 延伸閱讀與參考

深入了解設計模式，推薦閱讀以下經典書籍和線上資源：

*   **Gang of Four (GoF) - "Design Patterns: Elements of Reusable Object-Oriented Software"**
    *   這是設計模式領域的聖經，由 Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides (GoF) 所著。雖然程式碼範例以 C++ 和 Smalltalk 為主，但其模式概念是跨語言通用的。

*   **Refactoring Guru (線上資源)**
    *   一個非常棒的線上學習平台，提供了 GoF 設計模式的詳細解釋、圖示、以及多種程式語言（如 Java, C#, Python, PHP, JavaScript）的範例程式碼。對於初學者來說，是非常友善且實用的資源。
    *   網址：`https://refactoring.guru/design-patterns`

*   **Martin Fowler - "Patterns of Enterprise Application Architecture" (PoEAA)**
    *   這本書提供了在企業級應用程式中常用的更高層次模式，這些模式通常建立在 GoF 模式之上。對於設計大型複雜系統的開發者來說，非常有價值。

*   **Head First Design Patterns**
    *   以一種更生動、易懂的方式解釋設計模式，適合初學者入門。它使用真實世界的例子和幽默的寫作風格，讓學習過程更加有趣。

學習設計模式是一個持續的過程，需要結合實踐和經驗。多閱讀、多思考、多實作，才能真正掌握其精髓。