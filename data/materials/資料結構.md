# 資料結構：基礎概念與應用

## 1. 核心概念與定義

### 什麼是資料結構？

資料結構（Data Structure）是電腦中儲存、組織資料的方式。它定義了資料之間的邏輯關係、儲存方式，以及對這些資料進行操作（例如新增、刪除、修改、查詢）的方法。選擇合適的資料結構，對於演算法的效率至關重要。

-----

#### 核心觀念
想像一個書櫃，你可以有不同的方式來擺放書籍：
- 按照出版年份依序排列（像陣列）
- 只在最上面堆疊新書，取書也從最上面取（像堆疊）
- 讓每本書都連結到下一本書，形成一條鏈子（像鏈結串列）

每種擺放方式都有其優缺點，例如找書的速度、新增/移除書的方便性等。資料結構正是為了有效地管理和處理資料而誕生的「組織方式」。

#### 目的與重要性
- **效率**：提升資料存取、修改、刪除等操作的速度。
- **組織性**：讓資料以更有邏輯的方式儲存，便於理解與管理。
- **資源管理**：優化記憶體使用。

-----

### 抽象資料型態 (ADT) 與資料結構的關係

#### 定義/核心觀念
- **抽象資料型態 (Abstract Data Type, ADT)**：ADT 是一種「概念性」的資料模型，它定義了一組資料的邏輯行為、所能執行的操作，但**不關心**這些操作是如何被實現的。它只說明「做什麼」，而不說明「怎麼做」。
    - 例子：堆疊 (Stack) ADT 定義了 `push` (壓入)、`pop` (彈出) 等操作，它只保證 LIFO（後進先出）的行為。
- **資料結構 (Data Structure)**：資料結構是 ADT 的**具體實現**。它說明了資料是如何被儲存的，以及操作是如何被執行的。它說明「怎麼做」。
    - 例子：堆疊 ADT 可以用陣列（Array）或鏈結串列（Linked List）來實現，這兩種實現方式就是兩種不同的資料結構。

#### 關係
- **ADT 是「規格」或「介面」，資料結構是「實作」**。
- 一個 ADT 可以有多種資料結構來實現。
- 一種資料結構也可以用來實現多個 ADT。

-----

### 如何評估資料結構？：時間複雜度與空間複雜度簡介

#### 定義/核心觀念
為了客觀地評估資料結構的效能，我們需要衡量它在執行操作時所需的資源。

- **時間複雜度 (Time Complexity)**：衡量演算法執行時間與輸入資料量之間的關係。通常使用大 O 符號（Big O Notation）來表示最壞情況下的執行時間成長趨勢。
    - $O(1)$：常數時間，與輸入資料量無關。
    - $O(\log n)$：對數時間。
    - $O(n)$：線性時間，與輸入資料量成正比。
    - $O(n^2)$：平方時間。
    - $O(2^n)$：指數時間。
- **空間複雜度 (Space Complexity)**：衡量演算法執行所需額外記憶體空間與輸入資料量之間的關係。同樣使用大 O 符號表示。

#### 例子
- 在一個有 $N$ 個元素的陣列中，讀取第 $i$ 個元素：
    - 時間複雜度為 $O(1)$ (常數時間)，因為可以直接透過索引計算記憶體位置。
- 在一個有 $N$ 個元素的鏈結串列中，讀取第 $i$ 個元素：
    - 時間複雜度為 $O(N)$ (線性時間)，因為必須從頭部開始循序走訪 $i$ 個節點。

-----

## 2. 典型例子與轉換/推導

### 陣列 (Array)

#### 定義/核心觀念
陣列是一種最基本、最常見的資料結構。它在記憶體中佔用**連續**的空間，用來儲存相同資料型態的元素。每個元素可以透過其在陣列中的**索引 (index)** 直接存取。

#### 特性
- **連續記憶體**：所有元素在記憶體中緊密排列。
- **固定大小**：一旦建立，其大小通常無法改變（除非建立新陣列並複製）。
- **同質性**：通常只能儲存相同資料型態的元素。
- **索引存取**：從 0 或 1 開始編號，可以直接透過索引 $i$ 存取第 $i$ 個元素。

#### 優點
- **隨機存取 (Random Access)**：透過索引，可以在 $O(1)$ 時間內直接存取任何元素。
- **高效利用快取 (Cache Locality)**：由於記憶體連續，CPU 快取利用效率高。

#### 缺點
- **插入/刪除效率低**：在陣列中間插入或刪除元素時，為了保持連續性，需要移動後續所有元素，時間複雜度為 $O(N)$。
- **固定大小**：大小預先確定，若需要儲存更多元素，則必須重新分配更大的記憶體並複製所有元素，這是一個昂貴的操作。

#### 時間複雜度分析
- **存取 (Access)**：$O(1)$
- **搜尋 (Search)**：
    - 最佳情況 (找到第一個元素)：$O(1)$
    - 最壞情況 (找到最後一個元素或不存在)：$O(N)$ (循序搜尋)
- **插入 (Insertion)**：
    - 最佳情況 (插入到末尾，且還有空間)：$O(1)$
    - 最壞情況 (插入到開頭)：$O(N)$
- **刪除 (Deletion)**：
    - 最佳情況 (刪除末尾元素)：$O(1)$
    - 最壞情況 (刪除開頭元素)：$O(N)$

#### 例子
```python
# Python 中的列表 (List) 實際上是動態陣列
my_array = [10, 20, 30, 40, 50]

# 存取元素 (O(1))
print(my_array[2])  # 輸出 30

# 在索引 1 處插入元素 (O(N))
my_array.insert(1, 15)
print(my_array)  # 輸出 [10, 15, 20, 30, 40, 50]

# 刪除索引 3 處的元素 (O(N))
del my_array[3]
print(my_array)  # 輸出 [10, 15, 20, 40, 50]
```

-----

### 鏈結串列 (Linked List)

#### 定義/核心觀念
鏈結串列是一種非連續、動態的資料結構。它由一系列「節點 (Node)」組成，每個節點包含兩部分：
1. **資料 (Data)**：儲存實際的資訊。
2. **指標/參考 (Pointer/Reference)**：指向下一個節點的記憶體位址。

串列的頭部 (Head) 指向第一個節點，而最後一個節點的指標通常指向 `null` (空值)，表示串列的結束。

#### 特性
- **非連續記憶體**：節點可以分散在記憶體的任何位置。
- **動態大小**：可以根據需要動態地增加或減少節點，不受初始大小限制。
- **靈活的插入/刪除**：只需修改少數幾個指標即可完成，無需移動大量元素。

#### 種類 (常見的)
- **單向鏈結串列 (Singly Linked List)**：每個節點只包含一個指向下一個節點的指標。只能單向遍歷。
- **雙向鏈結串列 (Doubly Linked List)**：每個節點包含兩個指標，一個指向前一個節點，一個指向後一個節點。可以雙向遍歷。
- **環狀鏈結串列 (Circular Linked List)**：最後一個節點的指標指向第一個節點，形成一個環。

#### 優點
- **高效的插入/刪除**：在已知欲操作節點或其前一個節點的情況下，時間複雜度為 $O(1)$。
- **動態大小**：記憶體使用靈活，可隨意增減節點。

#### 缺點
- **循序存取 (Sequential Access)**：要存取第 $i$ 個元素，必須從頭部開始循序遍歷 $i$ 個節點，時間複雜度為 $O(N)$。
- **額外記憶體開銷**：每個節點都需要額外的空間來儲存指標。

#### 時間複雜度分析
- **存取 (Access)**：$O(N)$
- **搜尋 (Search)**：$O(N)$
- **插入 (Insertion)**：
    - 在開頭插入：$O(1)$
    - 在中間或結尾插入：$O(N)$ (若不知道前一個節點，需先搜尋)；$O(1)$ (若已知前一個節點)
- **刪除 (Deletion)**：
    - 刪除開頭：$O(1)$
    - 刪除中間或結尾：$O(N)$ (若不知道前一個節點，需先搜尋)；$O(1)$ (若已知前一個節點)

#### 例子 (單向鏈結串列)
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None  # 指向下一個節點的指標

class LinkedList:
    def __init__(self):
        self.head = None  # 鏈結串列的頭部

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

    def insert_after(self, prev_node_data, new_data):
        current = self.head
        while current and current.data != prev_node_data:
            current = current.next

        if current is None:
            print(f"節點 {prev_node_data} 未找到。")
            return

        new_node = Node(new_data)
        new_node.next = current.next
        current.next = new_node

# 建立鏈結串列
my_list = LinkedList()
my_list.append(10)
my_list.append(20)
my_list.append(40)
my_list.print_list()  # 輸出 10 -> 20 -> 40 -> None

# 在 20 之後插入 30 (O(N) 搜尋 + O(1) 插入)
my_list.insert_after(20, 30)
my_list.print_list()  # 輸出 10 -> 20 -> 30 -> 40 -> None
```

-----

### 抽象資料型態 (ADT) - 堆疊 (Stack) 與 佇列 (Queue)

堆疊和佇列是兩種非常常見的抽象資料型態 (ADT)，它們定義了資料存取的基本規則。

#### 堆疊 (Stack)

##### 定義/核心觀念
堆疊是一種**後進先出 (Last-In, First-Out, LIFO)** 的資料結構。想像一疊盤子，你只能在最上面放盤子或取走最上面的盤子。

##### 核心操作
- `push(element)`：將元素添加到堆疊的頂部。
- `pop()`：從堆疊頂部移除並返回元素。
- `peek()` 或 `top()`：返回堆疊頂部的元素，但不移除。
- `isEmpty()`：檢查堆疊是否為空。
- `size()`：返回堆疊中的元素數量。

##### 與陣列/鏈結串列的關係
堆疊 ADT 可以用陣列或鏈結串列來實現：
- **基於陣列的堆疊**：使用陣列作為底層儲存。通常需要處理陣列滿載時的擴容問題。`push` 和 `pop` 操作通常是 $O(1)$ (在不擴容的情況下)。
- **基於鏈結串列的堆疊**：使用鏈結串列作為底層儲存。通常將新元素添加到鏈結串列的頭部 (作為堆疊的頂部)，或從頭部移除元素。`push` 和 `pop` 操作通常是 $O(1)$。

##### 例子
- 程式語言的函數呼叫堆疊 (Call Stack)。
- 瀏覽器的「上一頁/下一頁」功能。
- 運算式求值 (例如，將中綴表達式轉換為後綴表達式)。

-----

#### 佇列 (Queue)

##### 定義/核心觀念
佇列是一種**先進先出 (First-In, First-Out, FIFO)** 的資料結構。想像排隊買票的人群，最先排隊的人最先買到票。

##### 核心操作
- `enqueue(element)`：將元素添加到佇列的尾部 (隊伍後方)。
- `dequeue()`：從佇列的頭部移除並返回元素 (隊伍前方)。
- `peek()` 或 `front()`：返回佇列頭部的元素，但不移除。
- `isEmpty()`：檢查佇列是否為空。
- `size()`：返回佇列中的元素數量。

##### 與陣列/鏈結串列的關係
佇列 ADT 可以用陣列或鏈結串列來實現：
- **基於陣列的佇列**：使用陣列作為底層儲存。可能需要處理「假溢位」問題 (當隊頭元素被移除後，隊列整體前移或使用環狀陣列)。`enqueue` 和 `dequeue` 操作通常是 $O(1)$ (在不擴容/處理假溢位的情況下)。
- **基於鏈結串列的佇列**：使用鏈結串列作為底層儲存。通常在鏈結串列的尾部插入 (`enqueue`)，在頭部移除 (`dequeue`)。`enqueue` 和 `dequeue` 操作通常是 $O(1)$。

##### 例子
- 作業系統的任務排程。
- 印表機的列印佇列。
- 網路中的緩衝區。

-----

## 3. 與相鄰概念的關聯

### 資料結構與演算法的關係

#### 核心觀念
資料結構和演算法是電腦科學的兩塊基石，它們之間存在著緊密的共生關係：
- **演算法依賴於資料結構**：演算法是解決問題的步驟，它需要對資料進行操作。資料結構提供了組織和儲存這些資料的方式，影響了演算法設計的效率和可行性。一個高效的演算法往往需要選擇或設計一個合適的資料結構。
- **資料結構影響演算法的效率**：同一個問題，使用不同的資料結構，可能導致演算法的時間複雜度和空間複雜度差異巨大。例如，在排序一個大型資料集時，選擇陣列或鏈結串列作為基礎，會直接影響排序演算法的實作和效能。
- **好的演算法往往伴隨著好的資料結構**：優秀的軟體設計通常是資料結構和演算法兩者優化的結果。

#### 例子
- **搜尋問題**：
    - 若資料儲存在**無序陣列**中，只能用循序搜尋 ($O(N)$)。
    - 若資料儲存在**有序陣列**中，可以用二分搜尋 ($O(\log N)$)。
    - 若資料儲存在**雜湊表 (Hash Table)** 中，平均搜尋時間可達 $O(1)$。
這說明了資料結構的選擇對演算法效率的巨大影響。

-----

### 資料結構在軟體開發中的應用

#### 核心觀念
資料結構是所有軟體系統的基石，無論是小型應用程式還是大型分散式系統，都離不開資料結構。

#### 應用範疇
- **作業系統**：任務排程 (佇列、優先權佇列)、記憶體管理 (鏈結串列、樹)。
- **資料庫**：索引 (B-樹、B+樹)、儲存記錄 (雜湊表、鏈結串列)。
- **編譯器**：符號表 (雜湊表、樹)、語法分析 (堆疊)。
- **網路**：路由表 (圖、雜湊表)、封包緩衝 (佇列)。
- **圖形圖像處理**：圖像表示 (陣列、矩陣)、幾何結構 (樹、圖)。
- **人工智慧**：知識表示 (圖、樹)、搜尋演算法 (優先權佇列)。
- **遊戲開發**：場景管理 (四叉樹、八叉樹)、路徑尋找 (圖)。

-----

### ADT 與介面設計

#### 核心觀念
ADT 的概念與軟體工程中的「介面 (Interface)」設計理念高度契合。
- **抽象性**：ADT 隱藏了底層實作細節，只暴露必要的操作。這使得使用者可以專注於「做什麼」，而不必關心「怎麼做」。
- **模組化**：透過定義清晰的 ADT 介面，不同的模組可以獨立開發，降低耦合性。
- **可替換性**：只要遵循 ADT 介面，底層的資料結構實現可以隨時替換，而不會影響上層的程式碼。例如，一個堆疊的實作可以從陣列切換到鏈結串列，只要 `push` 和 `pop` 等方法的行為保持一致，使用堆疊的程式碼就不需要修改。

#### 例子
在 Java 或 C# 等語言中，`List` 是一個介面 (ADT)，而 `ArrayList` (基於陣列) 和 `LinkedList` (基於鏈結串列) 是它的兩種不同實現。程式碼可以宣告 `List<String> myList = new ArrayList<String>();` 或 `List<String> myList = new LinkedList<String>();`，之後對 `myList` 的操作（如 `add`, `remove`）無需關心底層是哪種實現，因為它們都遵循 `List` 介面定義的行為。

-----

## 4. 進階內容 (簡介)

除了基礎的陣列、鏈結串列、堆疊和佇列，還有許多更複雜和強大的資料結構，它們解決了特定領域的更複雜問題。

#### 樹 (Tree)
- **概念**：一種分層的非線性資料結構，由節點和連接節點的邊組成，具有根節點、子節點、父節點等關係。
- **應用**：檔案系統、資料庫索引 (B-樹、B+樹)、表達式樹、決策樹、二元搜尋樹 (Binary Search Tree) 等。

#### 圖 (Graph)
- **概念**：一種由頂點 (Vertex) 和邊 (Edge) 組成的非線性資料結構，用於表示物件之間的複雜關係。
- **應用**：社交網絡、地圖導航、路由演算法、網頁連結結構等。

#### 雜湊表 (Hash Table / Hash Map)
- **概念**：通過雜湊函數將鍵 (Key) 映射到儲存位置，實現快速的鍵值對存取。
- **應用**：資料庫索引、快取、符號表、頻率計數等。

這些進階資料結構通常是基於前面介紹的基礎資料結構（如陣列和鏈結串列）來構建的。例如，樹的節點通常是透過指標（類似鏈結串列的節點）連接起來的。

-----

## 5. 常見錯誤與澄清

### 誤將 ADT 與資料結構混淆

#### 常見錯誤
「堆疊是一個陣列」或「鏈結串列是一種 ADT」。

#### 澄清
- **堆疊 (Stack)** 和 **佇列 (Queue)** 是**抽象資料型態 (ADT)**，它們定義了一組行為和操作規則（例如堆疊的 LIFO），但沒有規定如何實現。
- **陣列 (Array)** 和 **鏈結串列 (Linked List)** 是**資料結構**，它們是具體的資料組織方式，可以用來實現各種 ADT。
- 堆疊可以透過陣列實現，也可以透過鏈結串列實現。同樣，佇列也可以透過陣列或鏈結串列實現。資料結構是實現 ADT 的「工具」。

-----

### 忽略時間/空間複雜度分析的重要性

#### 常見錯誤
只關注程式碼是否能運行，而不分析其效率；認為對於小規模資料集，複雜度分析不重要。

#### 澄清
- **規模效應**：對於小規模資料，不同演算法或資料結構的性能差異可能不明顯。但當資料量 `N` 增大時，`O(N)` 和 `O(N^2)` 的差異會變得天文數字般巨大。
- **資源限制**：在嵌入式系統、行動裝置或高效能計算中，記憶體和處理器資源寶貴，不佳的複雜度會導致程式崩潰或運行緩慢。
- **可擴展性**：一個設計良好的系統應該能夠隨著資料量的增長而優雅地擴展。複雜度分析是預測系統行為和確保其可擴展性的關鍵工具。
- **面試與專業能力**：在電腦科學領域，能夠分析和討論時間/空間複雜度是衡量一個工程師基本功的重要指標。

-----

### C/C++ 中的指標與記憶體管理錯誤 (針對鏈結串列)

#### 常見錯誤
在使用 C/C++ 實現鏈結串列時，經常會遇到：
1. **空指標解引用 (Dereferencing Null Pointer)**：試圖訪問 `null` 指標所指向的記憶體。
2. **記憶體洩漏 (Memory Leak)**：動態分配的記憶體在使用後沒有被釋放。
3. **野指標 (Dangling Pointer)**：指向已經被釋放的記憶體區域的指標。

#### 澄清
- **檢查空指標**：在解引用任何指標之前，務必檢查它是否為 `null`。例如，遍歷鏈結串列時，循環條件應該是 `current != NULL`。
- **配對 `malloc/new` 與 `free/delete`**：每次使用 `malloc` (C) 或 `new` (C++) 分配記憶體後，當不再需要該記憶體時，必須使用 `free` 或 `delete` 將其釋放。對於鏈結串列，在刪除節點或銷毀整個串列時，要確保每個節點的記憶體都被釋放。
- **避免野指標**：當一個節點被 `delete` 或 `free` 後，應該將指向它的所有指標設置為 `NULL`，以避免後續誤用。
- **使用智慧指標 (Smart Pointers)**：在 C++ 中，`std::unique_ptr` 或 `std::shared_ptr` 等智慧指標可以自動管理記憶體生命週期，大大減少記憶體洩漏和野指標問題。

-----

## 6. 小練習

### 小練習 1: 資料結構的選擇

#### 題目
假設您正在開發一個應用程式，需要儲存一系列的學生成績。請分析以下兩種情境，並說明您會選擇哪種資料結構（陣列或鏈結串列），以及選擇的原因。

1. **情境 A: 學生成績管理系統**
   - 學生人數固定約 100 人，每年新增人數極少，但會頻繁地根據學號查詢特定學生的成績。
   - 很少有學生成績的插入或刪除操作（例如，只有在學生轉學或退學時）。

2. **情境 B: 考卷作答記錄**
   - 系統需要記錄學生在線上測驗中，每道題目的作答時間。題目數量不固定，學生答題時會動態新增記錄，且每次批改只從頭開始依序處理最新的 N 份記錄。
   - 舊的記錄可能會被定期清理。

#### 詳解

##### 情境 A: 學生成績管理系統
1.  **選擇的資料結構**：**陣列 (Array)**
2.  **原因分析**：
    *   **查詢效率高**：情境 A 提到「頻繁地根據學號查詢特定學生的成績」。如果學號能對應到陣列索引（例如，學號 1001 儲存在索引 0，學號 1002 儲存在索引 1），則陣列的隨機存取特性允許在 $O(1)$ 時間內直接透過索引找到成績。即使需要搜尋學號（如果學號不直接對應索引），若陣列保持有序，也可以使用二分搜尋在 $O(\log N)$ 時間內完成。
    *   **插入/刪除頻率低**：情境 A 表示「很少有學生成績的插入或刪除操作」。陣列在中間插入/刪除元素效率較低 ($O(N)$)，但由於此操作不頻繁，其缺點不會構成主要問題。
    *   **固定大小/預估大小**：學生人數「固定約 100 人」，陣列的固定大小特性可以被接受，因為可以預先分配足夠的空間。
    *   **記憶體利用率**：陣列的記憶體連續性有助於快取利用，進一步提高查詢效率。

##### 情境 B: 考卷作答記錄
1.  **選擇的資料結構**：**鏈結串列 (Linked List)** (特別是為了快速新增和從頭部處理)
2.  **原因分析**：
    *   **動態新增記錄**：情境 B 提到「學生答題時會動態新增記錄，且題目數量不固定」。鏈結串列的動態特性使其可以輕鬆地增加或刪除節點，無需擔心記憶體重新分配和複製的問題，插入操作（特別是插入到頭部或尾部）效率高 ($O(1)$)。
    *   **高效插入/刪除**：如果作答記錄可以以先進先出的方式處理（像佇列），那麼將新記錄添加到鏈結串列尾部（或頭部，取決於設計）和從鏈結串列頭部移除記錄，其時間複雜度均為 $O(1)$。這非常適合「批改只從頭開始依序處理最新的 N 份記錄」和「舊的記錄可能會被定期清理」的需求。
    *   **不頻繁的隨機存取**：此情境沒有提及需要頻繁地隨機存取中間的記錄，主要是「從頭開始依序處理」。鏈結串列的循序存取效率 ($O(N)$) 在這種情況下是可以接受的。

-----

### 小練習 2: 單向鏈結串列的插入操作

#### 題目
請描述在一個**單向鏈結串列**中，如何在給定一個現有節點（稱之為 `target_node`）的**後面**插入一個新節點的步驟，並概念性地繪製其指標變化。

#### 詳解

假設我們有一個單向鏈結串列，以及一個已經存在的節點 `target_node`，我們想在 `target_node` 的後面插入一個新的節點 `new_node`。

1.  **初始狀態**：
    ```
    ... -> [target_node] -> [next_node] -> ...
             ^                 ^
             |                 |
             target_node.next  next_node 的位址
    ```

2.  **步驟描述**：

    *   **步驟 1: 建立新節點**
        *   首先，建立一個新的節點 `new_node`，並將其資料部分設定為所需的值。它的 `next` 指標此時可以為 `null` 或未定義。
        ```
        [new_node]
        ```

    *   **步驟 2: 讓新節點指向 `target_node` 的下一個節點**
        *   將 `new_node` 的 `next` 指標指向 `target_node` 原本指向的下一個節點。這樣 `new_node` 就「接上」了 `target_node` 後面的部分串列。
        *   操作：`new_node.next = target_node.next`
        ```
                               +---------------------+
                               |                     |
        ... -> [target_node] -> [next_node] -> ...   |
                 ^                                   |
                 |                                   |
                 target_node.next                    |
                                                     |
               [new_node] <--------------------------+
               (new_node.next)
        ```

    *   **步驟 3: 讓 `target_node` 指向新節點**
        *   現在，將 `target_node` 的 `next` 指標更新，使其指向 `new_node`。
        *   操作：`target_node.next = new_node`
        ```
        ... -> [target_node] -> [new_node] -> [next_node] -> ...
                 ^                   ^             ^
                 |                   |             |
                 target_node.next    new_node.next next_node 的位址
        ```

3.  **時間複雜度**：
    *   此操作的時間複雜度為 $O(1)$，因為只需要修改兩個指標，無論鏈結串列的長度如何。前提是我們已經獲得了 `target_node` 的參考。如果需要先搜尋 `target_node`，則搜尋部分的時間複雜度為 $O(N)$。

-----

## 7. 延伸閱讀/參考

-   **經典教材**：
    *   "Introduction to Algorithms" by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein (通常簡稱 CLRS)。這是演算法和資料結構領域的權威教材。
    *   "Data Structures and Algorithms in Java" by Michael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser。提供 Java 實現。
    *   "Algorithms, Part I & Part II" by Robert Sedgewick and Kevin Wayne。Princeton 大學的經典課程，有配套書籍和線上課程。

-   **線上學習資源**：
    *   **Coursera / edX**：許多大學在這些平台上提供了免費或付費的資料結構和演算法課程。
    *   **LeetCode / HackerRank**：提供大量的演算法和資料結構練習題，是提升實戰能力的絕佳平台。
    *   **GeeksforGeeks**：一個非常全面的計算機科學知識庫，包含大量的資料結構和演算法教程及範例。

-   **相關主題**：
    *   **演算法分析**：深入理解大 O 符號、遞迴關係等。
    *   **遞迴**：許多樹和圖的演算法都使用遞迴。
    *   **雜湊函數**：理解雜湊表效率的關鍵。
    *   **平衡二元搜尋樹 (Balanced Binary Search Trees)**：如 AVL 樹、紅黑樹，提供 $O(\log N)$ 的所有操作。
    *   **堆積 (Heap)**：實現優先權佇列的有效資料結構。