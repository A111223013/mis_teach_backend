# 輸入/輸出 (I/O) 系統

輸入/輸出 (I/O) 系統是電腦科學中一個基礎且關鍵的概念，它描述了電腦如何與外部世界以及其內部不同組件進行數據交換。理解 I/O 系統的運作機制，對於設計高效能、高可靠性的電腦系統至關重要。

-----

### 1) 核心概念/定義

#### 什麼是輸入/輸出 (I/O)？
*   **定義：** 輸入/輸出 (Input/Output, 簡稱 I/O) 是指電腦系統與外部世界（例如使用者、其他電腦、周邊設備）或其內部不同組件（例如記憶體與儲存裝置）之間進行數據交換的過程。
*   **核心觀念：**
    *   **輸入 (Input)：** 數據從外部世界進入電腦系統的過程。例如，鍵盤輸入文字、滑鼠移動、麥克風錄音、從硬碟讀取檔案、從網路接收數據。
    *   **輸出 (Output)：** 數據從電腦系統傳送至外部世界的過程。例如，螢幕顯示圖像、印表機列印文件、揚聲器播放聲音、將數據寫入硬碟、透過網路發送數據。

#### I/O 裝置 (I/O Devices)
*   **定義：** 允許系統進行 I/O 操作的硬體組件。這些裝置作為電腦與外部環境之間的橋樑。
*   **分類：**
    *   **輸入裝置：** 僅用於將數據輸入電腦。範例：鍵盤、滑鼠、麥克風、掃描器、網路攝影機。
    *   **輸出裝置：** 僅用於將數據從電腦輸出。範例：顯示器、印表機、揚聲器、投影機。
    *   **輸入/輸出兩用裝置：** 既可以輸入也可以輸出數據。範例：觸控螢幕、網路卡 (Network Interface Card, NIC)、磁碟機 (硬碟、SSD)、USB 隨身碟。

#### I/O 埠 (I/O Ports)
*   **定義：** I/O 埠是 CPU 或主記憶體與 I/O 裝置之間進行數據交換的介面點或位址。它們是系統硬體設計中預留的特定位址空間，允許 CPU 透過這些位址與 I/O 裝置的控制器進行通訊。
*   **核心觀念：**
    *   **位址空間：** 每個 I/O 埠都有一個唯一的位址，CPU 可以透過讀取或寫入這些位址來控制 I/O 裝置或讀取其狀態/數據。
    *   **控制暫存器 (Control Register)：** CPU 寫入此暫存器以發送指令給 I/O 裝置（例如，啟動操作、設定模式）。
    *   **狀態暫存器 (Status Register)：** CPU 讀取此暫存器以獲取 I/O 裝置的當前狀態（例如，是否忙碌、是否完成操作、是否有錯誤）。
    *   **數據暫存器 (Data Register)：** 用於實際的數據傳輸，CPU 可以從此讀取輸入數據或寫入輸出數據。

#### I/O 控制器 (I/O Controllers / Device Controllers)
*   **定義：** I/O 控制器是位於 I/O 裝置本身或主機板上的一個特殊用途處理器（通常是微控制器），負責管理一個或多個特定 I/O 裝置的低階操作。它充當 I/O 裝置與系統匯流排之間的介面。
*   **核心觀念：**
    *   **硬體抽象：** I/O 控制器將複雜的裝置特定操作（如磁碟的尋道、旋轉、讀寫磁頭控制）抽象化，為 CPU 提供一個更簡單的介面。
    *   **數據緩衝 (Buffering)：** I/O 控制器通常包含內部緩衝區，用於暫存 I/O 數據，以匹配裝置與系統匯流排之間的速度差異。
    *   **錯誤檢測與修正：** 許多控制器具有內建的錯誤檢測（如奇偶校驗、CRC）和一定程度的錯誤修正能力。
    *   **中斷處理：** 當 I/O 操作完成或發生錯誤時，控制器會產生一個中斷訊號，通知 CPU 處理。

-----

### 2) 典型例子與轉換/推導

#### 鍵盤輸入流程
當使用者在鍵盤上按下一個鍵時，會觸發一系列的 I/O 操作：
1.  **按鍵偵測：** 鍵盤內部電路偵測到按鍵閉合，產生一個唯一的「掃描碼 (scan code)」。
2.  **傳送掃描碼：** 鍵盤控制器將這個掃描碼透過串列或 USB 介面傳送給電腦主機的 I/O 埠。
3.  **I/O 埠接收：** 主機上的鍵盤控制器（通常是晶片組的一部分）接收掃描碼，並將其存入其內部數據暫存器。
4.  **發送中斷：** 鍵盤控制器發出一個硬體中斷訊號給 CPU。
5.  **CPU 中斷處理：** CPU 停止當前任務，跳轉到中斷服務常式 (Interrupt Service Routine, ISR)。作業系統的鍵盤驅動程式會執行 ISR。
6.  **讀取數據：** 鍵盤驅動程式從 I/O 埠的數據暫存器讀取掃描碼。
7.  **掃描碼轉換：** 驅動程式將掃描碼轉換為可識別的字符代碼（例如 ASCII 或 Unicode）。
8.  **數據傳遞：** 轉換後的字符數據被傳遞到作業系統的核心緩衝區，最終由等待輸入的應用程式接收。

#### 顯示器輸出流程
當應用程式想要在螢幕上顯示內容時，流程如下：
1.  **繪製請求：** 應用程式（例如瀏覽器、遊戲）調用圖形 API (如 DirectX, OpenGL, Vulkan) 來繪製圖像。
2.  **數據準備：** 圖形驅動程式將應用程式的繪製指令轉換為顯示卡能理解的指令，並將像素數據寫入顯示卡的記憶體（稱為「影格緩衝區, Frame Buffer」）。
3.  **顯示控制器讀取：** 顯示控制器（顯示卡上的一個晶片）以固定的頻率（刷新率）從影格緩衝區讀取像素數據。
4.  **訊號轉換：** 顯示控制器將讀取的數位像素數據轉換為顯示器可以識別的類比訊號（VGA）或數位訊號（DVI, HDMI, DisplayPort）。
5.  **傳送訊號：** 轉換後的訊號透過連接線傳送給顯示器。
6.  **顯示：** 顯示器接收訊號，並將對應的像素點亮，從而呈現出圖像。

#### 磁碟 I/O 流程 (以讀取檔案為例)
1.  **應用程式請求：** 應用程式發出讀取檔案的請求（例如 `read()` 系統呼叫）。
2.  **作業系統處理：** 作業系統的檔案系統層接收請求，確定檔案在磁碟上的物理位置（磁軌、磁區）。
3.  **發送 I/O 請求：** 作業系統將讀取請求發送給磁碟控制器。此請求包含要讀取的數據量、磁碟位址和數據應寫入主記憶體的位置。
4.  **磁碟控制器執行：** 磁碟控制器接收請求，並執行低階操作：
    *   移動讀寫頭到目標磁軌（尋道）。
    *   等待磁碟旋轉，使目標磁區位於讀寫頭下方（旋轉延遲）。
    *   啟動讀取機制，從磁碟表面讀取數據。
5.  **數據傳輸 (DMA)：** 磁碟控制器通常透過 DMA (Direct Memory Access) 機制，直接將讀取的數據傳輸到主記憶體中作業系統指定的緩衝區，而無需 CPU 介入。
6.  **中斷通知：** 數據傳輸完成後，磁碟控制器向 CPU 發送一個中斷訊號。
7.  **CPU 中斷處理：** CPU 執行中斷服務常式，通知作業系統 I/O 操作已完成。
8.  **數據返回：** 作業系統將數據從緩衝區傳遞給等待的應用程式。

#### I/O 操作模式
系統與 I/O 裝置互動主要有三種模式：

1.  **程式化 I/O (Programmed I/O, PIO)：**
    *   **原理：** CPU 透過不斷地讀取 I/O 裝置的狀態暫存器來「輪詢 (polling)」裝置，直到裝置準備好接收數據或有數據可供讀取。數據傳輸也由 CPU 逐字元或逐字節地進行。
    *   **優點：** 實現簡單，不需要複雜的硬體支持。
    *   **缺點：** CPU 必須不斷地等待 I/O 裝置，造成 CPU 時間的巨大浪費，特別是對於慢速 I/O 裝置，效率極低。
    *   **應用：** 早期簡單系統或特定控制器初始化。

2.  **中斷驅動 I/O (Interrupt-Driven I/O)：**
    *   **原理：** CPU 不再輪詢 I/O 裝置。當 I/O 裝置完成操作、準備好傳輸數據或發生錯誤時，它會發出一個中斷訊號給 CPU。CPU 接收到中斷後，會暫停當前任務，轉去執行對應的中斷服務常式來處理 I/O 事件。
    *   **優點：** 顯著提高了 CPU 利用率，CPU 在 I/O 裝置忙碌時可以執行其他任務。
    *   **缺點：** 每次數據傳輸（例如一個字元或一個數據塊）仍需要 CPU 介入，進行上下文切換來處理中斷，對於高速、大批量的數據傳輸仍然效率不高。
    *   **應用：** 鍵盤、滑鼠等低速裝置的 I/O。

3.  **直接記憶體存取 (Direct Memory Access, DMA)：**
    *   **原理：** 為了進一步解放 CPU，引入了 DMA 控制器。在 DMA 模式下，CPU 只需要初始化 DMA 控制器（告訴它數據的來源、目的地、長度以及傳輸方向），然後 DMA 控制器就直接在 I/O 裝置和主記憶體之間傳輸數據，而無需 CPU 介入。數據傳輸完成後，DMA 控制器會向 CPU 發送一個中斷。
    *   **優點：** 極大地提高了數據傳輸效率，CPU 在 DMA 傳輸數據的同時可以執行其他任務，實現了 I/O 與 CPU 的並行操作。
    *   **缺點：** 需要專門的 DMA 控制器硬體支持，實現相對複雜。DMA 操作可能會與 CPU 爭用記憶體匯流排。
    *   **應用：** 磁碟機、網路卡、顯示卡等高速、大批量數據傳輸的裝置。

-----

### 3) 與相鄰概念的關聯

#### 與 CPU 的關聯
*   **指令與控制：** CPU 是 I/O 操作的發起者和管理者。它透過執行特殊的 I/O 指令（如 `IN`, `OUT`）或記憶體映射 I/O 來啟動和控制 I/O 裝置。
*   **中斷處理：** I/O 裝置透過中斷機制與 CPU 溝通，CPU 負責響應和處理這些中斷。
*   **效能影響：** I/O 操作的速度直接影響 CPU 的利用率和系統的整體效能。若 I/O 過慢，CPU 可能會長時間等待 I/O 完成而處於閒置狀態；若 I/O 過快，CPU 可能成為處理數據的瓶頸。

#### 與記憶體的關聯
*   **數據緩衝：** 記憶體常用作 I/O 數據的臨時緩衝區。輸入數據會先存入記憶體，輸出數據則從記憶體中取出。
*   **DMA 目標：** DMA 控制器直接在 I/O 裝置與主記憶體之間傳輸數據，主記憶體是 DMA 操作的直接目標。
*   **記憶體映射 I/O (Memory-Mapped I/O)：**
    *   **原理：** 將 I/O 埠和裝置的控制暫存器映射到主記憶體位址空間的一部分。CPU 可以使用普通的記憶體讀寫指令來訪問 I/O 裝置，而無需特殊的 I/O 指令。
    *   **優點：** 簡化了 CPU 指令集，所有記憶體相關的尋址模式都可以用於 I/O 操作。
    *   **缺點：** I/O 裝置會佔用一部分記憶體位址空間，降低了可供程式使用的記憶體容量。高速緩存可能會緩存 I/O 暫存器的值，導致數據不一致問題（需要特別處理如「非緩存區域」）。
*   **埠映射 I/O (Port-Mapped I/O / Isolated I/O)：**
    *   **原理：** I/O 埠有獨立的位址空間，與主記憶體位址空間分開。CPU 需要使用專門的 I/O 指令（例如 x86 架構的 `IN` 和 `OUT` 指令）來訪問這些埠。
    *   **優點：** I/O 位址空間與記憶體位址空間分離，不會減少程式可用的記憶體容量。
    *   **缺點：** 需要額外的 I/O 指令集，且 I/O 操作通常不能利用記憶體的一些高級特性（如緩存）。
    *   **應用：** 許多傳統 PC 架構（如 x86）對某些裝置（如鍵盤、印表機）仍使用埠映射 I/O。

#### 與作業系統的關聯
*   **抽象層：** 作業系統為應用程式提供 I/O 系統呼叫，將底層複雜的硬體細節抽象化。應用程式不需要直接操作硬體。
*   **裝置驅動程式 (Device Drivers)：** 作業系統的核心組件，專門負責與特定 I/O 硬體裝置進行通訊。驅動程式負責接收來自作業系統的通用 I/O 請求，並將其轉換為裝置特定的控制指令。
*   **I/O 排程：** 作業系統管理和排程多個應用程式發出的 I/O 請求，以優化系統的吞吐量和響應時間。
*   **錯誤處理與保護：** 作業系統負責檢測和處理 I/O 錯誤，並確保不同程式之間的 I/O 訪問不會互相干擾，提供安全性。

#### 與匯流排 (Bus) 的關聯
*   **數據傳輸路徑：** 匯流排是 I/O 裝置、I/O 控制器、CPU 和記憶體之間傳輸數據和控制訊號的公共通路。
*   **系統匯流排 (System Bus)：** 連接 CPU、主記憶體和高性能 I/O 裝置（透過橋接器）。
*   **I/O 匯流排：** 專為連接多種 I/O 裝置設計，如 PCI (Peripheral Component Interconnect)、PCI Express (PCIe)、USB (Universal Serial Bus)、SATA (Serial Advanced Technology Attachment) 等。這些匯流排定義了數據傳輸的協定和電氣特性。

-----

### 4) 進階內容

#### I/O 虛擬化 (I/O Virtualization)
在虛擬化環境中，當多個虛擬機器 (VM) 運行在同一台實體主機上時，如何有效地共享和管理有限的實體 I/O 裝置是一個挑戰。
*   **目的：** 讓每個 VM 都認為自己擁有獨立的 I/O 裝置，同時高效地利用實體資源。
*   **主要技術：**
    *   **I/O 裝置模擬 (Emulation)：** 虛擬化層 (Hypervisor) 模擬實體 I/O 裝置的行為。VM 內部運行標準的裝置驅動程式，這些驅動程式的操作被 Hypervisor 截獲並轉換為對實際硬體的操作。
        *   **優點：** 易於實現，VM 無需修改。
        *   **缺點：** 效能損耗大，因為每一步 I/O 都需要 Hypervisor 介入。
    *   **半虛擬化 (Para-virtualization)：** VM 內部安裝特別設計的「半虛擬化驅動程式」，這些驅動程式意識到自己運行在虛擬化環境中，並直接透過 Hypercall (Hypervisor 呼叫) 與 Hypervisor 進行 I/O 通訊。
        *   **優點：** 效能優於模擬，減少了 Hypervisor 的介入。
        *   **缺點：** VM 的作業系統需要修改（安裝專用驅動程式）。
    *   **直接 I/O (Passthrough / Direct I/O)：** 將一個實體 I/O 裝置專門分配給某個 VM 使用。VM 可以直接訪問和控制該裝置，就像運行在裸機上。通常透過 IOMMU (I/O Memory Management Unit) 技術實現。
        *   **優點：** 提供接近實體機的 I/O 效能。
        *   **缺點：** 裝置無法在多個 VM 間共享，每個專用裝置都需要一個實體硬體。
    *   **單根 I/O 虛擬化 (Single Root I/O Virtualization, SR-IOV)：** 允許一個實體 PCIe 裝置以硬體方式劃分為多個「虛擬功能 (Virtual Functions, VFs)」，每個 VF 可以直接分配給一個 VM。多個 VM 可以同時共享一個實體裝置的不同 VF，且效能接近直接 I/O。
        *   **優點：** 高效能，多 VM 共享單一實體裝置。
        *   **缺點：** 需要 I/O 裝置和 Hypervisor 的硬體和軟體支持。

#### 磁碟 I/O 排程 (I/O Scheduling)
作業系統為了優化磁碟（或類似的隨機存取裝置）的讀寫效能，會對待處理的 I/O 請求進行排程，以減少讀寫頭的移動距離和次數。
*   **目標：** 提高磁碟吞吐量，減少平均響應時間，確保公平性。
*   **常見演算法：**
    *   **FIFO (First-In, First-Out)：** 先進先出。按照請求到達的順序處理。
        *   **優點：** 實現簡單，公平。
        *   **缺點：** 無法優化磁頭移動，可能導致大量不必要的移動。
    *   **SSTF (Shortest Seek Time First)：** 最短尋道時間優先。總是選擇離當前讀寫頭位置最近的請求。
        *   **優點：** 最小化總尋道時間，吞吐量高。
        *   **缺點：** 可能導致「飢餓 (starvation)」，即遠離讀寫頭的請求可能一直得不到服務。
    *   **SCAN (Elevator Algorithm)：** 電梯演算法。讀寫頭從一端移動到另一端，沿途服務所有請求，然後反向移動，再次服務所有請求。
        *   **優點：** 避免飢餓，提供較好的吞吐量和響應時間。
        *   **缺點：** 剛從磁頭掃過的方向上的新請求需要等待磁頭到達另一端並折返。
    *   **C-SCAN (Circular SCAN)：** 循環掃描。讀寫頭只沿一個方向（例如從 0 到最大磁軌）服務請求，到達末端後，立即返回 0 磁軌，不服務反向的請求。
        *   **優點：** 比 SCAN 更公平，響應時間分佈更均勻。
        *   **缺點：** 仍然有不必要的返回動作。
    *   **LOOK / C-LOOK：** SCAN 和 C-SCAN 的變種。讀寫頭只移動到最遠的請求處就折返，而不是一直移動到磁碟的兩端。

#### 緩衝與快取 (Buffering and Caching)
*   **緩衝 (Buffering)：**
    *   **目的：** 用於彌補 I/O 裝置與 CPU/記憶體之間的速度差異，或處理數據傳輸粒度不匹配的問題。
    *   **原理：** 在數據的生產者和消費者之間設置一個臨時的儲存區域（緩衝區）。生產者將數據寫入緩衝區，消費者從緩衝區讀取數據。
    *   **範例：** 從磁碟讀取數據時，作業系統會一次讀取一大塊數據放入緩衝區，應用程式再從緩衝區中逐字元讀取。這樣可以減少磁碟 I/O 的次數。網路數據包的接收與發送也大量使用緩衝。
*   **快取 (Caching)：**
    *   **目的：** 利用數據的「局部性原理 (Locality of Reference)」（時間局部性：最近訪問的數據很可能再次訪問；空間局部性：訪問某個數據後，其附近的數據也很可能被訪問），將近期或常用數據複製到存取速度更快的儲存層次，以減少對較慢 I/O 裝置的訪問次數。
    *   **原理：** 當數據被請求時，首先檢查快取。如果數據在快取中（快取命中），則直接從快取中讀取，速度快。如果不在（快取未命中），則從原始慢速儲存裝置中讀取，同時將數據複製一份到快取中，以便將來使用。
    *   **範例：** CPU 緩存 (Cache L1/L2/L3)、磁碟快取（作業系統的頁快取）、Web 瀏覽器快取。
*   **緩衝與快取的區別：**
    *   **主要功能：** 緩衝主要用於解決速度匹配和批量傳輸問題；快取主要用於提高訪問速度，減少對慢速介質的重複訪問。
    *   **數據保留：** 緩衝中的數據通常是暫時的，一旦被消費就可能丟棄；快取中的數據會被保留，以備將來重新訪問。
    *   **演算法：** 快取需要更複雜的置換演算法（如 LRU, LFU 等）來決定哪些數據應該被替換。緩衝通常只需要 FIFO。

-----

### 5) 常見錯誤與澄清

#### 誤區一：I/O 都是慢的，因此不值得優化。
*   **澄清：** 雖然相對於 CPU 的運算速度，大多數 I/O 裝置確實較慢，但這並不意味著 I/O 不重要或不值得優化。
    *   **現代高速 I/O：** NVMe SSD、100GbE 網路卡等現代 I/O 裝置的速度已非常可觀，甚至可能成為整個系統的瓶頸。
    *   **效能瓶頸：** 在許多應用中（如資料庫、Web 伺服器），I/O 經常是限制系統整體效能的主要瓶頸。優化 I/O 可以顯著提升應用程式的響應速度和吞吐量。
    *   **高效機制：** DMA 和中斷驅動 I/O 等機制已極大提高了 I/O 效率，讓 CPU 可以與 I/O 並行工作。
    *   **軟體優化：** 作業系統層面的 I/O 排程、檔案系統設計、緩衝與快取策略，以及應用程式層面的 I/O 模型選擇（同步/非同步、阻塞/非阻塞）都對 I/O 效能有巨大影響。

#### 誤區二：I/O 操作只考慮硬體。
*   **澄清：** I/O 效能是一個綜合性的問題，硬體和軟體都扮演著關鍵角色。
    *   **硬體：** I/O 裝置本身的速度、控制器、匯流排頻寬等是基礎。
    *   **軟體：**
        *   **裝置驅動程式：** 驅動程式的效率和正確性直接影響 I/O 效能。
        *   **作業系統：** I/O 排程演算法、檔案系統的設計（如日誌型檔案系統、寫入時複製）、緩衝和快取機制，都直接影響 I/O 效率。
        *   **應用程式：** 應用程式如何組織 I/O 請求（一次讀取/寫入多少數據、是否使用非同步 I/O、是否批次處理）也會對 I/O 效能產生巨大影響。

#### 誤區三：緩衝和快取是同一個概念。
*   **澄清：** 緩衝和快取都是利用記憶體來提高 I/O 效率，但它們的目標和機制有所不同。
    *   **緩衝 (Buffering)：**
        *   **主要目的：** 匹配生產者和消費者之間的速度差異；將小塊數據聚合成大塊，或將大塊數據分解成小塊，以提高 I/O 操作的效率（減少 I/O 次數）。
        *   **特性：** 通常是暫時性的，數據一旦被消費就可能從緩衝區中移除。
        *   **範例：** 鍵盤輸入緩衝區，影片播放器的預加載緩衝區。
    *   **快取 (Caching)：**
        *   **主要目的：** 利用數據的局部性原理，將經常訪問的數據存儲在更快的介質上，以減少對原始慢速介質的訪問。
        *   **特性：** 數據被保留下來，希望在將來被重複訪問。需要置換演算法來管理空間。
        *   **範例：** CPU 快取、磁碟頁快取、瀏覽器快取。
    *   **總結：** 緩衝側重於**流暢性**和**效率**（批量處理），快取側重於**加速**和**減少重複工作**（利用局部性）。它們有時會結合使用，例如作業系統的磁碟頁快取同時提供了緩衝和快取的功能。

-----

### 6) 小練習（附詳解）

#### 小練習一：I/O 操作模式比較

請說明程式化 I/O (PIO)、中斷驅動 I/O 和直接記憶體存取 (DMA) 這三種 I/O 操作模式的主要差異，並分析它們在 CPU 利用率和數據傳輸效率上的優缺點。

##### 詳解一：

1.  **程式化 I/O (Programmed I/O, PIO)**
    *   **主要差異：** CPU 持續「輪詢」I/O 裝置的狀態暫存器，等待裝置準備好。數據傳輸也完全由 CPU 執行。
    *   **CPU 利用率：** 極低。CPU 大部分時間被阻塞，空閒等待 I/O 裝置，尤其當 I/O 裝置速度慢時，CPU 會嚴重浪費。
    *   **數據傳輸效率：** 低。每次數據傳輸都需要 CPU 全程參與，限制了傳輸速度，且 CPU 無法同時執行其他有用任務。
    *   **優點：** 實現簡單，所需硬體最少。
    *   **缺點：** CPU 效率低下，不適合高速或大批量數據傳輸。

2.  **中斷驅動 I/O (Interrupt-Driven I/O)**
    *   **主要差異：** CPU 不再輪詢。I/O 裝置完成操作或需要 CPU 介入時，會向 CPU 發送一個中斷訊號。CPU 響應中斷並執行相應的中斷服務常式來處理。數據傳輸仍由 CPU 執行。
    *   **CPU 利用率：** 較高。CPU 在 I/O 裝置忙碌時可以執行其他任務，只有在 I/O 事件發生時才需要介入。
    *   **數據傳輸效率：** 中等。相較於 PIO 有顯著提升，但每次數據塊傳輸仍需 CPU 參與中斷處理和數據移動，頻繁的中斷和上下文切換會產生開銷。
    *   **優點：** 提高了 CPU 利用率，減少了 CPU 的等待時間。
    *   **缺點：** 每次數據傳輸仍需要 CPU 介入，對於大量數據傳輸仍有瓶頸。

3.  **直接記憶體存取 (Direct Memory Access, DMA)**
    *   **主要差異：** CPU 只負責初始化 DMA 控制器。數據傳輸（在 I/O 裝置和主記憶體之間）由 DMA 控制器直接完成，無需 CPU 介入。傳輸完成後，DMA 控制器向 CPU 發送中斷。
    *   **CPU 利用率：** 極高。CPU 僅需在初始化和傳輸結束時短暫介入，數據傳輸期間完全釋放，可以同時執行其他運算任務。
    *   **數據傳輸效率：** 極高。 DMA 控制器直接在裝置和記憶體之間移動數據，消除了 CPU 作為中間媒介的瓶頸，實現了 I/O 與 CPU 的高度並行。
    *   **優點：** 最高的數據傳輸效率和 CPU 利用率，最適合高速、大批量數據傳輸。
    *   **缺點：** 需要專門的 DMA 控制器硬體支持，實現相對複雜。DMA 競爭記憶體匯流排可能造成輕微的記憶體訪問延遲。

---

#### 小練習二：磁碟 I/O 排程

假設一個磁碟的讀寫頭目前位於磁軌 50。有以下待處理的 I/O 請求，目標磁軌依序為：98, 183, 37, 122, 14, 124, 65, 67。請分別使用 FIFO (先進先出) 和 SSTF (最短尋道時間優先) 這兩種排程演算法，計算讀寫頭的總移動距離。假設磁軌編號從 0 到 199。

##### 詳解二：

**當前讀寫頭位置：** 50
**請求隊列 (依序)：** 98, 183, 37, 122, 14, 124, 65, 67

---

**1. FIFO (First-In, First-Out) 演算法**

按照請求到達的順序處理。

*   **初始位置：** 50
*   **處理順序及移動距離：**
    1.  處理 98：`|98 - 50| = 48`。當前位置：98
    2.  處理 183：`|183 - 98| = 85`。當前位置：183
    3.  處理 37：`|37 - 183| = 146`。當前位置：37
    4.  處理 122：`|122 - 37| = 85`。當前位置：122
    5.  處理 14：`|14 - 122| = 108`。當前位置：14
    6.  處理 124：`|124 - 14| = 110`。當前位置：124
    7.  處理 65：`|65 - 124| = 59`。當前位置：65
    8.  處理 67：`|67 - 65| = 2`。當前位置：67

*   **總移動距離：**
    $48 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = \mathbf{643}$ 磁軌

---

**2. SSTF (Shortest Seek Time First) 演算法**

總是選擇離當前讀寫頭位置最近的請求。

*   **初始位置：** 50
*   **請求隊列：** [98, 183, 37, 122, 14, 124, 65, 67]

*   **處理順序及移動距離：**
    1.  **當前位置：50**
        *   距離計算：
            *   98: $|98 - 50| = 48$
            *   183: $|183 - 50| = 133$
            *   37: $|37 - 50| = 13$
            *   122: $|122 - 50| = 72$
            *   14: $|14 - 50| = 36$
            *   124: $|124 - 50| = 74$
            *   65: $|65 - 50| = 15$
            *   67: $|67 - 50| = 17$
        *   最近請求是 **37** (距離 13)。
        *   移動距離：`13`。當前位置：37。隊列：[98, 183, 122, 14, 124, 65, 67]

    2.  **當前位置：37**
        *   距離計算：
            *   98: $|98 - 37| = 61$
            *   183: $|183 - 37| = 146$
            *   122: $|122 - 37| = 85$
            *   14: $|14 - 37| = 23$
            *   124: $|124 - 37| = 87$
            *   65: $|65 - 37| = 28$
            *   67: $|67 - 37| = 30$
        *   最近請求是 **14** (距離 23)。
        *   移動距離：`23`。當前位置：14。隊列：[98, 183, 122, 124, 65, 67]

    3.  **當前位置：14**
        *   距離計算：
            *   98: $|98 - 14| = 84$
            *   183: $|183 - 14| = 169$
            *   122: $|122 - 14| = 108$
            *   124: $|124 - 14| = 110$
            *   65: $|65 - 14| = 51$
            *   67: $|67 - 14| = 53$
        *   最近請求是 **65** (距離 51)。
        *   移動距離：`51`。當前位置：65。隊列：[98, 183, 122, 124, 67]

    4.  **當前位置：65**
        *   距離計算：
            *   98: $|98 - 65| = 33$
            *   183: $|183 - 65| = 118$
            *   122: $|122 - 65| = 57$
            *   124: $|124 - 65| = 59$
            *   67: $|67 - 65| = 2$
        *   最近請求是 **67** (距離 2)。
        *   移動距離：`2`。當前位置：67。隊列：[98, 183, 122, 124]

    5.  **當前位置：67**
        *   距離計算：
            *   98: $|98 - 67| = 31$
            *   183: $|183 - 67| = 116$
            *   122: $|122 - 67| = 55$
            *   124: $|124 - 67| = 57$
        *   最近請求是 **98** (距離 31)。
        *   移動距離：`31`。當前位置：98。隊列：[183, 122, 124]

    6.  **當前位置：98**
        *   距離計算：
            *   183: $|183 - 98| = 85$
            *   122: $|122 - 98| = 24$
            *   124: $|124 - 98| = 26$
        *   最近請求是 **122** (距離 24)。
        *   移動距離：`24`。當前位置：122。隊列：[183, 124]

    7.  **當前位置：122**
        *   距離計算：
            *   183: $|183 - 122| = 61$
            *   124: $|124 - 122| = 2$
        *   最近請求是 **124** (距離 2)。
        *   移動距離：`2`。當前位置：124。隊列：[183]

    8.  **當前位置：124**
        *   距離計算：
            *   183: $|183 - 124| = 59$
        *   最近請求是 **183** (距離 59)。
        *   移動距離：`59`。當前位置：183。隊列：[]

*   **總移動距離：**
    $13 + 23 + 51 + 2 + 31 + 24 + 2 + 59 = \mathbf{205}$ 磁軌

---

**結果比較：**
*   **FIFO 總移動距離：** 643 磁軌
*   **SSTF 總移動距離：** 205 磁軌

SSTF 演算法顯著減少了讀寫頭的總移動距離，從而提高了磁碟 I/O 效能。

-----

### 7) 延伸閱讀/參考

*   **計算機組織與設計 (Computer Organization and Design: The Hardware/Software Interface)**
    *   作者：David A. Patterson, John L. Hennessy
    *   內容：詳細解釋了 I/O 裝置的硬體結構、CPU 與 I/O 的互動方式、中斷、DMA 等底層機制。
*   **作業系統概念 (Operating System Concepts)**
    *   作者：Abraham Silberschatz, Peter B. Galvin, Greg Gagne
    *   內容：深入探討了作業系統如何管理 I/O 系統，包括裝置驅動程式、I/O 排程、緩衝、快取、錯誤處理和虛擬化。
*   **現代作業系統 (Modern Operating Systems)**
    *   作者：Andrew S. Tanenbaum, Herbert Bos
    *   內容：從系統設計和實作的角度介紹了 I/O 系統的各個方面。
*   **Linux Kernel Development**
    *   作者：Robert Love
    *   內容：對於想了解 Linux 核心如何處理 I/O、裝置驅動程式、檔案系統和記憶體管理等實際運作的讀者，是非常寶貴的資源。