# 作業系統結構

作業系統 (Operating System, OS) 的結構是其設計哲學與實作方式的體現，直接影響著系統的穩定性、安全性、效能、可擴展性與維護性。理解不同的作業系統結構有助於我們分析現有系統的優缺點，並為設計新系統提供思路。

-----

### 1. 核心概念與定義

作業系統結構描述了作業系統各個組成部分如何被組織、互動及彼此關聯。它決定了核心服務（如行程管理、記憶體管理、檔案系統、I/O 管理）的實作方式與其在系統中的位置。

#### 1.1 單體式核心 (Monolithic Kernel)

*   **定義/核心觀念：**
    單體式核心是一種將所有核心服務（如行程管理、記憶體管理、檔案系統、設備驅動程式等）都實作在單一的位址空間中，作為一個巨大的、不可分割的程式來運行的結構。所有核心模組都以核心模式 (Kernel Mode) 執行，共享相同的記憶體空間。
*   **例子或推導：**
    早期的 UNIX 系統和現代的 Linux 核心是典型的單體式核心（儘管現代 Linux 已經引入了模組化特性，使其成為「模組化單體式核心」或「混合式核心」）。
    當應用程式發出一個系統呼叫時，系統會從使用者模式切換到核心模式，並直接在核心空間中執行對應的服務程式碼。
*   **與相鄰概念的關聯：**
    *   **優點：** 由於所有服務都在同一個位址空間中執行，減少了核心模組間的通訊開銷，因此通常具有較高的執行效能。開發相對直接，所有程式碼都可以直接調用核心內部函數。
    *   **缺點：** 系統一旦發生錯誤（例如一個設備驅動程式的 bug），整個核心都可能崩潰。維護和除錯困難，因為程式碼庫龐大且耦合度高。新增或移除功能需要重新編譯整個核心。

#### 1.2 層次式核心 (Layered Kernel)

*   **定義/核心觀念：**
    層次式核心將作業系統的功能嚴格地劃分為多個層次 (Layers)，每個層次都只依賴於其下層提供的服務，並向上層提供服務。最底層是硬體，最頂層是使用者介面。
*   **例子或推導：**
    由 Dijkstra 設計的 THE Multiprogramming System 是第一個層次式結構的例子，它分為六個層次：
    *   層 0: 硬體 (處理器、記憶體)
    *   層 1: CPU 排程、記憶體管理
    *   層 2: 行程間通訊 (IPC)
    *   層 3: I/O 管理
    *   層 4: 使用者程式
    *   層 5: 操作員
    這種結構確保了每一層只需關注其下層的介面，而無需了解底層的內部細節。
*   **與相鄰概念的關聯：**
    *   **優點：** 模組化程度高，易於設計、實作、除錯和驗證。修改某一層不會影響其他層，前提是介面保持不變。
    *   **缺點：** 嚴格的層次劃分可能導致效能下降，因為請求可能需要穿越多個層次才能到達硬體。定義合適的層次和介面本身就是一個挑戰。

#### 1.3 微核心結構 (Microkernel Structure)

*   **定義/核心觀念：**
    微核心結構將作業系統的核心服務盡可能地縮小，只保留最基本的功能，如位址空間管理、行程間通訊 (IPC) 和基本排程。其他傳統上屬於核心的功能（如檔案系統、設備驅動程式、網路協定等）則被實作在使用者空間中，作為獨立的伺服器 (Servers) 程式運行。
*   **例子或推導：**
    Mach 核心 (用於 NeXTSTEP, macOS 基礎)、QNX、L4 核心系列是微核心的典型代表。
    在微核心系統中，一個應用程式需要讀取檔案時，它會向檔案系統伺服器發送一個訊息（透過 IPC），檔案系統伺服器再透過 IPC 與設備驅動程式伺服器通訊，最終設備驅動程式伺服器會發出硬體指令。所有這些通訊都在使用者空間進行，只有 IPC 機制本身在核心空間。
*   **與相鄰概念的關聯：**
    *   **優點：** 高度模組化、可擴展性強。由於大多數服務在使用者空間執行，一個服務的崩潰不會導致整個核心崩潰，提升了系統的穩定性與安全性。易於移植和維護。
    *   **缺點：** 頻繁的跨位址空間通訊 (IPC) 可能會引入顯著的效能開銷，因為每次通訊都需要上下文切換。設計良好的 IPC 機制是成功的關鍵。

#### 1.4 模組化核心 / 混合式核心 (Modular Kernel / Hybrid Kernel)

*   **定義/核心觀念：**
    混合式核心結合了單體式核心和微核心的優點。它通常以單體式核心為基礎，但允許核心模組在運行時動態載入和卸載。這使得核心在核心服務方面保持了單體式核心的效能優勢，同時又獲得了微核心的部分模組化和可擴展性。
*   **例子或推導：**
    現代的 Linux 核心和 Windows NT 核心 (及其後續版本) 都是混合式核心的典型代表。
    在 Linux 中，設備驅動程式、檔案系統模組等可以在系統運行時動態載入 `(insmod)` 或卸載 `(rmmod)`，而無需重新編譯和啟動整個核心。這使得系統在保持高效能的同時，能靈活地適應不同的硬體配置和功能需求。
*   **與相鄰概念的關聯：**
    *   **優點：** 兼顧了效能和靈活性。可以動態添加或移除功能，提高了系統的可維護性和可擴展性，同時避免了微核心的 IPC 效能瓶頸。
    *   **缺點：** 複雜性高於純粹的單體式核心。模組之間的依賴關係管理可能很複雜，錯誤的模組載入/卸載可能導致系統不穩定。

#### 1.5 虛擬機器 (Virtual Machine, VM)

*   **定義/核心觀念：**
    虛擬機器提供了一種環境，它模擬了真實的硬體平台，使得多個作業系統可以在同一台物理機器上同時運行。底層的軟體稱為虛擬機器監視器 (Virtual Machine Monitor, VMM) 或 Hypervisor。VMM 管理物理硬體資源，並為每個虛擬機器提供一個隔離的虛擬化環境。
*   **例子或推導：**
    VMware ESXi, Oracle VirtualBox, Microsoft Hyper-V, KVM 等。
    一個物理伺服器可以運行多個客戶作業系統（如 Windows Server、多個 Linux 發行版），每個客戶作業系統都認為它獨佔了硬體資源，彼此之間是隔離的。
*   **與相鄰概念的關聯：**
    *   **優點：** 資源利用率高，多個虛擬機器共享物理硬體。提供強大的隔離性，一個虛擬機器的問題不會影響其他虛擬機器。便於測試和部署不同的作業系統或應用程式。
    *   **缺點：** 引入了額外的虛擬化層，可能會有一定的效能開銷。管理多個虛擬機器需要專業知識。

-----

### 2. 典型例子與轉換/推導

本節將深入探討不同結構的運作方式及其設計思路。

#### 2.1 單體式核心的運作流程

假設一個應用程式需要讀取一個檔案：
1.  使用者應用程式發出 `read()` 系統呼叫。
2.  作業系統捕獲此呼叫，將 CPU 從使用者模式切換到核心模式。
3.  核心模式下的處理程序定位到檔案系統模組的 `read` 函數。
4.  檔案系統模組內部直接呼叫位於核心空間的快取管理、記憶體管理、設備驅動程式等功能。
5.  設備驅動程式直接訪問 I/O 硬體控制器來讀取資料。
6.  資料讀取完成後，核心將資料傳回給使用者應用程式，並切換回使用者模式。

**推導：** 從這個流程可以看出，單體式核心的服務之間是直接函數調用，這使得其路徑短、效率高。然而，任何一個環節（例如設備驅動）出錯，都可能導致核心崩潰，因為所有核心程式碼都共享同一個記憶體空間。

#### 2.2 微核心的運作流程

假設一個應用程式需要讀取一個檔案：
1.  使用者應用程式發出 `read()` 系統呼叫。
2.  微核心捕獲此呼叫，將 CPU 從使用者模式切換到核心模式。
3.  微核心的 `read` 處理程序識別出該請求需要檔案系統服務，透過核心提供的 IPC 機制，將請求以訊息的形式發送給檔案系統伺服器（此伺服器在使用者空間運行）。
4.  微核心將 CPU 切換回使用者模式，並將控制權轉交給檔案系統伺服器。
5.  檔案系統伺服器解析請求，判斷需要設備 I/O，再次透過 IPC 將請求發送給設備驅動程式伺服器（同樣在使用者空間運行）。
6.  微核心再次進行上下文切換，將控制權轉交給設備驅動程式伺服器。
7.  設備驅動程式伺服器透過 IPC 請求微核心執行特權 I/O 操作（微核心會檢查權限）。
8.  微核心執行 I/O 操作，完成後透過 IPC 將結果返回給設備驅動程式伺服器。
9.  設備驅動程式伺服器將結果透過 IPC 返回給檔案系統伺服器。
10. 檔案系統伺服器將最終結果透過 IPC 返回給使用者應用程式。

**推導：** 微核心的流程顯然比單體式核心複雜得多，涉及到多次使用者模式與核心模式的切換以及頻繁的 IPC 通訊。這解釋了其潛在的效能開銷。但同時，如果檔案系統伺服器或設備驅動程式伺服器崩潰，只有該伺服器會受影響，核心本身保持穩定，因為它們運行在獨立的使用者空間。

-----

### 3. 與相鄰概念的關聯

作業系統結構的選擇對作業系統的各個子系統設計都有深遠的影響。

#### 3.1 系統呼叫 (System Calls)

*   **單體式/混合式核心：** 系統呼叫通常直接導致 CPU 從使用者模式切換到核心模式，並在核心位址空間內直接執行對應的服務函數。效率高，但核心內部錯誤可能影響整個系統。
*   **微核心：** 系統呼叫通常會被核心轉化為 IPC 訊息，發送給在使用者空間運行的特定伺服器。雖然增加了上下文切換和訊息傳遞的開銷，但提供了更好的隔離和保護。

#### 3.2 程序管理 (Process Management)

*   **所有結構：** 核心都負責程序的創建、終止、排程和上下文切換。
*   **微核心：** 將許多傳統上屬於核心的程序管理功能（如行程間通訊的策略、部分排程策略）移到使用者空間的伺服器中，核心只保留最基本的行程控制塊管理和排程原語。這使得排程策略可以更靈活地在使用者空間實現。

#### 3.3 記憶體管理 (Memory Management)

*   **單體式/混合式核心：** 核心直接管理整個系統的物理記憶體和虛擬記憶體。核心的記憶體管理單元 (MMU) 實作了分頁、分段、快取等策略。核心本身也佔用一部分核心空間的虛擬和物理記憶體。
*   **微核心：** 核心僅負責物理記憶體的基本映射和保護。高層次的記憶體管理策略（如虛擬記憶體交換策略、頁面置換演算法）可以由使用者空間的記憶體伺服器來實作。

#### 3.4 I/O 管理 (I/O Management) 與 設備驅動程式

*   **單體式/混合式核心：** 設備驅動程式通常直接編譯進核心或作為可載入模組運行在核心空間。它們可以直接訪問硬體，效率高。但錯誤的驅動程式可能導致核心崩潰。
*   **微核心：** 設備驅動程式通常在使用者空間作為獨立的伺服器運行。它們透過 IPC 與核心通訊以訪問特權硬體指令。這提高了系統的穩定性和安全性，因為驅動程式的崩潰不會影響核心。

#### 3.5 安全性 (Security) 與 穩定性 (Stability)

*   **單體式核心：** 所有的核心組件都在一個特權位址空間中運行，缺乏隔離。一個組件的錯誤可能導致整個系統崩潰，安全漏洞也更容易影響整個系統。
*   **微核心：** 服務的高度隔離性是其主要優勢。每個伺服器在獨立的位址空間中運行，並受到核心的保護。一個服務的崩潰不會傳播到其他服務或核心本身，大大提高了系統的穩定性和安全性。

#### 3.6 可擴展性 (Extensibility) 與 可維護性 (Maintainability)

*   **單體式核心：** 擴展或修改功能需要重新編譯整個核心，維護大型單體式程式碼庫很困難。
*   **層次式/模組化/微核心：** 這些結構都提高了系統的模組化程度。
    *   **層次式：** 易於理解和除錯，但嚴格的介面限制可能導致擴展困難。
    *   **模組化：** 允許動態載入/卸載模組，提高了靈活性和可擴展性。
    *   **微核心：** 由於服務在使用者空間運行，可以獨立開發、更新和替換，極大地提高了可擴展性和可維護性。

-----

### 4. 進階內容

#### 4.1 核心模式與使用者模式 (Kernel Mode vs. User Mode)

*   **定義/核心觀念：** 現代作業系統通常將 CPU 的執行模式分為至少兩種：
    *   **核心模式 (Kernel Mode / Supervisor Mode)：** 又稱特權模式。在此模式下，CPU 可以執行所有的指令，包括特權指令（如直接訪問 I/O 埠、修改記憶體映射等），並可以訪問系統的所有記憶體。作業系統核心在核心模式下運行。
    *   **使用者模式 (User Mode)：** 又稱非特權模式。在此模式下，CPU 只能執行非特權指令，不能直接訪問硬體資源，也不能訪問核心模式的記憶體。應用程式通常在使用者模式下運行。
*   **例子或推導：**
    這種模式劃分是作業系統保護和隔離的基礎。當使用者程式需要執行特權操作時（例如讀取檔案、創建行程），它不能直接執行，而必須透過 **系統呼叫 (System Call)** 向作業系統請求服務。系統呼叫會觸發一個中斷，導致 CPU 從使用者模式切換到核心模式，由作業系統來執行特權操作。完成後，CPU 會切換回使用者模式，將結果返回給應用程式。
*   **與相鄰概念的關聯：**
    作業系統結構的選擇直接影響模式切換的頻率和方式。
    *   **單體式核心：** 一旦進入核心模式，大部分操作都在核心模式下完成，模式切換次數相對較少。
    *   **微核心：** 由於許多服務在使用者空間的伺服器中運行，處理一個請求可能需要多次在使用者模式和核心模式之間切換（透過 IPC 機制），這增加了開銷。

#### 4.2 核心空間與使用者空間 (Kernel Space vs. User Space)

*   **定義/核心觀念：**
    這是虛擬記憶體管理的概念，將程式的位址空間劃分為兩個主要部分：
    *   **核心空間 (Kernel Space)：** 專門為作業系統核心保留的記憶體區域。核心在此空間中執行，並儲存其資料結構、程式碼和核心模組。使用者程式無法直接訪問核心空間。
    *   **使用者空間 (User Space)：** 每個使用者應用程式都有自己獨立的使用者空間。應用程式在此空間中執行，並儲存其程式碼和資料。各個應用程式的使用者空間是相互隔離的。
*   **例子或推導：**
    在 32 位元系統中，通常將 4GB 的虛擬位址空間劃分，例如將 0x00000000 到 0xBFFFFFFF (3GB) 分配給使用者空間，將 0xC0000000 到 0xFFFFFFFF (1GB) 分配給核心空間。
    這種劃分提供了強大的保護。一個應用程式的錯誤或惡意行為通常只能影響其自身的使用者空間，無法直接破壞核心或其他應用程式的空間。
*   **與相鄰概念的關聯：**
    *   **單體式核心：** 所有的核心服務都在單一的核心空間中執行。
    *   **微核心：** 核心空間被保持最小，大部分服務（檔案系統、網路協定、設備驅動等）作為獨立的行程運行在它們各自的使用者空間中。它們之間透過核心提供的 IPC 機制進行通訊。

-----

### 5. 常見錯誤與澄清

1.  **錯誤觀念：Linux 是一個純粹的單體式核心。**
    *   **澄清：** 現代 Linux 核心是一個「混合式核心」或「模組化單體式核心」。雖然它的主要部分運行在單一核心空間，但它支援動態載入/卸載核心模組 (Kernel Modules)，例如設備驅動程式、檔案系統模組等。這使得它在保持單體式核心效能優勢的同時，獲得了類似微核心的模組化和可擴展性。

2.  **錯誤觀念：微核心一定比單體式核心效能差。**
    *   **澄清：** 理論上，微核心由於頻繁的上下文切換和 IPC 開銷，效能可能比單體式核心差。然而，這並非絕對。高效的微核心設計 (如 L4 核心) 可以將 IPC 開銷降到極低，某些情況下甚至可以與單體式核心匹敵。此外，微核心的優勢在於穩定性、安全性、可擴展性及除錯的便利性，這些在特定應用場景（如即時嵌入式系統、高度安全的系統）下可能比純粹的原始效能更重要。

3.  **錯誤觀念：虛擬機器是一種應用程式，與作業系統結構無關。**
    *   **澄清：** 虛擬機器不僅僅是一個應用程式。虛擬化技術（及其底層的 Hypervisor 或 VMM）本身就是一種作業系統結構或系統架構。Hypervisor 扮演了類似於作業系統的角色，它管理物理硬體資源，並為在其上運行的多個客戶作業系統提供一個虛擬的硬體平台。這是一種在作業系統層級實現多工和資源隔離的方式。

4.  **錯誤觀念：層次式核心是現代作業系統的主流結構。**
    *   **澄清：** 嚴格的層次式結構在理論設計上很優雅，但由於其可能導致的效能開銷和過於嚴格的依賴關係，在實際應用中很少被純粹地採用。現代作業系統更傾向於混合式或模組化設計，部分採用層次化的思想，但不會嚴格遵守。

-----

### 6. 小練習 (附詳解)

#### 小練習 1: 結構選擇題

**情境：** 你被要求設計一個新的作業系統，用於一個高安全性、高可靠性且需要長時間無故障運行的關鍵任務系統（例如航空電子系統或醫療設備）。該系統對模組化和後續維護要求很高，但資源（CPU 速度、記憶體）相對有限。你建議採用哪種作業系統結構？請解釋你的選擇。

**步驟與詳解：**

1.  **分析需求關鍵字：**
    *   高安全性、高可靠性、長時間無故障運行：這些是微核心結構的主要優勢。服務隔離性強，單一組件故障不影響整個系統。
    *   模組化和後續維護要求高：微核心的模組化程度高，服務可獨立更新和替換，維護成本較低。
    *   資源相對有限：微核心的簡潔性使得其核心本身佔用資源少，雖然 IPC 可能有開銷，但對於關鍵任務，穩定性通常優先於絕對的原始效能。

2.  **比較不同結構：**
    *   **單體式核心：** 安全性、可靠性差，一個組件問題可能導致整個系統崩潰。維護困難。不符合需求。
    *   **層次式核心：** 模組化好，但可能引入效能開銷，且嚴格的層次劃分可能不夠靈活。
    *   **模組化/混合式核心：** 效能和靈活性兼顧，但核心大部分仍在單一特權空間，安全性不如微核心。
    *   **虛擬機器：** 雖然提供隔離，但引入了額外的 VMM 層，對資源有限的關鍵任務系統可能過重。

3.  **做出選擇：**
    基於以上分析，**微核心結構**是最合適的選擇。

4.  **解釋選擇原因：**
    *   **高安全性與高可靠性：** 微核心的核心程式碼極小，且大部分服務（如設備驅動程式、檔案系統等）運行在使用者空間的獨立行程中。這提供了強大的隔離性，即使某個服務或驅動程式崩潰，也不會導致整個系統崩潰，從而極大地提高了系統的穩定性和安全性。這對於關鍵任務系統至關重要。
    *   **模組化與維護性：** 由於各個服務是獨立的，它們可以獨立開發、測試、除錯和更新，而無需影響核心或其他服務。這極大地簡化了系統的維護工作，並提高了系統的可擴展性。
    *   **資源效率（相對而言）：** 微核心本身佔用資源極少，雖然 IPC 存在開銷，但對於確保系統正確運行的關鍵任務系統，其帶來的穩定性和安全性價值遠超潛在的效能損失。許多高效能的微核心（如 L4）在嵌入式環境中表現出色。

-----

#### 小練習 2: 概念比較

比較「單體式核心」與「微核心」在以下兩個方面的主要差異：
1.  設備驅動程式的位置與執行權限。
2.  一個典型的「檔案讀取」系統呼叫的處理流程。

**步驟與詳解：**

1.  **設備驅動程式的位置與執行權限：**
    *   **單體式核心：**
        *   **位置：** 設備驅動程式直接整合在核心中，或作為可載入模組運行在核心空間。
        *   **執行權限：** 以核心模式（特權模式）執行，擁有對整個硬體資源的完全訪問權限。
    *   **微核心：**
        *   **位置：** 設備驅動程式通常作為獨立的伺服器行程運行在使用者空間。
        *   **執行權限：** 以使用者模式（非特權模式）執行。當需要訪問特權硬體操作時，必須透過核心提供的 IPC 機制向微核心發送請求，由微核心代理執行特權操作並返回結果。

2.  **檔案讀取系統呼叫的處理流程：**
    *   **單體式核心：**
        1.  應用程式發出 `read()` 系統呼叫。
        2.  CPU 從使用者模式切換到核心模式。
        3.  核心直接在自身位址空間內執行檔案系統相關函數。
        4.  檔案系統函數直接調用核心空間內的設備驅動程式。
        5.  設備驅動程式直接操作硬體讀取資料。
        6.  核心將資料傳遞回應用程式，CPU 切換回使用者模式。
        *   **特點：** 流程直接，開銷小，但核心各部分高度耦合，一個環節錯誤易導致核心崩潰。
    *   **微核心：**
        1.  應用程式發出 `read()` 系統呼叫。
        2.  CPU 從使用者模式切換到核心模式（微核心接收請求）。
        3.  微核心使用 IPC 機制將讀取請求訊息發送給使用者空間的「檔案系統伺服器」。
        4.  CPU 切換回使用者模式（檔案系統伺服器接收訊息並執行）。
        5.  檔案系統伺服器解析請求，再透過 IPC 機制將讀取請求訊息發送給使用者空間的「設備驅動程式伺服器」。
        6.  CPU 切換回核心模式 (IPC 處理)，然後再切換回使用者模式（設備驅動程式伺服器接收訊息並執行）。
        7.  設備驅動程式伺服器透過 IPC 機制請求微核心執行特權 I/O 操作。
        8.  微核心執行特權 I/O 操作，並透過 IPC 將結果返回給設備驅動程式伺服器。
        9.  設備驅動程式伺服器透過 IPC 將結果返回給檔案系統伺服器。
        10. 檔案系統伺服器透過 IPC 將最終結果返回給應用程式。
        *   **特點：** 流程複雜，涉及多次模式切換和 IPC 通訊，開銷較大，但服務間高度隔離，提高了系統的穩定性和安全性。

-----

### 7. 延伸閱讀/參考

*   **經典教科書：**
    *   Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts* (10th ed.). Wiley. (繁體中文版通常稱為《作業系統概念》)
    *   Tanenbaum, A. S., & Bos, H. (2015). *Modern Operating Systems* (4th ed.). Pearson. (繁體中文版通常稱為《現代作業系統》)

*   **特定核心相關：**
    *   Liedtke, J. (1996). *On µ-Kernel Construction*. ACM SIGOPS Operating Systems Review, 30(5), 237-250. (關於 L4 微核心的經典論文)
    *   Accetta, M. J., Baron, R. V., Bolosky, W., Golub, D. B., Rashid, R. F., Tevanian Jr., A., & Young, M. (1986). *Mach: A New Kernel Foundation for UNIX Development*. In *USENIX Summer Conference*. (關於 Mach 微核心的介紹)

*   **虛擬化技術：**
    *   Popek, G. J., & Goldberg, R. P. (1974). *Formal Requirements for Virtualizable Third Generation Architectures*. Communications of the ACM, 17(7), 412-421. (虛擬化技術的理論基礎)

*   **線上資源：**
    *   Wikipedia: "Operating system structure", "Monolithic kernel", "Microkernel", "Hybrid kernel", "Virtual machine monitor".