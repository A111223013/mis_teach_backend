# 雙向與環狀鏈結串列：深入理解彈性資料結構

## 章節一：引言與鏈結串列基礎回顧

### 什麼是鏈結串列？

在電腦科學中，鏈結串列（Linked List）是一種線性資料結構，與陣列（Array）不同，它在記憶體中不是連續儲存的。鏈結串列由一系列節點（Node）組成，每個節點包含資料元素和指向下一個節點的指標（Pointer）。這種結構的彈性在於，它允許高效地在任意位置插入或刪除元素，而無需像陣列那樣移動大量元素。

#### 單向鏈結串列的限制

在我們深入探索雙向與環狀鏈結串列之前，先快速回顧一下單向鏈結串列（Singly Linked List）的基礎。單向鏈結串列的每個節點只包含一個指向下一個節點的指標。這表示：
*   **只能向前遍歷**：從頭節點開始，依序遍歷到尾節點。
*   **回溯困難**：如果需要找到某個節點的前一個節點，唯一的方法是從頭節點重新開始遍歷。
*   **某些操作效率較低**：例如，要刪除一個給定節點，我們通常需要找到它的前一個節點，這在單向鏈結串列中需要額外的遍歷。

為了克服這些限制，雙向鏈結串列和環狀鏈結串列應運而生，它們各自在不同情境下提供了更高效或更方便的解決方案。

-----

## 章節二：雙向鏈結串列 (Doubly Linked List)

### 2.1 核心概念與定義

#### 定義：

雙向鏈結串列（Doubly Linked List）是一種改進型的鏈結串列。與單向鏈結串列不同，雙向鏈結串列的每個節點不僅包含指向下一個節點的指標，還包含一個指向前一個節點的指標。

*   **節點結構**：一個雙向鏈結串列的節點通常包含三個部分：
    1.  `data`：儲存節點的實際資料。
    2.  `next`：指向串列中下一個節點的指標。
    3.  `prev`：指向串列中前一個節點的指標。

通常表示為：
```
struct Node {
    int data;
    Node* next;
    Node* prev;
};
```

#### 核心觀念：雙向遍歷能力

雙向鏈結串列最核心的特性是其**雙向遍歷能力**。你可以從頭節點向後遍歷到尾節點，也可以從尾節點向前遍歷到頭節點。這極大地增加了串列操作的靈活性。

*   **頭節點（Head）**：第一個節點，其 `prev` 指標通常為 `NULL` (或指向自身，若為雙向環狀)。
*   **尾節點（Tail）**：最後一個節點，其 `next` 指標通常為 `NULL` (或指向自身，若為雙向環狀)。

-----

### 2.2 典型操作與推導

由於每個節點有兩個指標需要維護，雙向鏈結串列的操作會比單向鏈結串列稍微複雜一些，但某些操作卻更高效。

#### 1. 插入操作

**前提**：假設要插入的新節點為 `newNode`。

##### a) 在串列開頭插入 (Insert at Head)
*   如果串列為空：`newNode` 成為頭尾節點，其 `next` 和 `prev` 都指向 `NULL`。
*   如果串列非空：
    1.  `newNode->next = head` (新節點指向原頭節點)
    2.  `head->prev = newNode` (原頭節點的 `prev` 指向新節點)
    3.  `newNode->prev = NULL` (新節點的 `prev` 指向 `NULL`)
    4.  `head = newNode` (更新 `head` 指標為新節點)

##### b) 在串列結尾插入 (Insert at Tail)
*   如果串列為空：同在開頭插入。
*   如果串列非空：
    1.  `newNode->prev = tail` (新節點的 `prev` 指向原尾節點)
    2.  `tail->next = newNode` (原尾節點的 `next` 指向新節點)
    3.  `newNode->next = NULL` (新節點的 `next` 指向 `NULL`)
    4.  `tail = newNode` (更新 `tail` 指標為新節點)

##### c) 在指定節點 `current` 之後插入
*   `newNode->next = current->next`
*   `newNode->prev = current`
*   如果 `current->next` 不為 `NULL` (即 `current` 不是尾節點)：
    *   `current->next->prev = newNode`
*   `current->next = newNode`
*   **特別處理**：如果 `current` 是尾節點，則 `newNode` 成為新的尾節點，需要更新 `tail` 指標。

##### d) 在指定節點 `current` 之前插入
*   `newNode->prev = current->prev`
*   `newNode->next = current`
*   如果 `current->prev` 不為 `NULL` (即 `current` 不是頭節點)：
    *   `current->prev->next = newNode`
*   `current->prev = newNode`
*   **特別處理**：如果 `current` 是頭節點，則 `newNode` 成為新的頭節點，需要更新 `head` 指標。

#### 2. 刪除操作

**前提**：假設要刪除的節點為 `target`。

##### a) 刪除頭節點 (Delete at Head)
*   如果串列只有一個節點：`head = NULL`, `tail = NULL`。
*   如果串列有多個節點：
    1.  `head = head->next`
    2.  `head->prev = NULL`
    3.  釋放原頭節點記憶體。

##### b) 刪除尾節點 (Delete at Tail)
*   如果串列只有一個節點：同刪除頭節點。
*   如果串列有多個節點：
    1.  `tail = tail->prev`
    2.  `tail->next = NULL`
    3.  釋放原尾節點記憶體。

##### c) 刪除指定節點 `target`
*   **邊界情況**：如果 `target` 是頭節點，則執行刪除頭節點的邏輯；如果 `target` 是尾節點，則執行刪除尾節點的邏輯。
*   如果 `target` 在串列中間：
    1.  `target->prev->next = target->next`
    2.  `target->next->prev = target->prev`
    3.  釋放 `target` 節點記憶體。

#### 3. 遍歷操作

*   **向前遍歷**：從 `head` 開始，沿著 `next` 指標移動，直到 `current` 為 `NULL`。
*   **向後遍歷**：從 `tail` 開始，沿著 `prev` 指標移動，直到 `current` 為 `NULL`。

```cpp
// 簡單的向前遍歷範例
void traverseForward(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        // 處理 current->data
        current = current->next;
    }
}

// 簡單的向後遍歷範例
void traverseBackward(Node* tail) {
    Node* current = tail;
    while (current != nullptr) {
        // 處理 current->data
        current = current->prev;
    }
}
```

-----

### 2.3 與單向鏈結串列的關聯

#### 優勢 (相較於單向鏈結串列)：

1.  **雙向遍歷**：可以從任一端開始遍歷，或在遍歷過程中向前後移動，這對於需要雙向操作的應用非常有用（如瀏覽器的「上一頁/下一頁」功能）。
2.  **簡化某些操作**：
    *   **刪除指定節點**：在單向鏈結串列中，要刪除一個節點，你需要找到其前一個節點。這通常意味著從頭開始遍歷。在雙向鏈結串列中，直接透過 `target->prev` 即可獲取其前一個節點，操作更直接。
    *   **在指定節點前插入**：同樣，直接透過 `target->prev` 即可操作。
3.  **靈活性**：更容易實現更複雜的列表操作，例如將列表反轉，或將兩個列表合併。

#### 劣勢 (相較於單向鏈結串列)：

1.  **額外空間開銷**：每個節點需要多一個 `prev` 指標，這會增加記憶體使用量。對於儲存大量小資料的串列，這是一個需要考量的因素。
    *   如果單向鏈結串列每個節點佔用 $S$ 大小的記憶體（一個資料欄位和一個指標），那麼雙向鏈結串列則需要 $S + \text{sizeof(pointer)}$ 大小的記憶體。
2.  **操作複雜度略增**：在插入和刪除操作時，需要維護兩個指標 (`next` 和 `prev`) 而非一個，這使得程式碼稍微複雜，更容易出錯。必須小心處理所有邊界情況（空串列、單一節點串列、在頭尾插入/刪除）。

-----

## 章節三：環狀鏈結串列 (Circular Linked List)

### 3.1 核心概念與定義

#### 定義：

環狀鏈結串列（Circular Linked List）是一種特殊形式的鏈結串列，其尾節點的 `next` 指標不是指向 `NULL`，而是指向串列的**頭節點**。這使得整個串列形成一個環。

*   **單向環狀鏈結串列**：每個節點包含資料和一個 `next` 指標，尾節點的 `next` 指向頭節點。
*   **雙向環狀鏈結串列**：每個節點包含資料、`next` 指標和 `prev` 指標。尾節點的 `next` 指向頭節點，頭節點的 `prev` 指向尾節點。

通常在討論環狀鏈結串列時，如果沒有特別說明，一般是指單向環狀鏈結串列。

#### 核心觀念：無終止點、連續循環

環狀鏈結串列的核心特徵是**沒有明確的開始和結束**（從指標的角度看）。你可以從任何節點開始遍歷，最終都會回到起點。

*   **遍歷判斷**：由於沒有 `NULL` 終止符，遍歷時需要特別的邏輯來判斷何時回到起點，以避免無限循環。常見做法是遍歷直到當前節點再次等於起始節點。
*   **頭節點**：通常我們會定義一個特殊的節點作為“頭節點”來標識串列的起點，但從結構上看，所有節點都是平等的，都可以作為遍歷的起點。有時為了操作方便，會維護一個指向**尾節點**的指標，因為透過尾節點的 `next` 很容易找到頭節點。

-----

### 3.2 典型操作與推導 (以單向環狀鏈結串列為例)

#### 1. 插入操作

**前提**：通常會維護一個指向 `tail` 的指標，這樣 `tail->next` 就是 `head`。

##### a) 在空串列中插入
*   `newNode->next = newNode` (新節點指向自己)
*   `tail = newNode` (新節點既是頭也是尾)

##### b) 在串列開頭插入 (Insert at Head)
*   如果串列為空：同上。
*   如果串列非空：
    1.  `newNode->next = tail->next` (新節點指向原頭節點)
    2.  `tail->next = newNode` (尾節點指向新節點，新節點成為頭節點)
    *   **注意**：`head` 指標在環狀串列中通常不是必須的，我們可以透過 `tail->next` 來表示頭節點。

##### c) 在串列結尾插入 (Insert at Tail)
*   如果串列為空：同上。
*   如果串列非空：
    1.  `newNode->next = tail->next` (新節點指向原頭節點)
    2.  `tail->next = newNode` (原尾節點指向新節點)
    3.  `tail = newNode` (更新 `tail` 指標為新節點)

#### 2. 刪除操作

##### a) 刪除頭節點
*   如果串列為空：不執行任何操作。
*   如果串列只有一個節點：`tail = NULL`。
*   如果串列有多個節點：
    1.  `Node* head = tail->next` (找到頭節點)
    2.  `tail->next = head->next` (尾節點指向新頭節點)
    3.  釋放 `head` 記憶體。

##### b) 刪除尾節點
*   如果串列為空：不執行任何操作。
*   如果串列只有一個節點：`tail = NULL`。
*   如果串列有多個節點：
    1.  需要找到尾節點的前一個節點。這需要從 `tail->next` 開始遍歷，直到找到 `current->next == tail` 的 `current`。
    2.  `current->next = tail->next` (前一個節點指向頭節點)
    3.  釋放 `tail` 記憶體。
    4.  `tail = current` (更新 `tail` 指標)

#### 3. 遍歷操作

遍歷環狀鏈結串列時，需要一個起始點和一個判斷循環終止的條件。

```cpp
// 假設我們有 `head` 指標，並且列表非空
void traverseCircular(Node* head) {
    if (head == nullptr) return; // 空列表

    Node* current = head;
    do {
        // 處理 current->data
        current = current->next;
    } while (current != head); // 當回到起始節點時停止
}

// 如果只維護 `tail` 指標，則 `head` 為 `tail->next`
void traverseCircularWithTail(Node* tail) {
    if (tail == nullptr) return; // 空列表

    Node* head = tail->next;
    Node* current = head;
    do {
        // 處理 current->data
        current = current->next;
    } while (current != head);
}
```

-----

### 3.3 與單向/雙向鏈結串列的關聯

#### 優勢：

1.  **從任意點開始遍歷整個列表**：這是環狀鏈結串列最主要的優點。你可以從任何節點開始，向前遍歷，最終都會回到起始點，遍歷所有節點。這對於某些演算法（如約瑟夫斯問題）或應用（如多工作業系統中的任務排程）非常方便。
2.  **實現循環緩衝區**：可以很容易地實現像循環佇列（Circular Queue）或緩衝區這類的資料結構，用於資料的生產與消費。
3.  **無需空指標檢查**：在遍歷或某些操作中，由於沒有 `NULL` 指標作為終止符，可以簡化程式邏輯，減少對 `NULL` 的檢查。
4.  **在尾部插入/刪除高效**：如果只維護一個 `tail` 指標，則在列表尾部插入或刪除元素，然後更新 `tail`，操作效率很高。這是因為 `tail->next` 總是指向 `head`。

#### 劣勢：

1.  **遍歷邏輯複雜**：由於沒有 `NULL` 作為遍歷終止條件，需要額外邏輯來判斷何時停止（例如，遍歷回到起始節點時）。如果處理不當，容易導致無限循環。
2.  **頭節點或尾節點的維護**：雖然理論上所有節點都是平等的，但在實際操作中，為了方便管理（例如找到頭節點或從頭開始遍歷），我們通常仍需維護一個 `head` 或 `tail` 指標。
3.  **某些傳統鏈結串列演算法需要調整**：為環狀結構設計的演算法會與為線性鏈結串列設計的演算法不同。

-----

## 章節四：雙向環狀鏈結串列 (Doubly Circular Linked List)

### 4.1 核心概念與定義

雙向環狀鏈結串列結合了雙向鏈結串列和環狀鏈結串列的特性。它的每個節點不僅有 `next` 和 `prev` 指標，而且：
*   尾節點的 `next` 指向頭節點。
*   頭節點的 `prev` 指向尾節點。

這意味著你可以從任何節點開始，雙向（向前或向後）遍歷整個串列，並最終回到起點。

*   **節點結構**：與雙向鏈結串列相同：`data`, `next`, `prev`。
*   **環狀特性**：
    *   `head->prev = tail`
    *   `tail->next = head`

#### 核心觀念：兼具雙向與循環優點

這種結構提供了最大的靈活性：
1.  **高效的雙向遍歷**：如同雙向鏈結串列。
2.  **從任意點開始循環遍歷**：如同環狀鏈結串列。
3.  **在頭尾插入/刪除極為高效**：只需更新頭尾節點的四個指標（兩個 `next`，兩個 `prev`）。

### 4.2 典型操作簡述

雙向環狀鏈結串列的操作是雙向鏈結串列和環狀鏈結串列操作的組合。例如，插入新節點 `newNode` 到一個非空的雙向環狀列表 `head`：

**在開頭插入 `newNode`：**
1.  `newNode->next = head`
2.  `newNode->prev = head->prev` (指向原來的尾節點)
3.  `head->prev->next = newNode` (原尾節點的 `next` 指向新節點)
4.  `head->prev = newNode` (原頭節點的 `prev` 指向新節點)
5.  `head = newNode` (更新頭節點)

**遍歷**：
```cpp
// 向前遍歷
void traverseDoublyCircular(Node* head) {
    if (head == nullptr) return;

    Node* current = head;
    do {
        // 處理 current->data
        current = current->next;
    } while (current != head);
}
```
向後遍歷的邏輯也類似，只需將 `current = current->next` 改為 `current = current->prev`。

-----

## 章節五：常見錯誤與澄清

### 5.1 雙向鏈結串列

#### 1. 指標更新順序錯誤
**常見錯誤**：在插入或刪除節點時，沒有按照正確的順序更新 `next` 和 `prev` 指標，導致指標斷裂或指向錯誤的節點。
**澄清**：務必先建立新節點與其相鄰節點的連結，再斷開舊連結。尤其是在插入時，如果先改變了 `current->next`，則可能丟失 `current->next` 原來指向的節點。
**例子**：在 `current` 之後插入 `newNode`：
*   錯誤：`current->next = newNode; newNode->prev = current; newNode->next = current->next; current->next->prev = newNode;` (`newNode->next = current->next` 這行會取到新設定的 `newNode` 而非舊的 `current->next`)
*   正確：
    1.  `newNode->next = current->next;` (新節點指向 `current` 原來的下一個節點)
    2.  `if (current->next != nullptr) current->next->prev = newNode;` (如果 `current` 不是尾節點，則其原下一個節點的 `prev` 指向新節點)
    3.  `newNode->prev = current;` (新節點指向 `current`)
    4.  `current->next = newNode;` (`current` 指向新節點)

#### 2. 處理空列表、單一節點列表的邊界情況
**常見錯誤**：未考慮到串列為空或只有一個節點時的插入/刪除操作，導致 `NULL` 指標解引用或邏輯錯誤。
**澄清**：對於每個操作，首先要檢查串列是否為空，然後檢查操作的節點是否是串列中的唯一節點、頭節點或尾節點。這些情況通常需要單獨處理。

#### 3. 忘記釋放記憶體
**常見錯誤**：刪除節點後，忘記使用 `delete` 或 `free()` 釋放被刪除節點佔用的記憶體，導致記憶體洩漏。
**澄清**：每次從串列中移除一個節點後，如果該節點是動態分配的，務必釋放其記憶體。

### 5.2 環狀鏈結串列

#### 1. 遍歷終止條件錯誤
**常見錯誤**：在遍歷環狀鏈結串列時，仍然使用 `current != NULL` 作為終止條件，導致無限循環。
**澄清**：環狀鏈結串列沒有 `NULL` 指標作為終止符。遍歷必須設置一個明確的終止條件，通常是 `current != head` (在 `do-while` 循環中) 或 `current != startingNode`。
**例子**：
```cpp
// 正確的單向環狀鏈結串列遍歷
Node* current = head;
if (current != nullptr) { // 處理空列表
    do {
        // 處理 current->data
        current = current->next;
    } while (current != head);
}
```

#### 2. 頭節點或尾節點的維護問題
**常見錯誤**：
    a. 未能正確維護 `tail` 指標（如果只維護 `tail`）在插入/刪除操作後指向新的尾節點。
    b. 在只有一個節點的環狀串列中， `head->next` 和 `head->prev` 都應指向 `head` 本身，處理不當可能導致錯誤。
**澄清**：在環狀鏈結串列中，尤其是在單向環狀串列中，`tail` 指標非常有用，因為 `tail->next` 總是指向 `head`。因此，確保在每次插入或刪除導致 `tail` 改變時，更新 `tail` 指標是至關重要的。對於只有一個節點的情況，確保該節點的 `next` (和 `prev` 在雙向環狀中) 指向它自己。

-----

## 章節六：小練習（附詳解）

### 練習一：雙向鏈結串列 - 在指定節點**前**插入新節點

**問題**：
設計一個函數 `insert_before(Node* head, Node* target, int new_data)`，該函數能在雙向鏈結串列中，於給定節點 `target` 之前插入一個包含 `new_data` 的新節點。你需要考慮所有邊界情況，包括：
1.  串列為空。
2.  `target` 是頭節點。
3.  `target` 在串列中間。
4.  `target` 不存在於串列中（雖然本練習中你可以假設 `target` 一定存在且不為 `NULL`，但實際應用中應檢查）。

```cpp
// 節點結構
struct Node {
    int data;
    Node* next;
    Node* prev;

    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

// 鏈結串列的頭節點
Node* head = nullptr;
Node* tail = nullptr; // 為了方便，我們維護一個尾節點指標
```

**詳解**：

```cpp
// 節點結構 (同上)
struct Node {
    int data;
    Node* next;
    Node* prev;

    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

// 全局頭尾指標 (為練習方便，實際應用中應封裝在類別裡)
Node* head = nullptr;
Node* tail = nullptr;

void insert_before(Node*& head_ref, Node*& tail_ref, Node* target, int new_data) {
    // 1. 建立新節點
    Node* newNode = new Node(new_data);

    // 2. 處理串列為空的情況（通常 target 不會為 NULL）
    // 如果 target == nullptr，這表示目標節點不存在，或者要插入到一個空串列。
    // 在本練習中，我們假設 target 一定是串列中的一個有效節點。
    if (target == nullptr) {
        // 嚴謹做法應拋出錯誤或返回
        std::cout << "Target node cannot be null." << std::endl;
        delete newNode;
        return;
    }

    // 3. 處理新節點的 prev 和 next 指標
    newNode->next = target;
    newNode->prev = target->prev;

    // 4. 更新 target 及其前一個節點的指標

    // 如果 target 是頭節點
    if (target->prev == nullptr) {
        // a. 更新 head 指標
        head_ref = newNode;
    } else {
        // b. target 的前一個節點的 next 指向新節點
        target->prev->next = newNode;
    }
    // c. target 的 prev 指向新節點
    target->prev = newNode;

    // 5. 處理空串列變為非空串列時 tail 的初始化
    if (tail_ref == nullptr) { // 如果是第一次插入到空串列，且 target 就是唯一節點 (不符合本函數情境)
        // 這裡邏輯上 insert_before target，target 不可能是 null
        // 且如果 head_ref 已經是 newNode 了，那 tail_ref 應該也是 newNode
        if (head_ref == newNode && target->next == nullptr) { // 如果 target 是唯一的節點且新節點插入其前
            tail_ref = target; // target 變為尾節點
        }
    }
    // 注意：如果 target 是原頭節點，且原串列只有一個節點，
    // 插入後 newNode 為頭，原 target 為尾。
    if (head_ref == newNode && target->next == nullptr && target->prev == newNode) {
        tail_ref = target;
    }
    // 如果 target 原來是唯一的節點，那麼現在 newNode 是頭，target 是尾
    // 這一部分在 insert_before 的邏輯中可能會比較複雜，
    // 最簡單是初始化時保證 head 和 tail 都指向正確位置。
    // 如果 head_ref 變了，需要重新檢查 tail_ref 是否還指向原來的尾部。

    // 簡單化處理：如果是空的列表，或者 target 為 head，並且 target 也是 tail (只有一個元素時)，
    // 插入後，tail 不變
    // 複雜情況：如果 target 是原頭節點，且原串列只有一個節點，那插入後 target 會變成尾節點。
    if (head_ref == target && target->next == nullptr) { // 這種情況下 head_ref 應該已經更新為 newNode
        // 實際上，如果 target 是 head，且 head->prev == nullptr，那麼 target 一定不是 tail (除非只有一個元素)
        // 這裡的邏輯是當 target 是唯一的節點時，插入其前，那麼 target 變成尾節點。
        if (target->prev == newNode && target->next == nullptr) { // newNode -> target -> NULL
             tail_ref = target;
        }
    }
    // 讓 tail 指標維持正確，如果 newNode 成為了新的 head，而原 tail 保持不變
    // 如果 target 是原頭節點，則插入後 head 變了，tail 不變。
    // 除非 target 也是 tail (只有一個元素)，此時 target 變成了新尾節點。
    if (target->next == nullptr && target->prev != nullptr) { // target 變成新的尾節點
         tail_ref = target;
    } else if (head_ref == newNode && tail_ref == nullptr) { // 從空串列開始，只插入一個，tail 也該是 newNode
        tail_ref = newNode;
    }
}

// 輔助函數：列印串列
void printList(Node* head_ref) {
    Node* current = head_ref;
    std::cout << "List (Forward): ";
    while (current != nullptr) {
        std::cout << current->data << " <-> ";
        current = current->next;
    }
    std::cout << "NULL" << std::endl;
}

// 輔助函數：在尾部插入（用於測試方便）
void append(Node*& head_ref, Node*& tail_ref, int new_data) {
    Node* newNode = new Node(new_data);
    if (head_ref == nullptr) {
        head_ref = newNode;
        tail_ref = newNode;
        return;
    }
    tail_ref->next = newNode;
    newNode->prev = tail_ref;
    tail_ref = newNode;
}


int main() {
    std::cout << "--- Test insert_before ---" << std::endl;

    // 測試 1: 在空串列中插入 (這裡不適用 insert_before)
    // 我們假設 target 總是在串列中。
    // 可以手動初始化一個節點作為 target
    // Node* loneNode = new Node(10); head = loneNode; tail = loneNode;
    // insert_before(head, tail, loneNode, 5); // 應該是 5 <-> 10

    // 測試 2: 在非空串列的頭部插入
    head = new Node(20);
    tail = head;
    append(head, tail, 30); // List: 20 <-> 30
    printList(head); // Expected: 20 <-> 30 <-> NULL

    std::cout << "Inserting 10 before 20 (head)..." << std::endl;
    insert_before(head, tail, head, 10); // target is 20 (original head)
    printList(head); // Expected: 10 <-> 20 <-> 30 <-> NULL

    // 測試 3: 在串列中間插入
    Node* target_node_30 = head->next->next; // Node with data 30
    std::cout << "Inserting 25 before 30..." << std::endl;
    insert_before(head, tail, target_node_30, 25);
    printList(head); // Expected: 10 <-> 20 <-> 25 <-> 30 <-> NULL

    // 測試 4: 只有一個節點的串列，在其前插入
    // 重置串列
    Node* current = head;
    while(current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }
    head = nullptr;
    tail = nullptr;

    append(head, tail, 100); // List: 100
    printList(head); // Expected: 100 <-> NULL

    std::cout << "Inserting 50 before 100 (single node)..." << std::endl;
    insert_before(head, tail, head, 50); // target is 100 (original head)
    printList(head); // Expected: 50 <-> 100 <-> NULL
    std::cout << "New head: " << head->data << ", New tail: " << tail->data << std::endl; // head 50, tail 100

    // 清理記憶體
    current = head;
    while(current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }
    head = nullptr;
    tail = nullptr;

    return 0;
}
```

**步驟條列**：
1.  **建立新節點**：創建一個 `newNode`，並將其 `data` 設為 `new_data`。
2.  **連結新節點與 `target`**：將 `newNode->next` 指向 `target`，將 `newNode->prev` 指向 `target->prev`。
3.  **處理 `target` 的前一個節點**：
    *   如果 `target->prev` 為 `NULL` (表示 `target` 是頭節點)：則 `head_ref` 應更新為 `newNode`。
    *   否則（`target` 在中間）：將 `target->prev->next` 指向 `newNode`。
4.  **更新 `target` 的 `prev` 指標**：將 `target->prev` 指向 `newNode`。
5.  **更新 `tail` 指標的邊界情況**：
    *   如果插入後 `head_ref` 變為 `newNode` 且原 `target` 現在是尾節點（即 `target->next` 變為 `nullptr`），則 `tail_ref` 應更新為 `target`。
    *   在其他情況下（如在中間插入，或在頭部插入但原串列不只一個元素），`tail_ref` 不變。

### 練習二：環狀鏈結串列 - 判斷是否為循環串列

**問題**：
給定一個**可能為空或為單向鏈結串列**的 `head` 指標，請撰寫一個函數 `is_circular(Node* head)` 來判斷這個鏈結串列是否為環狀鏈結串列。

```cpp
// 節點結構
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};
```

**詳解**：

**核心觀念**：
使用快慢指標（Floyd's Cycle-Finding Algorithm，又稱龜兔賽跑演算法）。一個指標（慢指標，`slow`）每次移動一步，另一個指標（快指標，`fast`）每次移動兩步。如果在某個時間點，`slow` 和 `fast` 相遇了，則說明串列中存在環。如果 `fast` 或 `fast->next` 達到 `NULL`，則說明串列為線性，不存在環。

```cpp
// 節點結構 (同上)
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

bool is_circular(Node* head) {
    // 1. 處理空串列或只有一個節點的串列
    if (head == nullptr || head->next == nullptr) {
        return false; // 空串列或只有一個節點的線性串列都不是環狀串列
    }

    // 2. 初始化快慢指標
    Node* slow = head;
    Node* fast = head;

    // 3. 遍歷串列
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;        // 慢指標移動一步
        fast = fast->next->next;  // 快指標移動兩步

        // 4. 檢查是否有環
        if (slow == fast) {
            return true; // 快慢指標相遇，存在環
        }
    }

    // 5. 如果快指標達到末尾而未相遇，則無環
    return false;
}

// 輔助函數：建構線性串列
Node* create_linear_list(int count) {
    Node* head = nullptr;
    Node* tail = nullptr;
    for (int i = 0; i < count; ++i) {
        Node* newNode = new Node(i + 1);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// 輔助函數：建構環狀串列
Node* create_circular_list(int count) {
    Node* head = nullptr;
    Node* tail = nullptr;
    if (count <= 0) return nullptr;

    head = new Node(1);
    tail = head;
    for (int i = 1; i < count; ++i) {
        Node* newNode = new Node(i + 1);
        tail->next = newNode;
        tail = newNode;
    }
    tail->next = head; // 形成環
    return head;
}

int main() {
    std::cout << "--- Test is_circular ---" << std::endl;

    // 測試 1: 空串列
    Node* empty_list = nullptr;
    std::cout << "Empty list is circular? " << (is_circular(empty_list) ? "Yes" : "No") << std::endl; // Expected: No

    // 測試 2: 單節點線性串列
    Node* single_node_list = new Node(10);
    std::cout << "Single node linear list is circular? " << (is_circular(single_node_list) ? "Yes" : "No") << std::endl; // Expected: No
    delete single_node_list;

    // 測試 3: 多節點線性串列
    Node* linear_list = create_linear_list(5); // 1 -> 2 -> 3 -> 4 -> 5 -> NULL
    std::cout << "Linear list (5 nodes) is circular? " << (is_circular(linear_list) ? "Yes" : "No") << std::endl; // Expected: No
    // 清理線性串列
    Node* current = linear_list;
    while(current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    // 測試 4: 單節點環狀串列 (head->next == head)
    Node* single_circular_node = new Node(20);
    single_circular_node->next = single_circular_node;
    std::cout << "Single node circular list is circular? " << (is_circular(single_circular_node) ? "Yes" : "No") << std::endl; // Expected: Yes
    delete single_circular_node;

    // 測試 5: 多節點環狀串列
    Node* circular_list = create_circular_list(4); // 1 -> 2 -> 3 -> 4 -> (back to 1)
    std::cout << "Circular list (4 nodes) is circular? " << (is_circular(circular_list) ? "Yes" : "No") << std::endl; // Expected: Yes
    // 清理環狀串列 (需要特殊處理，避免無限循環)
    if (circular_list != nullptr) {
        current = circular_list->next;
        Node* head_to_delete = circular_list;
        while(current != head_to_delete) {
            Node* temp = current;
            current = current->next;
            delete temp;
        }
        delete head_to_delete;
    }

    return 0;
}
```

**步驟條列**：
1.  **邊界條件檢查**：如果 `head` 為 `NULL`（空串列）或 `head->next` 為 `NULL`（單節點線性串列），則它不可能是環狀串列，直接返回 `false`。
2.  **初始化快慢指標**：創建兩個指標 `slow` 和 `fast`，都指向 `head`。
3.  **遍歷與檢查**：
    *   在 `while` 迴圈中，條件是 `fast` 和 `fast->next` 都不為 `NULL`，這是為了確保快指標不會在訪問其 `next` 屬性時遇到 `NULL` 而崩潰。
    *   在每次循環中，`slow` 向前移動一步（`slow = slow->next`）。
    *   `fast` 向前移動兩步（`fast = fast->next->next`）。
    *   如果 `slow` 和 `fast` 在任何時候相等，表示它們在環中相遇，串列是環狀的，返回 `true`。
4.  **無環處理**：如果 `while` 循環結束，說明 `fast` 或 `fast->next` 變為 `NULL`，這表示快指標已經走到了串列的末尾，但 `slow` 和 `fast` 從未相遇，因此串列是線性的，返回 `false`。

-----

## 章節七：延伸閱讀/參考

### 1. 應用場景

*   **雙向鏈結串列**：
    *   **瀏覽器歷史記錄**：實現「上一頁」和「下一頁」功能。
    *   **LRU 快取（Least Recently Used Cache）**：用於高效地管理最近最少使用的元素。當空間不足時，可以快速移除快取中最不常使用的項目。
    *   **文字編輯器**：支援 Undo/Redo 功能。
    *   **任務排程器**：在多工作業系統中，按優先級或其他準則維護任務列表，需要雙向移動。

*   **環狀鏈結串列**：
    *   **循環緩衝區（Circular Buffer）/循環佇列（Circular Queue）**：高效處理生產者-消費者問題，避免資料移動，常見於音訊/視訊串流。
    *   **多工處理系統的任務排程**：操作系統可以使用環狀鏈結串列來管理需要輪流執行的多個進程，每個進程輪流獲得 CPU 時間片。
    *   **約瑟夫斯問題（Josephus Problem）**：一個經典的數學與電腦科學問題，可以用環狀鏈結串列自然地模擬。

### 2. 其他資料結構與概念

*   **跳躍列表（Skip List）**：一種基於多層級鏈結串列的資料結構，用於實現高效的搜尋、插入和刪除操作，性能堪比平衡二元搜尋樹。
*   **XOR 鏈結串列**：一種空間優化的雙向鏈結串列，每個節點只用一個指標儲存其前一個和下一個節點的 XOR 值。
*   **哈希表（Hash Table）**：在處理衝突時，鏈結串列是常見的解決方案之一（鏈式地址法）。
*   **樹（Tree）**：樹結構本質上是特殊的鏈結結構，每個節點可以有多個「子節點」指標。

### 參考資料

*   **經典資料結構與演算法書籍**：
    *   *Introduction to Algorithms* by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein (通常簡稱 CLRS)。
    *   *Data Structures and Algorithms in C++* by Michael T. Goodrich, Roberto Tamassia, David M. Mount。
*   **線上資源**：
    *   GeeksforGeeks (英文): 提供大量程式碼範例和詳細解釋。
    *   Wikipedia (多語言): 提供概念的概覽和歷史背景。
    *   各大學的資料結構課程講義。