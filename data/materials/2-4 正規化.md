# 2-4 正規化：深入理解資料庫設計的核心原則

你將學習如何運用第二、第三、Boyce-Codd 和第四正規型態來設計更健壯、更高效的關聯式資料庫。

-----

### 核心概念：資料庫正規化

#### 定義/核心觀念
資料庫正規化（Database Normalization）是關聯式資料庫設計中的一項重要技術，其目標是透過系統化的程序來組織資料庫中的表格和欄位，以：
1.  **減少資料冗餘（Data Redundancy）**：避免相同資料在多個地方重複儲存。
2.  **提高資料完整性（Data Integrity）**：確保資料的一致性和正確性，降低因重複資料造成的更新異常。
3.  **消除更新異常（Update Anomalies）**：
    *   **插入異常（Insertion Anomaly）**：無法在不插入其他資訊的情況下插入新資料。
    *   **刪除異常（Deletion Anomaly）**：刪除某筆資料時，不小心刪除了其他重要的資訊。
    *   **修改異常（Modification Anomaly）**：修改某筆資料時，需要修改多個地方，容易導致不一致。

正規型態（Normal Forms, NFs）是一組設計準則，從 1NF 到 5NF 乃至更高，每一種正規型態都建立在前一種的基礎之上，並施加更嚴格的條件來消除特定類型的資料冗餘和異常。本章節將聚焦於 2NF、3NF、BCNF 及 4NF。

#### 前提：函數相依性 (Functional Dependency, FD)
理解正規化最核心的觀念是「函數相依性」。
*   **定義**：如果 $X \to Y$，表示 $X$ 唯一地決定了 $Y$。換句話說，對於關係中的任意兩條元組 (row)，如果它們在 $X$ 上的值相同，那麼它們在 $Y$ 上的值也必須相同。
*   **例子**：`學生ID \to 學生姓名` 意味著每個 `學生ID` 唯一對應一個 `學生姓名`。

-----

### 2NF (第二正規型態)

#### 定義/核心觀念
一個關係模式 (relation schema) 若要符合 2NF，必須滿足以下兩個條件：
1.  **必須已經符合 1NF。** (所有屬性都是原子性的，沒有重複組。)
2.  **所有的非主鍵屬性 (Non-Key Attributes) 都必須「完全函數相依 (Fully Functionally Dependent)」於主鍵。** 換句話說，沒有「部分相依性 (Partial Dependency)」。

*   **部分相依性**：當一個非主鍵屬性只相依於複合主鍵（由多個屬性組成的主鍵）的其中一部分時，就存在部分相依性。

#### 典型例子與轉換
**情境：** 一個不符合 2NF 的訂單明細表。
**表結構：** `訂單明細(訂單編號, 產品編號, 產品名稱, 數量, 單價)`

**假設：**
*   主鍵：`(訂單編號, 產品編號)` (一個訂單可包含多個產品，一個產品可出現在多個訂單)
*   函數相依性 (FDs)：
    *   `(訂單編號, 產品編號) \to 數量` (特定訂單的特定產品有特定數量)
    *   `(訂單編號, 產品編號) \to 單價` (特定訂單的特定產品有特定單價)
    *   `產品編號 \to 產品名稱` (產品名稱僅由產品編號決定，與訂單編號無關)

**問題分析：**
*   `產品名稱` 是一個非主鍵屬性。
*   主鍵是複合鍵 `(訂單編號, 產品編號)`。
*   FD `產品編號 \to 產品名稱` 顯示 `產品名稱` 只依賴於主鍵的一部分 (`產品編號`)，而不是整個主鍵。這就是部分相依性。
*   因此，此表不符合 2NF。

**異常：**
*   **插入異常：** 無法單獨儲存一個新產品的名稱，除非它被包含在一個訂單中。
*   **刪除異常：** 如果一個產品只出現在一個訂單中，當該訂單的明細被刪除時，該產品的名稱資訊也會遺失。
*   **修改異常：** 如果一個產品的名稱變更，必須更新所有包含該產品的訂單明細，容易導致資料不一致。

**2NF 轉換：** 消除部分相依性，將表格拆分為多個關係。
1.  將原主鍵 `(訂單編號, 產品編號)` 和其完全相依的屬性 `數量`, `單價` 構成一個新表。
2.  將部分相依的屬性 `產品名稱` 和其決定者 `產品編號` 構成另一個新表。

**分解結果：**
*   **訂單明細(訂單編號, 產品編號, 數量, 單價)**
    *   主鍵：`(訂單編號, 產品編號)`
    *   此表已符合 2NF。
*   **產品(產品編號, 產品名稱)**
    *   主鍵：`產品編號`
    *   此表已符合 2NF。

-----

### 3NF (第三正規型態)

#### 定義/核心觀念
一個關係模式若要符合 3NF，必須滿足以下兩個條件：
1.  **必須已經符合 2NF。**
2.  **所有的非主鍵屬性都必須「非傳遞相依 (Non-Transitively Dependent)」於主鍵。** 換句話說，沒有「傳遞相依性 (Transitive Dependency)」。

*   **傳遞相依性**：當一個非主鍵屬性 $C$ 相依於另一個非主鍵屬性 $B$，而 $B$ 又相依於主鍵 $A$ 時，即存在鏈式相依關係 $A \to B \to C$。

#### 典型例子與轉換
**情境：** 一個不符合 3NF 的員工部門表。
**表結構：** `員工(員工編號, 員工姓名, 部門編號, 部門名稱, 部門地點)`

**假設：**
*   主鍵：`員工編號`
*   函數相依性 (FDs)：
    *   `員工編號 \to 員工姓名`
    *   `員工編號 \to 部門編號`
    *   `部門編號 \to 部門名稱` (部門編號決定部門名稱)
    *   `部門編號 \to 部門地點` (部門編號決定部門地點)

**問題分析：**
*   `員工編號` 是主鍵。
*   `部門編號` 是一個非主鍵屬性，它直接相依於主鍵 `員工編號`。
*   `部門名稱` 和 `部門地點` 也是非主鍵屬性，但它們不直接相依於 `員工編號`，而是透過 `部門編號` 相依於 `員工編號`。
    *   即：`員工編號 \to 部門編號 \to 部門名稱`
    *   即：`員工編號 \to 部門編號 \to 部門地點`
*   這就是傳遞相依性。因此，此表不符合 3NF。

**異常：**
*   **插入異常：** 如果要新增一個部門的資訊（名稱和地點），但還沒有任何員工屬於該部門，就無法將部門資訊存入此表。
*   **刪除異常：** 刪除某部門的最後一位員工時，該部門的名稱和地點資訊也會隨之丟失。
*   **修改異常：** 如果一個部門的名稱或地點變更，必須更新所有屬於該部門的員工記錄，容易出錯。

**3NF 轉換：** 消除傳遞相依性，將表格拆分。
1.  將主鍵 `員工編號` 及其直接相依的屬性 `員工姓名`, `部門編號` 構成一個新表。
2.  將非主鍵決定者 `部門編號` 及其相依的屬性 `部門名稱`, `部門地點` 構成另一個新表。

**分解結果：**
*   **員工(員工編號, 員工姓名, 部門編號)**
    *   主鍵：`員工編號`
    *   此表已符合 3NF。
*   **部門(部門編號, 部門名稱, 部門地點)**
    *   主鍵：`部門編號`
    *   此表已符合 3NF。

-----

### BCNF (Boyce-Codd 正規型態)

#### 定義/核心觀念
BCNF 是比 3NF 更嚴格的正規型態。一個關係模式若要符合 BCNF，必須滿足以下條件：
1.  **必須已經符合 3NF。**
2.  **對於表格中的每個非平凡函數相依 $X \to Y$，決定者 $X$ 必須是關係的一個『候選鍵 (Candidate Key)』。**

*   **非平凡函數相依**：當 $Y$ 不是 $X$ 的子集時。
*   **候選鍵**：能夠唯一識別資料列的最小屬性集合。一個關係可以有多個候選鍵，其中一個會被選定作為主鍵。
*   **BCNF 與 3NF 的差異**：3NF 允許非主鍵屬性依賴於候選鍵的子集，只要這些候選鍵不是非主鍵屬性；而 BCNF 要求任何決定者都必須是一個完整的候選鍵。換句話說，BCNF 消除了所有非候選鍵決定者的函數相依性。

#### 典型例子與轉換
**情境：** 一個不符合 BCNF 的學生課程顧問表。
**表結構：** `學生課程顧問(學生編號, 課程名稱, 顧問編號)`

**假設：**
*   函數相依性 (FDs)：
    1.  `(學生編號, 課程名稱) \to 顧問編號` (一個學生選修某門課程，有一個指定的顧問)
    2.  `學生編號 \to 顧問編號` (一個學生只能有一個顧問，這個顧問負責該學生所有課程的諮詢)

**問題分析：**
1.  **找出所有候選鍵：**
    *   從 FD 1 我們知道 `(學生編號, 課程名稱)` 可以決定 `顧問編號`。
    *   考慮 FD 2 `學生編號 \to 顧問編號`。這表示如果知道 `學生編號` 和 `課程名稱`，可以決定 `顧問編號`。但由於 `學生編號` 已經能決定 `顧問編號`，實際上 `課程名稱` 對於決定 `顧問編號` 是冗餘的。
    *   如果我們選 `(學生編號, 課程名稱)` 為主鍵：
        *   FD 1 `(學生編號, 課程名稱) \to 顧問編號` 符合定義 (主鍵決定非主鍵屬性)。
        *   FD 2 `學生編號 \to 顧問編號` 存在問題：`學生編號` 是主鍵 `(學生編號, 課程名稱)` 的一部分，但它卻決定了一個非主鍵屬性 `顧問編號`。這看起來像是 2NF 問題，但由於 `顧問編號` 已被看作是 `(學生編號, 課程名稱)` 的函數，所以實際情況是 `學生編號` 也是一個『決定者』，而它『不是』該表的候選鍵。
    *   如果我們考慮 `(學生編號, 顧問編號)` 也是候選鍵（因為 `學生編號` 決定 `顧問編號`，且 `(學生編號, 顧問編號)` 可以唯一識別所有其他屬性，如果 `課程名稱` 也能被 `(學生編號, 顧問編號)` 決定，則它是一個候選鍵，但本例中 `課程名稱` 仍是獨立的）。
    *   正確的候選鍵識別：
        *   `CK1 = (學生編號, 課程名稱)`：可以唯一識別所有屬性。
        *   `CK2 = (學生編號, 顧問編號)`：透過 `學生編號 \to 顧問編號`，可以看作 `學生編號` 搭配 `顧問編號` 來識別 `課程名稱`。（但這可能導致歧義，例如一個學生有多門課，每個顧問都可以指導多個學生。）
    *   最常見的主鍵是 `(學生編號, 課程名稱)`。

2.  **判斷 3NF：**
    *   **1NF：** 是。
    *   **2NF：** 是。`顧問編號` 完全相依於 `(學生編號, 課程名稱)`。沒有部分相依性。
    *   **3NF：** 是。沒有傳遞相依性。`學生編號 \to 顧問編號` 是一個直接相依。
    *   此表符合 3NF。

3.  **判斷 BCNF：**
    *   BCNF 要求每個決定者都必須是一個候選鍵。
    *   我們有一個函數相依：`學生編號 \to 顧問編號`。
    *   決定者是 `學生編號`。
    *   `學生編號` 不是表格 `學生課程顧問` 的任何一個候選鍵（`學生編號` 只是 `(學生編號, 課程名稱)` 這個候選鍵的一部分，不是完整的候選鍵）。
    *   因此，此表不符合 BCNF。

**異常：**
*   **插入異常：** 如果要新增一個學生的顧問資訊，但該學生還未選任何課程，就無法將其顧問資訊存入此表。
*   **刪除異常：** 刪除某學生選修的最後一門課的記錄時，該學生的顧問資訊也會丟失。
*   **修改異常：** 如果一個學生的顧問變更，必須更新所有該學生選修的課程記錄。

**BCNF 轉換：** 消除非候選鍵決定者的函數相依，將表格拆分。
1.  將違反 BCNF 的函數相依 `學生編號 \to 顧問編號` 構成一個新表。
2.  將原始表中的 `顧問編號` 移除，保留其餘屬性。

**分解結果：**
*   **學生顧問(學生編號, 顧問編號)**
    *   主鍵：`學生編號`
    *   此表符合 BCNF。
*   **學生選課(學生編號, 課程名稱)**
    *   主鍵：`(學生編號, 課程名稱)`
    *   此表符合 BCNF。

-----

### 4NF (第四正規型態)

#### 定義/核心觀念
一個關係模式若要符合 4NF，必須滿足以下兩個條件：
1.  **必須已經符合 BCNF。**
2.  **表格中沒有「多值相依性 (Multi-valued Dependency, MVD)」。**

*   **多值相依性**：$A \twoheadrightarrow B$ 表示對於 $A$ 的每一個值，都有一組 $B$ 的值與之對應，且這組 $B$ 值獨立於表格中所有其他非 $A$ 的屬性。當一個實體有多個獨立的多值屬性時，可能出現 MVD。

#### 典型例子與轉換
**情境：** 一個不符合 4NF 的學生技能興趣表。
**表結構：** `學生技能興趣(學生編號, 技能, 興趣)`

**假設：**
*   主鍵：`(學生編號, 技能, 興趣)` (因為單獨的 `學生編號`、`技能`、`興趣` 都不能唯一識別一行)
*   函數相依性：沒有（假設 `技能` 和 `興趣` 之間沒有直接函數關係）
*   多值相依性 (MVDs)：
    *   `學生編號 \twoheadrightarrow 技能` (一個學生可以有多種技能)
    *   `學生編號 \twoheadrightarrow 興趣` (一個學生可以有多種興趣)
    *   且學生的技能集合與興趣集合是相互獨立的。例如，一個學生學會新技能，不影響他的興趣集合；增加一個新興趣，也不影響他的技能集合。

**問題分析：**
1.  **判斷 BCNF：**
    *   由於主鍵是 `(學生編號, 技能, 興趣)`，且沒有任何非主鍵屬性，也沒有非候選鍵決定者，因此此表符合 BCNF。

2.  **判斷 MVD：**
    *   儘管符合 BCNF，但存在多值相依性。例如，學生 A 有技能 {Java, Python}，興趣 {閱讀, 寫作}。
    *   在表格中會出現：
        *   (A, Java, 閱讀)
        *   (A, Java, 寫作)
        *   (A, Python, 閱讀)
        *   (A, Python, 寫作)
    *   這意味著，當新增一個學生的技能時，必須為該學生現有的所有興趣重複新增該技能的組合；反之亦然。這表示 `技能` 和 `興趣` 相對於 `學生編號` 是多值相依且相互獨立的。
    *   因此，此表不符合 4NF。

**異常：**
*   **插入異常：** 新增一個學生的新興趣時，必須為該學生所有的技能重複新增記錄，導致大量冗餘。
*   **刪除異常：** 刪除一個學生的某項技能時，可能意外地刪除了該學生與其他興趣的組合。
*   **修改異常：** 由於冗餘，更新資料時複雜且容易出錯。

**4NF 轉換：** 消除多值相依性，將表格拆分。
1.  將主鍵和一個多值相依的屬性構成一個新表。
2.  將主鍵和另一個多值相依的屬性構成另一個新表。

**分解結果：**
*   **學生技能(學生編號, 技能)**
    *   主鍵：`(學生編號, 技能)`
    *   此表符合 4NF。
*   **學生興趣(學生編號, 興趣)**
    *   主鍵：`(學生編號, 興趣)`
    *   此表符合 4NF。

-----

### 與相鄰概念的關聯

#### 正規型態的層次關係
正規型態之間是包含關係，每一級都比前一級更嚴格，消除的冗餘也更多：
$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$
*   **1NF**：所有屬性都是原子性的，無重複組。
*   **2NF**：在 1NF 基礎上，消除非主鍵屬性對複合主鍵的部分相依。
*   **3NF**：在 2NF 基礎上，消除非主鍵屬性對主鍵的傳遞相依。
*   **BCNF**：在 3NF 基礎上，消除所有決定者不是候選鍵的函數相依。
*   **4NF**：在 BCNF 基礎上，消除多值相依。

通常，將資料庫設計到 3NF 或 BCNF 已經能滿足大多數應用場景的需求。4NF 及 5NF 主要處理更特殊的多值相依和連接相依情況。

#### 正規化與反正規化 (Denormalization)
*   **正規化優點**：減少資料冗餘、提高資料完整性、降低更新異常、易於維護和擴展。
*   **正規化缺點**：查詢通常需要更多的 JOIN 操作來組合來自多個表格的資料，可能增加查詢的複雜度和執行時間，降低讀取性能。
*   **反正規化**：為了優化讀取性能，有時會刻意引入一些受控的冗餘資料（例如，在一個表中重複儲存另一個表的資料，以避免 JOIN）。這是在資料完整性風險和查詢性能之間做出的權衡。反正規化通常在高併發、讀取密集型系統中實施，並且需要仔細管理，以確保資料一致性。
*   **權衡考量**：正規化是資料庫設計的良好起點，但在實際應用中，尤其對於 OLAP (線上分析處理) 或需要快速響應的 OLTP (線上交易處理) 系統，可能會根據性能需求進行適度的反正規化。

-----

### 進階內容：無損連接分解與相依性保存

#### 無損連接分解 (Lossless-Join Decomposition)
*   **核心觀念**：將一個關係模式 $R$ 分解為多個子模式 $R_1, R_2, \dots, R_n$ 後，透過這些子模式的自然連接 (Natural Join) 運算 `R1 ⋈ R2 ⋈ ... ⋈ Rn`，可以完全恢復原始的關係 $R$，且不會產生額外的虛假元組 (spurious tuples)，也不會丟失任何原始元組。
*   **重要性**：這是資料庫分解必須滿足的基本要求，確保分解後的資料庫在邏輯上與原始資料庫等價。
*   **判斷標準**：對於一個二元分解 $R = R_1 \cup R_2$，如果 $R_1 \cap R_2 \to R_1$ 或 $R_1 \cap R_2 \to R_2$ 存在於函數相依集合 $F$ 的閉包 $F^+$ 中，則分解是無損連接的。

#### 相依性保存 (Dependency-Preserving Decomposition)
*   **核心觀念**：將一個關係模式分解為多個子模式後，原始的函數相依集合 $F$ 中的所有函數相依性都可以在分解後的子模式中被推導出來。換句話說，每個函數相依性都被至少一個子模式所「保存」，無需跨多個表格進行連接或複雜計算即可檢查。
*   **重要性**：確保原始的資料完整性約束在分解後仍能被有效強制執行，而無需跨多個表格進行昂貴的檢查。

#### 3NF 與 BCNF 的權衡
*   **3NF**：總是保證可以達到無損連接分解和相依性保存。這意味著在分解到 3NF 後，資料不會丟失，並且所有的完整性約束（函數相依性）都可以在單個表中檢查。
*   **BCNF**：總是保證無損連接分解，但『不一定』能保證相依性保存。在某些特定情況下，為了達到 BCNF（即消除所有非候選鍵決定者的函數相依），可能需要放棄一些函數相依性的直接保存。這意味著，某些完整性約束在分解後需要透過多個表的組合查詢才能驗證。

**結論**：在資料庫設計中，如果相依性保存對於業務邏輯的實施至關重要，且無法透過其他方式（如觸發器）有效彌補，那麼有時選擇停留在 3NF 可能是比 BCNF 更實用的選擇。反之，如果極度重視冗餘的最小化，並且相依性可以透過應用層或其他機制來處理，那麼 BCNF 可能是更好的選擇。

-----

### 常見錯誤與澄清

1.  **混淆部分相依與傳遞相依：**
    *   **部分相依 (2NF 問題)**：當主鍵是複合鍵，且非主鍵屬性只依賴於主鍵的一部分時。
        *   **例子**：`訂單明細(訂單編號, 產品編號, 產品名稱)` 中，主鍵為 `(訂單編號, 產品編號)`，但 `產品編號 \to 產品名稱`。`產品名稱` 部分相依於 `產品編號`。
    *   **傳遞相依 (3NF 問題)**：當非主鍵屬性 $C$ 依賴於另一個非主鍵屬性 $B$，而 $B$ 又依賴於主鍵 $A$ 時，即 $A \to B \to C$。
        *   **例子**：`員工(員工編號, 部門編號, 部門名稱)` 中，主鍵為 `員工編號`，且 `員工編號 \to 部門編號` 和 `部門編號 \to 部門名稱`。`部門名稱` 傳遞相依於 `員工編號` 透過 `部門編號`。
    *   **澄清**：仔細識別主鍵和所有的函數相依性是區分兩者的關鍵。部分相依性只發生在複合主鍵下。

2.  **認為 BCNF 是所有情況下的最佳選擇：**
    *   **澄清**：BCNF 確實能最大程度地減少冗餘，但它可能無法保證相依性保存。這表示，為了強制執行某些業務規則，可能需要複雜的應用邏輯或跨表檢查。如果相依性保存對資料庫的完整性和維護性非常重要，且業務規則檢查頻繁，那麼停留在 3NF 可能是更好的折衷方案。

3.  **盲目正規化到最高形式：**
    *   **澄清**：過度正規化（分解出過多小型表）可能導致查詢需要進行大量 JOIN 操作，從而嚴重影響查詢性能。在設計資料庫時，應根據實際業務需求、預期工作負載和性能要求來決定正規化的程度。通常，3NF 已經足夠滿足大多數應用場景，並在冗餘與性能之間取得良好平衡。

-----

### 小練習 (附詳解)

#### 練習一：識別正規型態並進行分解

**情境：** 一個學生課程成績與教師資訊表。
`學生課程成績(學生ID, 學生姓名, 課程ID, 課程名稱, 成績, 教師ID, 教師姓名)`

**假設函數相依性 (FDs)：**
1.  `(學生ID, 課程ID) \to 成績` (一個學生在某課程中的成績)
2.  `學生ID \to 學生姓名` (學生ID 決定學生姓名)
3.  `課程ID \to 課程名稱` (課程ID 決定課程名稱)
4.  `課程ID \to 教師ID` (一門課程只由一位教師授課)
5.  `教師ID \to 教師姓名` (教師ID 決定教師姓名)

**問題：**
a) 判斷此表目前的主鍵是什麼？
b) 此表符合哪種正規型態？並解釋原因。
c) 請將此表分解到至少 3NF。

**詳解：**

a) **判斷主鍵：**
    *   為了唯一識別一條記錄，需要同時知道 `學生ID` 和 `課程ID`，因為一個學生可能選修多門課程，一門課程也可能有多位學生。
    *   因此，主鍵是複合鍵 `(學生ID, 課程ID)`。

b) **判斷正規型態：**
    1.  **1NF?** 是。所有屬性都是原子性的，沒有重複組。
    2.  **2NF?** 否。存在多個部分相依性：
        *   `學生姓名` (`學生ID \to 學生姓名`) 只依賴於主鍵的一部分 `學生ID`。
        *   `課程名稱` (`課程ID \to 課程名稱`) 只依賴於主鍵的一部分 `課程ID`。
        *   `教師ID` (`課程ID \to 教師ID`) 只依賴於主鍵的一部分 `課程ID`。
        *   `教師姓名` (`課程ID \to 教師ID \to 教師姓名`，首先它依賴於 `教師ID`，而 `教師ID` 依賴於 `課程ID`，`課程ID` 是主鍵的一部分。所以 `教師姓名` 也是部分相依。)
    *   因此，此表不符合 2NF。

c) **分解到 3NF：**

*   **步驟 1：消除部分相依性 (達到 2NF)**
    *   **表 1：成績 (學生ID, 課程ID, 成績)**
        *   主鍵：`(學生ID, 課程ID)`。
        *   `成績` 完全函數相依於 `(學生ID, 課程ID)`。
        *   此表符合 2NF。

    *   **表 2：學生 (學生ID, 學生姓名)**
        *   主鍵：`學生ID`。
        *   根據 `學生ID \to 學生姓名` 創建。
        *   此表符合 2NF (且已是 3NF)。

    *   **表 3：課程 (課程ID, 課程名稱, 教師ID)**
        *   主鍵：`課程ID`。
        *   根據 `課程ID \to 課程名稱` 和 `課程ID \to 教師ID` 創建。
        *   此表目前符合 2NF。但我們還沒有考慮 `教師ID \to 教師姓名`。

*   **步驟 2：消除傳遞相依性 (達到 3NF)**
    *   檢查 `課程(課程ID, 課程名稱, 教師ID)` 表。
    *   我們知道 `教師ID \to 教師姓名`。如果 `教師姓名` 留在 `課程` 表中，那麼就會有 `課程ID \to 教師ID \to 教師姓名` 的傳遞相依。為了消除這個傳遞相依，需要將 `教師ID` 和 `教師姓名` 分離出來。

    *   **表 3 (調整後)：課程 (課程ID, 課程名稱, 教師ID)**
        *   主鍵：`課程ID`。
        *   此表已符合 3NF。

    *   **表 4：教師 (教師ID, 教師姓名)**
        *   主鍵：`教師ID`。
        *   根據 `教師ID \to 教師姓名` 創建。
        *   此表符合 3NF (且已是 BCNF)。

**最終分解到 3NF 的表格：**
1.  `成績(學生ID, 課程ID, 成績)`
2.  `學生(學生ID, 學生姓名)`
3.  `課程(課程ID, 課程名稱, 教師ID)`
4.  `教師(教師ID, 教師姓名)`

-----

#### 練習二：判斷 BCNF

**情境：** 一個專案成員技能表。
`專案成員技能(專案ID, 成員ID, 技能ID)`

**假設函數相依性 (FDs)：**
1.  `(專案ID, 成員ID) \to 技能ID` (一個成員在某專案中擁有的特定技能)
2.  `成員ID \to 專案ID` (一個成員只能隸屬於一個專案)

**問題：**
a) 判斷此表目前的主鍵是什麼？
b) 此表符合 3NF 嗎？請解釋。
c) 此表符合 BCNF 嗎？請解釋，若不符合，請分解。

**詳解：**

a) **判斷主鍵：**
    *   考慮 FD 1：`(專案ID, 成員ID)` 決定 `技能ID`。
    *   考慮 FD 2：`成員ID \to 專案ID`。這表示知道 `成員ID` 就能知道 `專案ID`。
    *   因此，`成員ID` 已經間接決定了 `專案ID`。
    *   我們可以推導出 `(成員ID, 技能ID)` 也是一個候選鍵：
        *   `成員ID` 決定 `專案ID` (FD 2)。
        *   `成員ID` 和 `技能ID` 聯合起來，由於 `成員ID` 已經決定了 `專案ID`，所以 `(專案ID, 成員ID, 技能ID)` 都可以被 `(成員ID, 技能ID)` 唯一識別。
    *   **因此，主鍵可以是 `(成員ID, 技能ID)` (或其他候選鍵，如 `(專案ID, 成員ID)`，但 `(成員ID, 技能ID)` 是更簡潔的候選鍵)。我們將 `(成員ID, 技能ID)` 視為主鍵。**

b) **此表符合 3NF 嗎？**
    *   **1NF：** 是。所有屬性都是原子性的，沒有重複組。
    *   **2NF：** 是。主鍵是 `(成員ID, 技能ID)`。所有屬性 (`專案ID`, `成員ID`, `技能ID`) 要麼是主鍵的一部分，要麼完全相依於主鍵（例如 `專案ID` 依賴於 `成員ID`，而 `成員ID` 是主鍵的一部分）。
        *   `專案ID` 是非主鍵屬性嗎？不，因為主鍵是 `(成員ID, 技能ID)`，`專案ID` 並不是主鍵的一部分。
        *   但 `成員ID \to 專案ID` 存在。`成員ID` 是主鍵的一部分，`專案ID` 是非主鍵屬性，且它只依賴於主鍵的一部分 `成員ID`。這是一個部分相依！
        *   讓我們重新評估 2NF。
    *   **重新評估 2NF：**
        *   主鍵：`(成員ID, 技能ID)`。
        *   非主鍵屬性：`專案ID`。
        *   存在部分相依性：`成員ID \to 專案ID` (`專案ID` 只依賴於主鍵的一部分 `成員ID`)。
        *   **結論：此表不符合 2NF。**

    *   **修正後，重新解答 b) 和 c)：**

b) **此表符合 3NF 嗎？**
    *   此表不符合 2NF，因為存在部分相依性 `成員ID \to 專案ID`。因此，它也不可能符合 3NF。

c) **此表符合 BCNF 嗎？請解釋，若不符合，請分解。**
    *   此表不符合 2NF，因此也不符合 BCNF。
    *   **分解到 BCNF：**
        *   **步驟 1：消除部分相依性 (達到 2NF)**
            *   根據 `成員ID \to 專案ID`，將 `成員ID` 和 `專案ID` 拆分出來。
            *   **新表一：成員專案(成員ID, 專案ID)**
                *   主鍵：`成員ID`。
                *   此表符合 2NF (且已是 3NF, BCNF)。
            *   原始表剩下 `(成員ID, 技能ID)`。
            *   **新表二：成員技能(成員ID, 技能ID)**
                *   主鍵：`(成員ID, 技能ID)`。
                *   此表符合 2NF (且已是 3NF, BCNF)。

        *   **步驟 2：消除傳遞相依性 (達到 3NF)**
            *   檢查分解後的表格 `成員專案` 和 `成員技能`。它們都沒有傳遞相依性。所以都符合 3NF。

        *   **步驟 3：檢查 BCNF**
            *   `成員專案(成員ID, 專案ID)`：主鍵是 `成員ID`。唯一的非平凡 FD 是 `成員ID \to 專案ID`，決定者 `成員ID` 是候選鍵。**符合 BCNF**。
            *   `成員技能(成員ID, 技能ID)`：主鍵是 `(成員ID, 技能ID)`。沒有其他非平凡 FD，且主鍵是唯一的決定者。**符合 BCNF**。

    *   **最終分解到 BCNF 的表格：**
        1.  `成員專案(成員ID, 專案ID)`
        2.  `成員技能(成員ID, 技能ID)`

-----

### 延伸閱讀/參考

*   **資料庫系統概念 (Database System Concepts)** by Silberschatz, Korth, Sudarshan：關聯式資料庫領域的經典教科書，對正規型態、函數相依性、無損連接和相依性保存有深入且權威的闡述。
*   **An Introduction to Database Systems** by C.J. Date：另一本資料庫領域的經典之作，從關係模型理論的根源詳細解釋了正規化。
*   **維基百科：資料庫正規化 (Wikipedia: Database normalization)**：提供全面的概述和各正規型態的簡潔定義。
*   **GeeksforGeeks: Normal Forms in DBMS**：一個流行的計算機科學學習網站，提供了豐富的例子和解釋。
*   **實踐經驗**：在設計實際的資料庫系統時，嘗試從業務需求出發，識別實體、屬性及其之間的關係，然後運用正規化原則進行設計。通過實踐，可以更好地理解正規化在減少冗餘、保證資料一致性以及權衡性能方面的價值。