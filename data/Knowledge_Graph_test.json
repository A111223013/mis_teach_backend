[
  {
    "school": "國立中央大學",
    "department": "網學所",
    "year": "106",
    "question_number": "46",
    "question_text": "Java 程式中,下列那一個不是二維陣列的合法宣告?",
    "options": [
      "a. int [x][];",
      "b. int x[][];",
      "c. int []x[];",
      "d. int [][]x;"
    ],
    "type": "single-choice",
    "image_file": [],
    "answer": "a",
    "detail-answer": "正確答案是 (a) int [x][];。在 Java 中，二維陣列的宣告必須遵守語法規則。選項 (b) int x[][];、(c) int []x[]; 與 (d) int [][]x; 都是合法的二維陣列宣告方式，只是書寫風格不同。而 (a) int [x][]; 並不符合 Java 語法規則，因為方括號不能寫在型別前的變數名稱位置。若要合法宣告二維陣列，必須以 int[][] x;、int x[][]; 或 int[] x[]; 的形式撰寫。\n\n此題主要考察 Java 語法中陣列宣告的規則，屬於程式語言基礎語法題，因此難度為中等。",
    "key-points": "資料結構",
    "difficulty level": "中等",
    "error reason": "",
    "micro_concepts": [
      "一維陣列",
      "二維陣列"
    ]
  },
  {
    "school": "國立中興大學",
    "department": "資訊管理學研究所",
    "year": "106",
    "question_number": "23",
    "question_text": "Which of the following is not a limitation of binary search algorithm?",
    "options": [
      "(A)Must use a sorted array.",
      "(B)Requirement of sorted array is expensive when a lot of insertion and deletions are needed.",
      "(C)There must be a mechanism to access middle element directly.",
      "(D)Cannot be applied to sorted binary trees."
    ],
    "type": "single-choice",
    "image_file": [],
    "answer": "需要根據選項判斷。若選項為二分搜尋的優點或非限制，則為正確答案。",
    "detail-answer": "本題旨在考察二分搜尋演算法的限制。二分搜尋的常見限制包括：資料必須已排序、需要隨機存取、插入和刪除成本高昂。因此，正確答案應為不屬於這些限制的選項，例如描述二分搜尋優點或非限制的陳述。由於題目未提供選項，無法直接選出答案，需根據選項内容來判斷。難度為中等，因為需要理解二分搜尋的特性及其限制。",
    "key-points": "資料結構",
    "difficulty level": "中等",
    "error reason": "",
    "micro_concepts": [
      "演算法定義",
      "程式效率分析"
    ]
  },
  {
    "school": "國立中興大學",
    "department": "資訊管理學研究所",
    "year": "106",
    "question_number": "C",
    "question_text": "Write a program-like pseudo codes using recursive call method to compute the combination formula $\\frac{n!}{k!(n-k)!}$. (10 points)",
    "options": [],
    "type": "short-answer",
    "image_file": [],
    "answer": "```\nfunction combination(n, k):\n  // Error Handling: Check for invalid inputs\n  if n < 0 or k < 0 or k > n:\n    return \"Invalid input: n and k must be non-negative, and k must be less than or equal to n.\"\n\n  // Base Cases:\n  if k == 0 or k == n:\n    return 1  // C(n, 0) = C(n, n) = 1\n  if k == 1:\n    return n  // C(n, 1) = n\n\n  // Recursive Step:\n  return combination(n-1, k-1) + combination(n-1, k)\n```",
    "detail-answer": "此虛擬碼使用遞迴的方式計算組合數 C(n, k)。\n\n*   **基本情況 (Base Cases):**\n    *   `k == 0 or k == n`:  C(n, 0) 和 C(n, n) 都等於 1，這是遞迴的終止條件。\n    *   `k == 1`: C(n, 1) 等於 n，這也是一個基本情況，能提高效率。\n*   **遞迴步驟 (Recursive Step):**\n    *   `combination(n-1, k-1) + combination(n-1, k)`: 使用帕斯卡恆等式 C(n, k) = C(n-1, k-1) + C(n-1, k) 將問題分解為兩個較小的子問題，並遞迴呼叫自身。\n*   **錯誤處理 (Error Handling):**\n    *   `if n < 0 or k < 0 or k > n`: 檢查輸入的有效性，如果 n 或 k 為負數，或 k 大於 n，則返回錯誤訊息。\n\n此方法基於數學公式和遞迴思想，將複雜的組合計算分解為更小的子問題，直到達到基本情況。 程式碼的難度在於理解遞迴的運作方式和如何將數學公式轉換為程式碼。錯誤處理的加入也提升了程式碼的健壯性。\n\n知識點屬於程式語言，考察遞迴演算法的設計和應用。",
    "key-points": "資料結構",
    "difficulty level": "中等",
    "error reason": "",
    "micro_concepts": [
      "遞迴"
    ]
  },
  {
    "school": "國立中興大學",
    "department": "資訊管理學研究所",
    "year": "106",
    "question_number": "25",
    "question_text": "Which of the following sorting algorithms can be used to sort a linked list, keeping time complexity in mind?",
    "options": [
      "(A)Insertion Sort",
      "(B)Selection Sort",
      "(C)Quick Sort",
      "(D)Merge Sort",
      "(E)Heap Sort"
    ],
    "type": "single-choice",
    "image_file": [],
    "answer": "Merge Sort",
    "detail-answer": "合併排序（Merge Sort）在鏈結串列（linked list）排序中表現良好，主要因為它不需要隨機存取，這對於鏈結串列的特性非常有利。鏈結串列不擅長隨機存取元素，而合併排序可以有效地對鏈結串列進行排序，且其時間複雜度為 O(n log n)，效率較高。雖然 iterative merge sort 在 linked list 上實現時，仍然需要額外的 O(1) 空間來追蹤子列表的頭尾指標，但相較於其他排序演算法，Merge Sort 依然是較佳選擇。氣泡排序（Bubble Sort）和插入排序（Insertion Sort）的時間複雜度為 O(n^2)，效率較差。快速排序（Quick Sort）原則上可用，但實作上較複雜，且效率會因為鏈結串列無法輕易 random access 而下降。因此，考慮到時間複雜度和鏈結串列的特性，合併排序是最適合的演算法。",
    "key-points": "資料結構",
    "difficulty level": "中等",
    "error reason": "",
    "micro_concepts": [
      "單向鏈結串列",
      "演算法定義",
      "程式效率分析",
      "合併排序"
    ]
  },
  {
    "school": "國立宜蘭大學",
    "department": "電子工程學系碩士班",
    "year": "106",
    "question_number": "二-4",
    "question_text": "(8分)請說明用以加速CPU處理速度之 pipeline 技術和 superscalar技術,請分別陳述之。",
    "options": [],
    "type": "long-answer",
    "image_file": [],
    "answer": "Pipeline技術將指令執行分解為多個階段並行處理，提高吞吐量；Superscalar技術允許CPU在每個時鐘週期執行多個指令，提高執行效率。",
    "detail-answer": "Pipeline (管線化)：將指令的執行分解為多個階段 (fetch, decode, execute, memory access, write back 等)。不同的指令在不同的階段並行處理，提高CPU的吞吐量，即單位時間內完成的指令數量。雖然單個指令的延遲可能沒有減少，但總體執行速度提高了。這是一種時間上的並行。\n\nSuperscalar (超純量)：允許 CPU 在每個時鐘週期執行多個指令。它依賴於指令級並行性 (ILP)，即在指令流中尋找可以並行執行的獨立指令。CPU 內部有多個執行單元，並且能夠同時將多個指令分派到這些執行單元。這需要複雜的控制邏輯來檢測指令之間的依賴關係，並保證正確的執行順序。這是一種空間上的並行。\n\n此題考察對CPU架構中兩種重要性能提升技術的理解，需要理解CPU的基本工作原理，以及兩種不同的加速技術，因此難度為中等。",
    "key-points": "作業系統",
    "difficulty level": "中等",
    "error reason": "",
    "micro_concepts": [
      "CPU排班"
    ]
  }
]